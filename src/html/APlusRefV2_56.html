<HTML>
<HEAD>
<TITLE>A+ Reference: The c Context</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME=HEADING671>
<H1><FONT color="#FF0000">The <A NAME=0>c Context</FONT></H1>
<a name="CONTENTS55">
<UL>
<A HREF="#HEADING672"> The Representation of C-Language Structures in A+</A><BR>
<UL>
<A HREF="#HEADING673">Table:&nbsp; A+ Symbols for Specifying C Data Types</A><BR>
</UL>
<A HREF="#HEADING674"> Functions that Modify Arguments</A><BR>
<UL>
<A HREF="#HEADING675"> Example</A><BR>
</UL>
<A HREF="#HEADING676"> Definitions of c-Context Functions</A><BR>
<UL>
<A HREF="#HEADING677"> A+ Array to Character Vector
 Representation</font></A><font face=Kapl> c.stuff{a}</font><BR>
<A HREF="#HEADING678"> A+ Array Header</A><font face=Kapl> c.AHeader{a}</font><BR>
<UL>
<A HREF="#HEADING682">Table:&nbsp; The Result of the Function<font face=Kapl>
 c.AHeader</font><BR>
<A HREF="#HEADING683">Table:&nbsp; A+ Types vs. the Type Specification in<font face=Kapl>
 c.AHeader</font> Result</A><BR>
</UL>
<A HREF="#HEADING679"> Character Value at Pointer Location</A><font face=Kapl>
 c.char_pointed_to_by{i}</font><BR>
<A HREF="#HEADING680"> Character Vector at Pointer Location</A><font face=Kapl>
 c.string_pointed_to_by{i}</font><BR>
<A HREF="#HEADING681"> Character Vector Representation to A+
 Array</A><font face=Kapl> c.unstuff{a}</font><BR>
<A HREF="#HEADING684"> Define a Structure</A><font face=Kapl>
 c.structdef{f;l;t}</font><BR>
<A HREF="#HEADING685"> Display the Contents of a Structure</A><font face=Kapl>
 c.structprint{s;a}</font><BR>
<A HREF="#HEADING686"> Floating-Point Value at Pointer
 Location</A><font face=Kapl> c.float_pointed_to_by{i}</font><BR>
<A HREF="#HEADING687"> Form</A><font face=Kapl> c.form</font><BR>
<A HREF="#HEADING688"> Get Values from a Structure</b></A><font face=Kapl>
 c.structget{s;a;f}</font><BR>
<A HREF="#HEADING689"> Integer Value at Pointer Location</A><font face=Kapl>
 c.int_pointed_to_by{i}</font><BR>
<A HREF="#HEADING690"> Pointer to an A+ Array Value</A><font face=Kapl>
 c.ptr{a}</font><BR>
<A HREF="#HEADING691"> Pointer to a Structure Value</A><font face=Kapl>
 c.pointer{s;a}</font><BR>
<A HREF="#HEADING692"> Realize a Structure</A><font face=Kapl>
 c.structcreate{s}</font><BR>
<A HREF="#HEADING693"> Set Values in a Structure</A><font face=Kapl>
 c.structset{s;a;f;v}</font><BR>
<A HREF="#HEADING694"> Size of a Structure</A><font face=Kapl>
 c.structsize{s}</font><BR>
<A HREF="#HEADING695"> Store a Character Value</A><font face=Kapl>
 c.place_chars_at{a;i}</font><BR>
<A HREF="#HEADING696"> Store a Floating-Point Value</A><font face=Kapl>
 c.place_floats_at{a;i}</font><BR>
<A HREF="#HEADING697"> Store an Integer Value</A><font face=Kapl>
 c.place_ints_at{a;i}</font><BR>
<A HREF="#HEADING698"> Structure Value at Pointer Location</A><font face=Kapl>
 c.struct_pointed_to_by{s;i}</font><BR>
<A HREF="#HEADING699"> Type Double Value at Pointer Location</A><font face=Kapl>
 c.double_pointed_to_by{i}</font><BR>
<A HREF="#HEADING700"> Type Short Value at Pointer Location</A><font face=Kapl>
 c.short_pointed_to_by{i}</font><BR>
<A HREF="#HEADING701"> Type of a Structure</A><font face=Kapl> c.structtype{s}</font><BR>
</UL>
</UL>
<HR>
<blockquote>
The c context is native to A+.  It is not to be loaded.<P>
The c context provides utilities for creating, manipulating, and examining C-language
 structures and pointers to data. Pointers are represented as scalar integers in A+. The
 representation of structures is more complicated, and is discussed below in
 "<A HREF="#2">The Representation of C-Language Structures in A+</A>". The definitions of
 the c-context functions for structures follow that section.
</blockquote>
<A NAME=HEADING672>
<H1><FONT color="#20B2AA">The <A NAME=2>Representation of C-Language Structures in A+</FONT></H1>
<blockquote>
A <A NAME=3>C-language structure is represented in A+ by three vectors: a vector of symbols
 for member names that the user can choose; a vector of integers defining the length of
 each member; and a vector of symbols describing the storage type of each member. The
 symbols for specifying storage types are given in the table "<A HREF="#4">A+ Symbols for
 Specifying C Data Types</A>". The storage types <font face=Kapl>`struct1</font>,
 <font face=Kapl>`struct2</font>, <font face=Kapl>`struct3</font>,
 <font face=Kapl>`struct4</font> are for members that are structures, and in these cases
 the corresponding element of the length vector is the length of the structure, in bytes.
 In all other cases the element of the length vector is the number of elements in the
 member; if the length is greater than 1, then the member is assumed to be an array,
 whereas if the length is 1 the element is assumed to be a scalar.<P>
A C-language structure created from these vectors can be passed to C programs that have
 been dynamically loaded to the A+ session.  Each C datatype is properly aligned in the
 structure for the machine on which A+ is running.
<A NAME=HEADING673>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
A+ <A NAME=4>Symbols for Specifying C Data Types</B></FONT></caption>
<tr>
<th>A+ Symbol</th><th>C Data Type</th>
<th rowspan=8>&nbsp;</th>
<th>A+ Symbol</th><th>C Data Type</th></tr>
<tr>
<td><font face=Kapl>`char</font></td><td>char</td>
<td><font face=Kapl>`struct1</font></td><td>char aligned on one-byte boundary</td></tr>
<tr>
<td><font face=Kapl>`u_char</font></td><td>unsigned char</td>
<td><font face=Kapl>`struct2</font></td><td>char aligned on two-byte boundary</td></tr>
<tr>
<td><font face=Kapl>`short</font></td><td>short</td>
<td><font face=Kapl>`struct4</font></td><td>char aligned on four-byte boundary</td></tr>
<tr>
<td><font face=Kapl>`u_short</font></td><td>unsigned short</td>
<td><font face=Kapl>`struct8</font></td><td>char aligned on eight-byte boundary</td></tr>
<tr>
<td><font face=Kapl>`int</font></td><td>int</td>
<td><font face=Kapl>`pointer</font></td><td>void*</td></tr>
<tr>
<td><font face=Kapl>`u_int</font></td><td>unsigned int</td>
<td><font face=Kapl>`float</font></td><td>float</td></tr>
<tr>
<td><font face=Kapl>`long</font></td><td>long</td>
<td><font face=Kapl>`double</font></td><td>double</td></tr>
<tr>
<td><font face=Kapl>`u_long</font></td><td>unsigned long</td>
<td colspan=3>&nbsp;</td></tr>
</table><P>
</blockquote>
<A NAME=HEADING674>
<H1><FONT color="#20B2AA">Functions <A NAME=6>that Modify Arguments</FONT></H1>
<blockquote>
<A NAME=7>Functions in this chapter, e.g., <font face=Kapl>c.structset</font>, may modify one of their arguments.  In such cases, the argument should have a name and the name should be used in the argument position, for then you can see the changes after the function has completed execution.  In addition, you must be sure that other objects are not modified as well.  The reason is that A+ manages reference counts on objects, meaning that at any point in an execution two or more names can actually share the same array value; sharing stops when the value of one of the objects changes in a normal A+ way.  However, the modification of an array value by a function like <font face=Kapl>c.structset</font> is not a normal A+ value change, and all names that had previously shared the value will now shared the modified value, unless prevented.  The remedy is to replace the named argument <font face=Kapl>a</font> with something like <font face=Kapl>a0û(Òa)Òa</font>.
</blockquote>
<A NAME=HEADING675>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Example</FONT></H2>
<blockquote>
A simple example will serve to illustrate most of the functions in this chapter. Consider
 the C-language structures
<pre><font face=Courier>     struct s1 {
       int        fieldA;
       short      fieldB[4];
     };

     struct s2 {
       int        field1;
       struct s1  field2;
       struct s1  *field3;
     };</font></pre>
The s1 structure is represented in A+ as:
<pre><font face=Kapl>     s1_membersû`fieldA`fieldB
     s1_lengthsû1 4
     s1_typesû`int`short</font></pre>
The function <font face=Kapl>c.structdef</font> produces another A+ representation that includes various information about the structure, such as offsets, and which is used to create the actual structures, insert values, and extract values:
<pre><font face=Kapl>     s1ûc.structdef{s1_members;s1_lengths;s1_types}</font></pre>
The second structure can now be represented:
<pre><font face=Kapl>     s2_membersû`field1`field2`field3
     s2_lengthsû1,(c.structsize s1),1
     s2_typesû`int,(c.structtype s1),`pointer</font></pre>
Structures with these definitions can now be realized:
<pre><font face=Kapl>     s1_dataûc.structcreate s1
     s2ûc.structdef{s2_members;s2_lengths;s2_types}
     s2_dataûc.structcreate s2</font></pre>
When you put data in the realized structures, the value returned by <font face=Kapl>c.structset</font> is the updated structure:
<pre><font face=Kapl>     c.structset{s1;s1_data;`fieldA`fieldB;(3;6 7 8 9)}
 3 393223 524297 0
     s1_data
 3 393223 524297 0
     c.structset{s2;s2_data;`field1;345}
 345 0 0 0 0 0
     c.structset{s2;s2_data;`field2`field3;
               (s1_data;c.pointer{s1;s1_data})}
 345 3 393223 524297 67120480 0</font></pre>
You use <font face=Kapl>c.structget</font> to retrieve the data:
<pre><font face=Kapl>     c.structget{s1;s1_data;`fieldB}
 6 7 8 9
     mûc.structget{s2;s2_data;`field2}
     c.structget{s1;m;`fieldB}
c.structget{s1;m;`fieldB}
     pûc.structget{s2;s2_data;`field3}
     nûc.struct_pointed_to_by{s1;p}
     c.structget{s1;n;`fieldB}
c.structget{s1;m;`fieldB}</font></pre>
Display the contents of the structures:
<pre><font face=Kapl>      c.structprint{s1;s1_data}
fieldA:(int): 3
fieldB:(short): 6 7 8 9
     c.structprint{s2;s2_data}
field1:(int): 345
field2:(struct4): ----
field3:(pointer): 67120480</font></pre>
</blockquote>
<A NAME=HEADING676>
<H1><FONT color="#20B2AA">Definitions of c-Context Functions</FONT></H1>
<A NAME=HEADING677>
<H2><FONT color="#20B2AA">A+ <A NAME=9>Array to Character Vector Representation<font face=Kapl>  c.stuff{a}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is an A+ array.  The result is a character vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is a character vector representation of the of the A+ array <font face=Kapl>a</font>.<P>
Note: The functions <font face=Kapl>sys.exp</font> and <font face=Kapl>sys.imp</font> should be used in place of <font face=Kapl>c.stuff</font> and <font face=Kapl>c.unstuff</font>.
</BLOCKQUOTE>
<A NAME=HEADING678>
<H2><FONT color="#20B2AA">A+ Array <A NAME=12>Header  <font face=Kapl>c.AHeader{a}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is any A+ array.  The result is a five-element nested vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result contains all the information in the internal header of an A+ array.  The meaning
 of the elements of the result are in the tables "<A HREF="#20">The Result of the Function
 c.AHeader</A>" and "<A HREF="#21">A+ Types vs. the Type Specification in c.AHeader
 Result</A>".
<A NAME=HEADING682>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
The <A NAME=20>Result of the Function c.AHeader</B></FONT></caption>
<tr>
<th>Element Index</th><th>Description</th></tr>
<tr>
<td>0</td><td>An enclosed integer scalar holding the reference count of the array.</td></tr>
<td>1</td><td>An enclosed character vector representing the type of the array
 (see <A HREF="#21">next table</A>).</td></tr>
<td>2</td><td>An enclosed integer scalar holding the rank of the array.</td></tr>
<td>3</td><td>An enclosed integer scalar holding the element count of the array.</td></tr>
<td>4</td><td>An enclosed integer vector holding the shape of the array.</td></tr>
</table>
<A NAME=HEADING683>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
A+ <A NAME=21>Types vs. the Type Specification in c.AHeader Result</B></FONT></caption>
<tr>
<th>A+ Type</th><th>c.AHeader Value</th>
<td rowspan=5>&nbsp;</td>
<th>A+ Type</th><th>c.AHeader Value</th></tr>
<tr>
<td>integer</td><td><font face=Kapl>"It"</font></td>
<td>derived function</td><td><font face=Kapl>"Xt"</font></td></tr>
<tr>
<td>floating point</td><td><font face=Kapl>"Ft"</font></td>
<td>user defined function</td><td><font face=Kapl>"Xt+1"</font></td></tr>
<tr>
<td>character</td><td><font face=Kapl>"Ct"</font></td>
<td>monadic operator</td><td><font face=Kapl>"Xt+2"</font></td></tr>
<tr>
<td>nested, symbol, or function array</td><td><font face=Kapl>"Et"</font></td>
<td>dyadic operator</td><td><font face=Kapl>"Xt+3"</font></td></tr>
</table>
</blockquote>
<A NAME=HEADING679>
<H2><FONT color="#20B2AA">Character Value at <A NAME=15>Pointer Location<font face=Kapl>  c.char_pointed_to_by{i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is a one-element integer array.  The result is a character scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a C-language char value.  The result is that value as an A+ scalar of type <font face=Kapl>`char</font>.</BLOCKQUOTE>
<A NAME=HEADING680>
<H2><FONT color="#20B2AA">Character <A NAME=17>Vector at Pointer Location <font face=Kapl> c.string_pointed_to_by{i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is a one-element integer array.  The result is a character vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a C-language char string.  The result is that value as an A+ character vector.</BLOCKQUOTE>
<A NAME=HEADING681>
<H2><FONT color="#20B2AA">Character <A NAME=19>Vector Representation to A+ Array<font face=Kapl>  c.unstuff{a}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is an A+ character vector.  The result is an A+ array.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>c.unstuff</font> is a left inverse of <font face=Kapl>c.stuff</font>:<P>
<pre><font face=Kapl>     c.unstuff c.stuff x</font></pre>
is identical to <font face=Kapl>x</font> for any A+ array <font face=Kapl>x</font>.<P>
<b>Note:</b> The functions <font face=Kapl>sys.exp</font> and <font face=Kapl>sys.imp</font> should be used in place of <font face=Kapl>c.stuff</font> and <font face=Kapl>c.unstuff</font>.</BLOCKQUOTE>
<A NAME=HEADING684>
<H2><FONT color="#20B2AA">Define a <A NAME=24>Structure<font face=Kapl>  c.structdef{f;l;t}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The arguments <font face=Kapl>f</font> and <font face=Kapl>t</font> are vectors of symbols, while <font face=Kapl>l</font> is a vector of integers.  All three vectors have the same length.  The result is a general array of the form<font face=Kapl> (g;m;u;o;c)</font>, where <font face=Kapl>g</font> is identical to the argument <font face=Kapl>f</font>, <font face=Kapl>m </font> is identical to the argument <font face=Kapl>l</font>, <font face=Kapl>u</font>  is identical to the argument <font face=Kapl>t</font>, and <font face=Kapl>o</font> and <font face=Kapl>c</font> are integer vectors of length one more than the length of the argument vectors.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The arguments <font face=Kapl>f</font>, <font face=Kapl>t</font>, and <font face=Kapl>l</font> represent a C-language structure (see "<A HREF="#2">The Representation of C-Language Structures in A+</A>").  For each integer <font face=Kapl>i</font> that is a valid index of the argument vectors <font face=Kapl>f</font>, <font face=Kapl>l</font>, and <font face=Kapl>t</font>, the triple <font face=Kapl>f[i]</font>, <font face=Kapl>l[i]</font>, and <font face=Kapl>t[i]</font> represents a member of the structure.  The integer <font face=Kapl>o[i]</font> is the offset in bytes from the beginning of the structure to the beginning of this member.  The integer <font face=Kapl>c[i]</font> is a type code representing the storage type of the member.  If <font face=Kapl>n</font> is the number of elements in the argument vectors then <font face=Kapl>o[n]</font> and <font face=Kapl>c[n]</font> are both defined; <font face=Kapl>o[n]</font> is the size of the structure in bytes, and <font face=Kapl>c[n]</font> is the alignment factor for the structure.<P>
The contents of <font face=Kapl>o</font> will be different for different computer architectures, so it is best not to store results of <font face=Kapl>c.structdef</font> in A+ script files.</BLOCKQUOTE>
<A NAME=HEADING685>
<H2><FONT color="#20B2AA">Display <A NAME=26>the Contents of a Structure<font face=Kapl>  c.structprint{s;a}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments</b><BLOCKQUOTE>
The left argument <font face=Kapl>s</font> is a five-element nested vector and the right argument <font face=Kapl>a</font> is an integer vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a structure definition, i.e., a result of <font face=Kapl>c.structdef</font>.  The argument <font face=Kapl>a</font> is a structure specified by <font face=Kapl>s</font>; at one point it was a result of <font face=Kapl>c.structcreate</font>, and most likely <font face=Kapl>c.structset</font>.  The effect of this function is to display the contents of the structure <font face=Kapl>a</font>.  Members that are structures are noted, but their values are not displayed.</BLOCKQUOTE>
<A NAME=HEADING686>
<H2><FONT color="#20B2AA">Floating-Point <A NAME=28>Value at Pointer Location  <font face=Kapl>c.float_pointed_to_by{i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is a one-element integer array.  The result is a floating-point scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a C-language float value.  The result is that value as an A+ scalar of type <font face=Kapl>`float</font>.</BLOCKQUOTE>
<A NAME=HEADING687>
<H2><FONT color="#20B2AA">Form  <A NAME=30><font face=Kapl>c.form</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function used to be in the d context; d is a relational data base toolkit in A, the predecessor of A+.  The function is provided in A+ for migration purposes.</BLOCKQUOTE>
<A NAME=HEADING688>
<H2><FONT color="#20B2AA">Get <A NAME=32>Values from a Structure<font face=Kapl>  c.structget{s;a;f}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a five-element nested vector and <font face=Kapl>a</font> is an integer vector.  The argument <font face=Kapl>f</font> is either a one-element symbol array or a vector of symbols.  If <font face=Kapl>f</font> has one element then the result is either a simple scalar or a simple vector with two or more elements; if <font face=Kapl>f</font> has more than one element, the result is a nested vector with the same number of elements as <font face=Kapl>f</font>, and each element of the result is either a simple scalar or a simple vector with two or more elements.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a structure definition, i.e., a result of <font face=Kapl>c.structdef</font>.  The argument <font face=Kapl>a</font> is a structure specified by <font face=Kapl>s</font>; at one point it was a result of <font face=Kapl>c.structcreate</font>, and most likely <font face=Kapl>c.structset</font>.  The result holds the values in the structure <font face=Kapl>a</font> for the members specified by <font face=Kapl>f</font>.</BLOCKQUOTE>
<A NAME=HEADING689>
<H2><FONT color="#20B2AA">Integer <A NAME=34>Value at Pointer Location<font face=Kapl>  c.int_pointed_to_by{i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is a one-element integer array.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a C-language int value.  The result is that value as an A+ scalar of type <font face=Kapl>`int</font>.</BLOCKQUOTE>
<A NAME=HEADING690>
<H2><FONT color="#20B2AA">Pointer <A NAME=36>to an A+ Array Value<font face=Kapl>  c.ptr{a}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is any A+ array.  The result is a scalar integer.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is a pointer to the data area of the A+ array <font face=Kapl>a</font>.</BLOCKQUOTE>
<A NAME=HEADING691>
<H2><FONT color="#20B2AA">Pointer <A NAME=38>to a Structure Value  <font face=Kapl>c.pointer{s;a}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>s</font> is a five-element nested vector and the right argument <font face=Kapl>a</font> is an integer vector.  The result is a scalar integer.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a structure definition, i.e., a result of <font face=Kapl>c.structdef</font>.  The argument <font face=Kapl>a</font> is a structure specified by <font face=Kapl>s</font>; at one point it was a result of <font face=Kapl>c.structcreate</font>, and most likely <font face=Kapl>c.structset</font>.  The result is a pointer to the beginning of the actual data of the structure (in the data area of <font face=Kapl>a</font>).</BLOCKQUOTE>
<A NAME=HEADING692>
<H2><FONT color="#20B2AA">Realize <A NAME=40>a Structure <font face=Kapl> c.structcreate{s}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a five-element nested vector.  The result is an integer vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a structure definition, i.e., a result of <font face=Kapl>c.structdef</font>.  The result is an integer vector large enough to hold a structure defined by <font face=Kapl>s</font>, and initialized to 0.  The result is called a structure initialization.</BLOCKQUOTE>
<A NAME=HEADING693>
<H2><FONT color="#20B2AA">Set <A NAME=42>Values in a Structure<font face=Kapl>  c.structset{s;a;f;v}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a five-element nested vector and <font face=Kapl>a</font> is an integer vector.  The argument <font face=Kapl>f</font> is either a one- element symbol array or a vector of symbols.  If <font face=Kapl>f</font> has one element, then the argument <font face=Kapl>v</font> is a simple array.  If <font face=Kapl>f</font> has more than one element, then <font face=Kapl>v</font> is a nested array of depth 1 with the same number of elements as <font face=Kapl>f</font>.  This function directly modifies the value of the argument <font face=Kapl>a</font> (see "<A HREF="#6">Functions that Modify Arguments</A>").  The result is an integer vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a structure definition, i.e., a result of <font face=Kapl>c.structdef</font>.  The argument <font face=Kapl>a</font> is a structure specified by <font face=Kapl>s</font>; at one point it was a result of <font face=Kapl>c.structcreate</font>.  The argument <font face=Kapl>f</font> specifies members of the structure <font face=Kapl>a</font>, and <font face=Kapl>v</font> specifies values for those members.  The effect of this function is to assign these values to those members of <font face=Kapl>a</font>.  A value in <font face=Kapl>v</font> can have a different number of elements than is defined for that member.  If it has more elements, only as many as needed are inserted in <font face=Kapl>a</font>.  If it has fewer, then the contents of the member beyond the values supplied by <font face=Kapl>v</font> may be unpredictable.<P>
All values in <font face=Kapl>v</font> that correspond to integer or floating-point members in the structure should be of A+ type <font face=Kapl>`int</font> or <font face=Kapl>`float</font>, respectively.  Values in <font face=Kapl>v</font> that correspond to structure members should be results of <font face=Kapl>c.structset</font> for those structures.  The result of this function is the modified argument <font face=Kapl>a</font>.</BLOCKQUOTE>
<A NAME=HEADING694>
<H2><FONT color="#20B2AA">Size <A NAME=44>of a Structure<font face=Kapl>  c.structsize{s}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a five-element nested vector.  The result is an integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a structure definition, i.e., a result of <font face=Kapl>c.structdef</font>.  The result is the size, in bytes, of the structure defined by <font face=Kapl>s</font>.<P>
Similarly to <font face=Kapl>c.structdef</font>, the result of c.structsize will be different for different computer architectures, so it is best not to store these results in A+ script files.</BLOCKQUOTE>
<A NAME=HEADING695>
<H2><FONT color="#20B2AA">Store <A NAME=48>a Character Value<font face=Kapl>  c.place_chars_at{a;i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments</b><BLOCKQUOTE>
The left argument <font face=Kapl>a</font> is a character array.  The right argument <font face=Kapl>i</font> is a scalar integer.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a list of C-language char values.  The effect of this function is put the elements of <font face=Kapl>a</font> in that list (in <font face=Kapl>,a</font> order).</BLOCKQUOTE>
<A NAME=HEADING696>
<H2><FONT color="#20B2AA">Store <A NAME=50>a Floating-Point Value  <font face=Kapl>c.place_floats_at{a;i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments</b><BLOCKQUOTE>
The left argument <font face=Kapl>a</font> is a floating-point array.  The right argument <font face=Kapl>i</font> is a scalar integer.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a list of C-language double values.  The effect of this function is put the elements of <font face=Kapl>a</font> in that list (in <font face=Kapl>,a</font> order).</BLOCKQUOTE>
<A NAME=HEADING697>
<H2><FONT color="#20B2AA">Store <A NAME=52>an Integer Value  <font face=Kapl>c.place_ints_at{a;i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments</b><BLOCKQUOTE>
The left argument <font face=Kapl>a</font> is an integer array.  The right argument <font face=Kapl>i</font> is a scalar integer.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a list of C-language int values.  The effect of this function is put the elements of <font face=Kapl>a</font> in that list (in <font face=Kapl>,a</font> order).</BLOCKQUOTE>
<A NAME=HEADING698>
<H2><FONT color="#20B2AA">Structure <A NAME=54>Value at Pointer Location<font face=Kapl>  c.struct_pointed_to_by{s;i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>s</font> is a five-element nested vector.  The right argument <font face=Kapl>i</font> is a one-element integer array.  The result is an integer vector.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a structure definition, i.e., a result of <font face=Kapl>c.structdef</font>.  The integer <font face=Kapl>i</font> is a pointer to a C-language structure that is equivalent to one defined by <font face=Kapl>s</font>.  The result is an integer vector holding a copy of that structure.</BLOCKQUOTE>
<A NAME=HEADING699>
<H2><FONT color="#20B2AA">Type <A NAME=56>Double Value at Pointer Location<font face=Kapl>  c.double_pointed_to_by{i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is a one-element integer array.  The result is a floating-point scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a C-language double value.  The result is that value as an A+ scalar of type <font face=Kapl>`float</font>.</BLOCKQUOTE>
<A NAME=HEADING700>
<H2><FONT color="#20B2AA">Type <A NAME=58>Short Value at Pointer Location<font face=Kapl>  c.short_pointed_to_by{i}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is a one-element integer array.  The result is a integer scalar.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The integer <font face=Kapl>i</font> is a pointer to a C-language short value.  The result is that value as an A+ scalar of type <font face=Kapl>`int</font>.</BLOCKQUOTE>
<A NAME=HEADING701>
<H2><FONT color="#20B2AA">Type <A NAME=60>of a Structure  <font face=Kapl>c.structtype{s}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a five-element nested vector.  The result is a symbol scalar or the integer 0.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a structure definition, i.e., a result of <font face=Kapl>c.structdef</font>.  The result is the type of the structure, i.e., one of <font face=Kapl>`struct1</font>, <font face=Kapl>`struct2</font>, <font face=Kapl>`struct4</font>, or <font face=Kapl>`struct8</font>, depending on whether the structure definition contains at most one-byte members, two-byte, four-byte, or eight-byte, respectively.  Otherwise the result is 0, which would most likely indicate a damaged structure definition.</BLOCKQUOTE>
<HR>
<ADDRESS><table width="100%"><tr><td><font size=2><i><a href="mailto:doc@aplusdev.org">doc@aplusdev.org</a></i></font></td><td align=right><font size=2><i>&#169; Copyright 1995&#150;2008 Morgan Stanley Dean Witter &amp; Co.  All rights reserved.</i></font></td></tr></table></ADDRESS>
</BODY>
</HTML>

