<HTML>
<HEAD>
<TITLE>A+ Reference: System Functions</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME=HEADING267>
<H1><FONT color="#FF0000">System<A NAME=0> Functions</FONT></H1>
<a name="CONTENTS13">
<UL>
<A HREF="#HEADING268"> Classification of System Functions</A><BR>
<A HREF="#HEADING269"> Querying Syntax</A><BR>
<A HREF="#HEADING270"> Common Error Reports</A><BR>
<A HREF="#HEADING271"> Definitions of System Functions</A><BR>
<UL>
<A HREF="#HEADING272"> The Name Argument</A><BR>
<A HREF="#HEADING272A"> Abort Loading of Script</A><font face=Kapl> _abortload{}</font><BR>
<A HREF="#HEADING273"> All Attributes</A><font face=Kapl> _atts{y;x}</font><BR>
<A HREF="#HEADING274"> All Dependent Object Names</A><font face=Kapl> _alldep{x}</font><BR>
<A HREF="#HEADING275"> Association List to Slotfiller</A><font face=Kapl> _alsf{x}</font><BR>
<A HREF="#HEADING276"> Change Directory</A><font face=Kapl> _cd{x}</font><BR>
<A HREF="#HEADING277"> Comma Fix Input</A><font face=Kapl> _cfi{y;x}</font><BR>
<A HREF="#HEADING278"> Debug</A><font face=Kapl> _dbg{x}</font><BR>
<A HREF="#HEADING279"> Dependency Definition</A><font face=Kapl> _def{x}</font><BR>
<A HREF="#HEADING280"> Dependent Object Names</A><font face=Kapl> _dep{x}</font><BR>
<A HREF="#HEADING281"> Dynamic Load</A><font face=Kapl> _dyld{x;y}</font><BR>
<A HREF="#HEADING281A"> Execution Profile</A><font face=Kapl> _profile{x}</font><BR>
<A HREF="#HEADING282"> Exit</A><font face=Kapl> _exit{x}</font><BR>
<A HREF="#HEADING283"> Expunge</A><font face=Kapl>  _ex{x}</font><BR>
<A HREF="#HEADING284"> Expunge Context</A><font face=Kapl> _excxt{x}</font><BR>
<A HREF="#HEADING285"> Fix Input</A><font face=Kapl> _fi{y;x}</font><BR>
<A HREF="#HEADING286"> Flatten</A><font face=Kapl> _flat{x}</font><BR>
<A HREF="#HEADING287"> Format</A><font face=Kapl> _fmt{y;x}</font><BR>
<UL>
<A HREF="#HEADING288">Table:&nbsp; Format Phrases</A><BR>
<A HREF="#HEADING289">Table:&nbsp; Qualifiers</A><BR>
<A HREF="#HEADING290">Table:&nbsp; Decorators</A><BR>
</UL>
<A HREF="#HEADING291"> General Search and Replace</A><font face=Kapl> _gsr{y;x;r;n}</font><BR>
<A HREF="#HEADING292"> Get Attribute</A><font face=Kapl> _get{y;x}</font><BR>
<A HREF="#HEADING293"> Get Callback</A><font face=Kapl> _gcb{y}</font><BR>
<A HREF="#HEADING294"> Get Client Data</A><font face=Kapl> _gcd{y}</font><BR>
<A HREF="#HEADING295"> Get Format Symbols</A><font face=Kapl> _gfmtsym{}</font><BR>
<A HREF="#HEADING296"> Get Preset Callback</A><font face=Kapl> _gpcb{y}</font><BR>
<A HREF="#HEADING297"> Get System Variable</A><font face=Kapl> _gsv{x}</font><BR>
<A HREF="#HEADING298"> Hash Table Statistics</A><font face=Kapl> _hashstat{x}</font><BR>
<A HREF="#106"> Index of</A><font face=Kapl>  _index_of{y;x}</font><BR>
<A HREF="#HEADING299"> Is a Slotfiller</A><font face=Kapl> _issf{x}</font><BR>
<A HREF="#HEADING300"> Items of a Mapped File</A><font face=Kapl> _items{y;x}</font><BR>
<A HREF="#HEADING302"> Load</A><font face=Kapl> _load{x}</font><BR>
<A HREF="#HEADING303"> Load and Remove</A><font face=Kapl> _loadrm{`delete;x}</font><BR>
<A HREF="#HEADING304"> Locals</A><font face=Kapl> _locals{x}</font><BR>
<A HREF="#HEADING305"> Name</A><font face=Kapl> _name{x}</font><BR>
<A HREF="#HEADING306"> Name Class</A><font face=Kapl> _nc{y;x}</font><BR>
<UL>
<A HREF="#HEADING307">Table:&nbsp; Name Classes</A><BR>
</UL>
<A HREF="#HEADING308"> Name List</A><font face=Kapl> _nl{y;x}</font><BR>
<UL>
<A HREF="#HEADING309">Table:&nbsp; Name List Expressions vs. The Kind of Objects in the Result</A><BR>
</UL>
<A HREF="#HEADING310"> Name Search</A><font face=Kapl> _ns{y;x}</font><BR>
<A HREF="#HEADING311"> Name Search and Replace</A><font face=Kapl> _nsr{y;x;r}</font><BR>
<A HREF="#HEADING312"> NaN Find</A><font face=Kapl> _nanfind{x}</font><BR>
<A HREF="#HEADING313"> Permissive Indexing</A><font face=Kapl> _index{i;x;d}</font><BR>
<A HREF="#HEADING314"> Remove Dependency Definition</A><font face=Kapl> _undef{name}</font><BR>
<A HREF="#HEADING315"> Scalar Comma Fix Input</A><font face=Kapl> _scfi{s}</font><BR>
<A HREF="#HEADING316"> Scalar Fix Input</A><font face=Kapl> _sfi{s}</font><BR>
<A HREF="#HEADING317"> Screen Format</A><font face=Kapl> _sfmt{f;d}</font><BR>
<A HREF="#HEADING318"> Set Attribute</A><font face=Kapl> _set{y;x}</font><BR>
<A HREF="#HEADING319"> Set Callback</A><font face=Kapl> _scb{y;x}</font><BR>
<A HREF="#HEADING320"> Set Client Data</A><font face=Kapl> _scd{y;x}</font><BR>
<A HREF="#HEADING321"> Set Preset Callback</A><font face=Kapl> _spcb{y;x}</font><BR>
<A HREF="#HEADING322"> Set System Variable</A><font face=Kapl> _ssv{y;x}</font><BR>
<A HREF="#HEADING323A"> Stack Information</A><font face=Kapl> _doErrorStack{}</font><BR>
<A HREF="#HEADING323"> String Search</A><font face=Kapl> _ss{y;x}</font><BR>
<A HREF="#HEADING324"> String Search and Replace</A><font face=Kapl> _ssr{y;x;r}</font><BR>
<A HREF="#HEADING325"> Valence</A><font face=Kapl> _valence{x}</font><BR>
<A HREF="#HEADING326"> Work Area</A><font face=Kapl> _wa{x}</font><BR>
<UL>
<A HREF="#HEADING327">Table:&nbsp; Arguments and Results for Work Area</A><BR>
</UL>
</UL>
</UL>
<HR>
<A NAME=HEADING268>
<H1><FONT color="#20B2AA">Classification <A NAME=1>of System Functions</FONT></H1>
<blockquote>
<A NAME=2>Although they are listed alphabetically by English name in this chapter, for convenient reference, the A+ system functions can be grouped, among many other ways, in ten categories, dealing with:<P>
<UL>
<LI>system variables: &nbsp; Get System Variable, Set System Variable;<P>
<LI>names and references: &nbsp; Expunge, Expunge Context, Locals, Name, Name Class, Name List, Valence;<P>
<LI>attributes: &nbsp; All Attributes, Get Attribute, Set Attribute, Get Client Data, Set Client Data;<P>
<LI>dependencies: &nbsp; All Dependent Object Names, Dependency Definition, Dependent Object Names, Remove Dependency Definition;<P>
<LI>callbacks: &nbsp; Get Callback, Get Preset Callback, Set Callback, Set Preset Callback;<P>
<LI>files: &nbsp; Abort Loading of Script, Change Directory, Dynamic Load, Items of a Mapped File, Load a File, Load and Remove a File;<P>
<LI>format changes: &nbsp; Association List to Slotfiller, Comma Fix Input, Fix Input, Flatten, Format, Scalar Comma Fix Input, Scalar Fix Input, Screen Format, Get Format Symbols, Is a Slotfiller;<P>
<LI>text functions: &nbsp; General Search and Replace, Index Of, Name Search, Name Search and Replace, String Search, String Search and Replace;<P>
<LI>indexing: &nbsp; Permissive Indexing;<P>
<LI>debugging: &nbsp; Debug, NaN Find, Stack Information;<P>
<LI>A+ operation and space: &nbsp; Execution Profile, Exit, Hash Table Statistics, Work Area.
</UL>
</blockquote>
<A NAME=HEADING269>
<H1><FONT color="#20B2AA">Querying <A NAME=3>Syntax </FONT></H1>
<blockquote>
To inquire about the syntax of a system function or external function in an A+ session, enter its name alone on a line.  For example:
<pre><font face=Kapl>     _nl
 _nl{any;any} returns any</font></pre>
Because some of the system functions take more than two arguments, they are all shown here
 in general form, for uniformity, and that is how a syntax query is answered.  Nevertheless,
 infix notation can also, of course, be used to invoke the monadic and dyadic system
 functions.
</blockquote>
<A NAME=HEADING270>
<H1><FONT color="#20B2AA">Common <A NAME=5>Error Reports</FONT></H1>
<blockquote>
Multiple errors elicit but one report.  If an error report in the following list is issued, then the ones preceding it do not apply.  Seven reports are common to all system functions:<P>
<UL>
<LI>parse;
<LI>value: an argument has no value;
<LI>valence: the wrong number of arguments were given;
<LI>nondata: the argument is a function or some other nondata object;
<LI>type or domain: an argument is of the wrong type (nested when it should be simple, numeric when it should be a symbol, and so on) or the wrong class (e.g., a symbol, but not from some required set of symbols); the same error is called type by some functions and domain by others;
<LI>length: a single number is required and the ravel of the argument does not have a length of one;
<LI>wsfull: the workspace is currently not large enough to execute the function in; a bare left arrow (</font><font face=Kapl>û</font>), which dictates resumption of execution, causes the workspace to be enlarged if possible;
<LI>interrupt (not an error): the user pressed <B>c</B> twice while holding the <B>Control</B> key down.
</UL>
</blockquote>
<A NAME=HEADING271>
<H1><FONT color="#20B2AA">Definitions of System Functions</FONT></H1>
<A NAME=HEADING272>
<H2><FONT color="#20B2AA">The <A NAME=8>Name Argument</FONT></H2>
<blockquote>
Several system functions take names as arguments.  A name argument is one of the following:<P>
<UL>
<LI>a symbol holding a valid A+ name, e.g., <font face=Kapl>`var</font> or <font face=Kapl>`ctx.var</font>;<p>
<LI>a pair of symbols holding a valid A+ context name and a valid name, e.g.,<font face=Kapl> `ctx&nbsp;`var</font>.
</UL>
These names always refer to global objects.  See "<A HREF="APlusRefV2_5.html#49">Symbols and Symbol Constants</A>".<P>
<A NAME=10>The definition of a system function refers to this section if it has an argument that conforms to this definition.
</blockquote>
<A NAME=HEADING272A>
<H2><FONT color="#20B2AA"><A NAME=13A>Abort Loading of Script<font face=Kapl>  _abortload{}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE><P>
This system function allows the user to terminate the<font face=Kapl> $load</font>ing of a
 file. Executed in a script, it will terminate that script after the current line is
 processed.  If one script loads a second, and the second script calls<font face=Kapl>
_abortload{}</font>, the second script ends immediately, but the first script is not
 aborted, and continues to be loaded. While the loading of a script is suspended - by an
 interrupt, error, Stop, or Signal, for example -, entering<font face=Kapl> _abortload{}
 </font>in the (Emacs or XTerm) session log for execution will terminate its loading,
 without affecting the suspension.<P>
</BLOCKQUOTE><A NAME=HEADING273>
<H2><FONT color="#20B2AA">All <A NAME=14>Attributes<font face=Kapl>  _atts{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The arguments <font face=Kapl>x</font> and <font face=Kapl>y</font> are described in "<A HREF="#8">The Name Argument</A>".  The result is a vector of symbols.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Lists all attributes set by <font face=Kapl>_set</font> on <font face=Kapl>y</font> with prefix <font face=Kapl>x</font>.  E.g., <font face=Kapl>_atts{`a;`appl}</font> lists all attributes of the form <font face=Kapl>`appl.*</font> set on <font face=Kapl>a</font>.  If <font face=Kapl>x</font> is Null, lists all attributes set by <font face=Kapl>_set</font> on <font face=Kapl>y</font>.  The attributes are listed in random order.  If the variable <font face=Kapl>y</font> does not exist, the result is empty.  For a list of attributes set by s (which does not currently use <font face=Kapl>_set</font>), i.e., display attributes, use the <A HREF="APlusRefV2_23.html#264">settings</A> attribute.<P>
</BLOCKQUOTE><A NAME=HEADING274>
<H2><FONT color="#20B2AA">All Dependent <A NAME=17>Object Names<font face=Kapl>  _alldep{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is a vector of symbols.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is the transitive closure of <font face=Kapl>_dep{x}</font> (Dependent Object Names): it returns the dependency set of <font face=Kapl>x</font>, to wit, a list containing <font face=Kapl>_dep{x}</font>, <font face=Kapl>_dep¡_dep{x}</font>, etc., with duplicates removed.<P>
 <A NAME=18>Note that if <font face=Kapl>f</font> is a dependency and <font face=Kapl>`f</font> is contained in the vector <font face=Kapl>_alldep{`f}</font>, then the dependency set <font face=Kapl>_alldep{`f}</font> is cyclic.  See "<A HREF="APlusRefV2_17.html#48">Cyclic Dependencies</A>".<P>
</BLOCKQUOTE><A NAME=HEADING275>
<H2><FONT color="#20B2AA">Association List to <A NAME=22>Slotfiller<font face=Kapl>  _alsf{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is an association list or a slotfiller.  The result is a slotfiller (but see
 below).<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function converts an association list to the equivalent slotfiller.
 It also accepts slotfillers and returns them unchanged, so that it can be used to obtain a
 slotfiller from an array that might be either an association list or a slotfiller; no
 checking is necessary.
<P>
An argument that is an association list whose length is odd is accepted in two cases.
 If the last element is a symbol, a Null is appended before conversion.
 If the last element is a Null, it is dropped.<P>
In one case the result is not actually a slotfiller: if there are duplicates among the
 symbols that are to be the elements of the first item of the result, the argument is
 nevertheless accepted and the duplicates are retained.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre><font face=Kapl>     _alsf(`a;1;`b;2;`c;3 4 5)
&lt; `a `b `c
&lt; &lt; 1
  &lt; 2
  &lt; 3 4 5</font></pre>
</BLOCKQUOTE><A NAME=HEADING276>
<H2><FONT color="#20B2AA">Change <A NAME=25>Directory<font face=Kapl>  _cd{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a symbol or character vector.  The result is a nested vector with either one or two elements.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A NAME=26><font face=Kapl>_cd{x}</font> provides the same function as the <A HREF="APlusRefV2_15.html#16"><font face=Kapl>$cd</font></A> command.  The argument <font face=Kapl>x</font> specifies the new current directory in Unix format.  If the change to the new current directory is successful, the result is <font face=Kapl>1Ò&lt;`ok</font>; otherwise it is a two-element array of the form<font face=Kapl> (`error;"error message")</font>,&nbsp; for example if there is no such directory.  The PWD environment variable is set.<P>
After a file is loaded, the current directory is the same as it was when the Load function or command was initiated: it is automatically restored if it was changed during execution of the lines of the file.<P>
</BLOCKQUOTE><A NAME=HEADING277>
<H2><FONT color="#20B2AA">Comma Fix <A NAME=31>Input<font face=Kapl>  _cfi{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a simple character array of rank less than or equal to two,
 and <font face=Kapl>x</font> is a scalar restricted whole number.  The result is a
 two-element nested array of the form <font face=Kapl>(bool;data)</font>, where
 <font face=Kapl>#bool</font> equals <font face=Kapl>#data</font> if
 <font face=Kapl>y</font> is a matrix and equals 1 otherwise, and
 <font face=Kapl>bool</font> is an integer array of rank <font face=Kapl>0Ó¢1+ÒÒy</font>,
 and <font face=Kapl>data</font> is a numeric array of rank <font face=Kapl>1ÓÒÒy</font>
 with <font face=Kapl>¢1ÙÒdata</font> equal to <font face=Kapl>xÓ0</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
See "<A HREF="#60">Fix Input</A>" (<font face=Kapl>_fi</font>). The definition of
 <font face=Kapl>_cfi</font> is the same as Fix Input, except that
 <font face=Kapl>_cfi</font> permits additional representations (and misrepresentations)
 of numbers. Specifically, commas and  parentheses are permitted in number representations,
 as well as minus signs, low and the A+ high (<font face=Kapl>¢</font>). In producing the
 numeric values, commas are ignored no matter where they appear, and high and low minus
 signs and each set of enclosing parentheses is replaced by a high minus sign.
 In other words, commas are not treated as "thousands" separators (although they can be
 playing that role), and all parentheses and <font face=Kapl>-</font> and
 <font face=Kapl>¢</font> are treated as signifiers of negative quantities.
 For each result number, there can be at most one indication that it is negative:
 <font face=Kapl>'-¢16'</font>, <font face=Kapl>'(-16)'</font>, and the like
 are not accepted. The parentheses that indicate a number is negative must surround the
 entire number, those that indicate an exponent (in e-notation) is negative just the
 exponent itself. A left parenthesis may be followed by blanks.&nbsp; Note: blanks
 between numbers are not required, although their absence is obviously inadvisable;&nbsp;
 in other words, <i>missing blanks are not used as an indication of possible error any
 more than missing or extraneous commas are</i>.&nbsp;
 <font face=Kapl>'1e-3.5-7.6.5' </font>is translated as<font face=Kapl>
 1e-3&nbsp;0.5&nbsp;¢7.6&nbsp;0.5</font>.<p>

<A HREF="#HEADING315">Scalar Comma Fix Input,</A><font face=Kapl> _scfi</font>, is
 expected to be used in <font face=Kapl>`in</font> functions, validating user
 input.<font face=Kapl> _cfi</font>, on the other hand, is designed for larger arrays,
 such as text files; the assumption is that the data argument is likely to have been
 machine generated.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
<UL>
<LI>Nonce error if <font face=Kapl>x</font> is greater than 1000.
<LI>Rank error if the rank of <font face=Kapl>y</font> exceeds two.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre><font face=Kapl>     _cfi{'(1,200)';1}
&lt;  1
&lt;  ¢1200.</font></pre>
</BLOCKQUOTE><A NAME=HEADING278>
<H2><FONT color="#20B2AA">Debug <A NAME=35><font face=Kapl>  _dbg{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
This function takes essentially the same arguments as <font face=Kapl>$dbg</font> and returns essentially the results displayed by it.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Provides the functionality of <A HREF="APlusRefV2_15.html#31"><font face=Kapl>$dbg</font></A> with different syntax: e.g., <font face=Kapl>_dbg{`cxt;(`only;`)}</font> to trace only the root context. Additionally:<p>
<a name=35A>(1) <font face=Kapl>_dbg{`display;`beam}</font> returns a slotfiller with information about all files currently beamed in. The six fields of the slot filler contain entries for
 each file:<br>
<font face=Kapl> `mode</font> - 0, 1, or 2: the file is copy-on-write, read/write, or local write.<br>
<font face=Kapl> `arg</font> - the righthand argument given to <font face=Kapl>à</font>.<br>
<font face=Kapl> `fname</font> - the actual file name <font face=Kapl>`arg</font> was turned into.<br>
<font face=Kapl> `addr</font> - the memory address where the file was mapped.<br>
<font face=Kapl> `refcnt</font> - reference count: how many A-objects point to the file.<br>
<font face=Kapl> `bytes</font> - the size of the file in bytes.<p>
(2) <font face=Kapl>_dbg</font> allows for callbacks at the points where a tracing or tracking message
 would be displayed.  Executing <font face=Kapl>_dbg{`cb;(fn;cd)}</font> sets up the callback function
 with its client data (static).  This function must take five arguments:
 <font face=Kapl>fn{cd;event;arg1;arg2;arg3}</font>.  The events are <font face=Kapl>`func</font>, <font face=Kapl>`xfs</font>,
 <font face=Kapl>`sfs</font>, <font face=Kapl>`load</font>, <font face=Kapl>`beam</font>, and so on; <font face=Kapl>arg1</font> is the name of the
 function, file, or whatever involved; the possible values of <font face=Kapl>arg2</font> are
 <font face=Kapl>`enter</font>, <font face=Kapl>`exit</font>, <font face=Kapl>`abort</font>, <font face=Kapl>`in</font>, <font face=Kapl>`out</font>,
 <font face=Kapl>`unmap</font>, <font face=Kapl>`dep</font>, <font face=Kapl>`func</font>, and how many <font face=Kapl>Inf</font>s and how many
 NaNs; and <font face=Kapl>arg3</font> is usually null, but for beaming in it is the left argument of
 <font face=Kapl>à</font>.<p>
<a name=35B>(3)</a> In the event callback for <font face=Kapl>`inv</font> events, the second argument is
 null for normal invalidation, and equals <font face=Kapl>`cycle</font> if the
 <font face=Kapl>`inv</font> event is the detection of a cyclic dependency.
</BLOCKQUOTE><A NAME=HEADING279>
<H2><FONT color="#20B2AA">Dependency <A NAME=39>Definition<font face=Kapl>  _def{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is a character vector.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result holds the definition of the dependency named in <font face=Kapl>x</font>.  See "<A HREF="APlusRefV2_57.html#164">Dependencies</A>".  If <font face=Kapl>x</font> does not name a dependency, the result is Null.<P>
</BLOCKQUOTE><A NAME=HEADING280>
<H2><FONT color="#20B2AA">Dependent Object <A NAME=42>Names<font face=Kapl>  _dep{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is a vector of symbols.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result contains the names of all dependencies whose definitions explicitly reference the object named in <font face=Kapl>x</font>.  See "<A HREF="APlusRefV2_57.html#164">Dependencies</A>".<P>
</BLOCKQUOTE><A NAME=HEADING281>
<H2><FONT color="#20B2AA">Dynamic <A NAME=45>Load<font face=Kapl>  _dyld{x;y}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a character vector and the argument <font face=Kapl>y</font> is a nested vector.  The result is a scalar integer.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A NAME=46>The effect of this system function is to load C functions into A+ so that they can be used like ordinary user functions. (But the fixed number of arguments for a C function being <font face=Kapl>_dyld</font>ed cannot exceed 8.) The details can be found in "<A HREF="APlusRefV2_60.html#0">Calling C Subroutines from A+</A>". System error messages are also displayed.  If this function is not available, the <A HREF="APlusRefV2_13.html#29">Dynamic Environment</A> system variable, <font face=Kapl>`dyme</font>, has the value -1. It is safe to <font face=Kapl>_dyld</font> an object already
 <font face=Kapl>_dyld</font>ed.<P>
<b>Warning!</b>&nbsp; A cover function that takes care of the requirements of different
 architectures should be used rather than a direct invocation of
 <font face=Kapl>_dyld</font>, except when "hacking".<P>
<b>Warning!</b> If the A+ name used in <font face=Kapl>_dyld</font> (in its right argument) begins with an
 underscore, then the function will be installed in the root context, no matter what the
 current context, and it will be listed by <font face=Kapl>$sfs</font> but not by <font face=Kapl>$xfs</font>.<P>
</BLOCKQUOTE><A NAME=HEADING281A>
<H2><FONT color="#20B2AA">Execution <A NAME=45A>Profile<font face=Kapl>
  _profile{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
A meaningful argument is a scalar symbol, one of<font face=Kapl> `on `off `report
 `reset</font>. If the argument does not cause an error - i.e., if it is a one-element
 array - then the explicit result is the scalar integer 0.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This facility is enabled by executing<font face=Kapl>
 _profile&nbsp;`on </font>and disabled by<font face=Kapl> _profile&nbsp;`off</font>.&nbsp;
 When not enabled, it adds absolutely no overhead to primitive function calls.<P>
When it is enabled, executing<font face=Kapl> _profile&nbsp;`report </font>causes a report
 to be displayed that gives the number of primitive function executions by function, data
 type, and array size range (number of elements) since the last
 time<font face=Kapl> _profile&nbsp;`on </font>or<font face=Kapl> _profile&nbsp;`reset
 </font>was executed.
</BLOCKQUOTE><A NAME=HEADING282>
<H2><FONT color="#20B2AA">Exit <A NAME=49><font face=Kapl>  _exit{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a scalar integer.  There is no result.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The expression <font face=Kapl>_exit{x}</font> provides a similar function to the system command <font face=Kapl>$off</font>.  The argument <font face=Kapl>x</font> is the value returned when the A+ process terminates.  Proper values for <font face=Kapl>x</font> are 0 through 255, although any integer is accepted; by convention, the value 0 means success.  Since execution of this system function causes the A+ process to exit, it has no meaningful result. See
 "<A HREF="APlusRefV2_51.html#0">Invoking A+</A>".<P>
</BLOCKQUOTE><A NAME=HEADING283>
<H2><FONT color="#20B2AA">Expunge <A NAME=52><font face=Kapl>  _ex{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is an integer scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>_ex</font> provides the same function as <A HREF="APlusRefV2_15.html#70"><font face=Kapl>$ex</font></A>. The object named in <font face=Kapl>x</font> is removed and its associated memory is freed.  The result is 0 if the removal is successful, and 1 otherwise.  In particular, the result is 1 if the object does not exist.  It is also 1 if <font face=Kapl>x</font> is an object bound to a display class (see "<A HREF="APlusRefV2_22.html#18">is</A>" and "<A HREF="APlusRefV2_22.html#6">free</A>"); i.e., a bound object cannot be expunged.<P>
</BLOCKQUOTE><A NAME=HEADING284>
<H2><FONT color="#20B2AA">Expunge <A NAME=55>Context<font face=Kapl>  _excxt{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is described in "<A HREF="#8">The Name Argument</A>".
 The result is an integer scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The context named in <font face=Kapl>x</font> must be empty.  If it is, <font face=Kapl>_excxt{x}</font> removes it from
 the active workspace and returns 0.  If the context is not empty, <font face=Kapl>_excxt</font> returns
 1.  The Name List system function with arguments <font face=Kapl>x</font> and <font face=Kapl>`globs</font> can be used
 to list all objects that would prevent the expunging of a context.
 See the "<a href="#133">Name List</A>" (<font face=Kapl>_nl{y;x}</font>) function.
 See also
 "<A HREF="APlusRefV2_15.html#73">Expunge Context</A>"
 (<font face=Kapl>$excxt</font>).<p>
The root context cannot be expunged; an attempt to expunge it yields a
 result of 1. For a nonexistent context, the result is 1.<P>
</BLOCKQUOTE><A NAME=HEADING285>
<H2><FONT color="#20B2AA">Fix <A NAME=60>Input<font face=Kapl>  _fi{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a simple character array of rank less than or equal to two,
 and <font face=Kapl>x</font> is a scalar restricted whole number.  The result is a
 two-element nested array of the form <font face=Kapl>(bool;data)</font>, where
 <font face=Kapl>#bool</font> equals <font face=Kapl>#data</font> if
 <font face=Kapl>y</font> is a matrix and equals 1 otherwise, and
 <font face=Kapl>bool</font> is an integer array of rank <font face=Kapl>0Ó¢1+ÒÒy</font>,
 and <font face=Kapl>data</font> is a numeric array of rank <font face=Kapl>1ÓÒÒy</font>
 with <font face=Kapl>¢1ÙÒdata</font> equal to <font face=Kapl>xÓ0</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function creates a numeric array with <font face=Kapl>xÓ0</font> elements derived
 from each row of <font face=Kapl>y</font> (or from <font face=Kapl>y</font> itself, if
 it is a scalar or vector).  If a valid vector is created for the row
 <font face=Kapl>i#y</font>, it becomes <font face=Kapl>i#data</font>, and
 <font face=Kapl>i#bool</font> is assigned 1.  If <font face=Kapl>i#y</font> does not
 contain the representations of exactly <font face=Kapl>xÓ0</font> numbers, then
 <font face=Kapl>i#bool</font> is assigned 0, and <font face=Kapl>i#data</font> is created
 by using the first <font face=Kapl>xÓ0</font> valid nonblank sequences in
 <font face=Kapl>i#y</font>, and using zeros as fillers if there are not enough valid
 nonblank sequences.  (The term nonblank suggests how you should use the function, with
 blanks as separators, but see the note with which this definition ends.)  If there is a
 nonblank sequence in <font face=Kapl>i#y</font> that does not represent a number, then
 <font face=Kapl>i#data</font> contains zeros from the point of invalidity on.<P>
Each row of the argument <font face=Kapl>y</font> for which a valid numeric vector can be
 created must consist of <font face=Kapl>x</font> common representations of numbers.  A
 common representation is one of the three general forms produced by the
 <A HREF="APlusRefV2_8.html#78">Default Format</A> monadic primitive function
 <font face=Kapl>î</font>, namely integer, fixed-point, and exponential, except that low
 and high minuses are accepted indifferently: a low minus is accepted at the beginning of
 any number and in exponential form a high minus is accepted in the exponent.
 The expression
<pre><font face=Kapl>     bool/É#y</font></pre>
yields the row indices of <font face=Kapl>y</font> for which a valid numeric vector was
 created.  Note: blanks between numbers are not
 required.<font face=Kapl> 1e-3.5&nbsp;7.6.5-2 </font>is translated as<font face=Kapl>
 1e-3&nbsp;0.5&nbsp;7.6&nbsp;0.5&nbsp;¢2</font>.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
<UL>
<LI>Nonce error if <font face=Kapl>x</font> is greater than 1000.
<LI>Rank error if the rank of <font face=Kapl>y</font> exceeds two.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre><font face=Kapl>     Õaû3 5Ò'1.34 2 3  2x50 '
1.34
2 3
2x50
     a _fi 1
&lt; 1 0 0
&lt;  1.34
   2
   2
     a _fi 2
&lt; 0 1 0
&lt;  1.34 0
   2    3
   2    0</font></pre>
</BLOCKQUOTE><A NAME=HEADING286>
<H2><FONT color="#20B2AA">Flatten <A NAME=63><font face=Kapl>  _flat{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is any array whose simple components are of one type, except that symbols and functions may be mixed and nulls are essentially ignored.  The result is a simple vector whose length is the total number of elements in all the simple components of <font face=Kapl>x</font> and whose type is that of the first nonempty simple component of <font face=Kapl>x</font>, if <font face=Kapl>x</font> is not empty.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The simple components of <font face=Kapl>x</font> are all those simple objects obtainable by repeated selection and disclosure.  If they are all empty, the result is an empty vector whose type is that of the nonnull ones; if they are all null, the result is the Null.  If <font face=Kapl>x</font> is simple, the result is the ravel of <font face=Kapl>x</font>.  Otherwise, the result is the catenation of the ravels of all the simple components of <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
<UL>
<LI>A domain error is reported if two simple components of <font face=Kapl>x</font> (including empty arrays whose types are not null) are of different types, except that symbol and function may both be present.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre><font face=Kapl>    _flat (É3 5;23 34 42;0;É0;;&lt;&lt;(&lt;¢1 ¢2),&lt;1 2Ò7 8)
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 23 34 42 0 ¢1 ¢2 7 8
    _flat `a,&lt;2 2Ò`b`c`d`e
 `a `b `c `d `e
    (`a,&lt;{+})½_flat(`a;+)
1</font></pre>
</BLOCKQUOTE><A NAME=HEADING287>
<H2><FONT color="#20B2AA">Format <A NAME=66><font face=Kapl>  _fmt{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a character vector or scalar, and <font face=Kapl>x</font> is a simple character or numeric array or a nested array.  The result is a simple character array of rank less than or equal to 2.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The function <font face=Kapl>_fmt</font> transforms character and numeric data in <font face=Kapl>x</font> into a character table according to specification <font face=Kapl>y</font>, which consist of a series of format phrases - see the "<A HREF="#69">Format Phrases</A>" table - separated by commas.  For example, the string <font face=Kapl>'i6,f8.2,f6.1'</font> contains three phrases.  Each phrase governs the appearance of a column in the result.  The number of phrases need not match the number of items in <font face=Kapl>x</font>, the phrases being repeated cyclically as needed; furthermore, tab and constant specifications are in separate phrases.<P>
Each phrase has a type, indicated by a letter, such as the letters <font face=Kapl>i</font> and <font face=Kapl>f</font> in the above example.  A tab or constant field in <font face=Kapl>y</font> does not correspond to anything in <font face=Kapl>x</font>.  A tab field merely contributes to the positioning of the next part of the output, and a constant field is reproduced in the output exactly as shown.<P>
Within each format phrase, to the left of the letter that identifies its type, <i>qualifiers</i> or <i>decorators</i> may be inserted.  A qualifier provides additional rules, such as "insert commas between triplets of digits" or "leave this field blank for zero".  See the "<A HREF="#71">Qualifiers</A>" table.  A decorator is a code letter immediately followed by a piece of text enclosed in angle brackets or whatnot; the text is to be attached to the representation of a number, usually to indicate its sign.  See the "<A HREF="#73">Decorators</A>" table.<P>
When <A NAME=67>rounding is required, IEEE rules are used: see "<A HREF="APlusRefV2_8.html#130">Format</A>".  When a number cannot be formatted in the specified manner, its field is filled with asterisks.  A field whose format is valid but for a different type from the data is filled with question marks.  In particular, symbols in <font face=Kapl>x</font> do not cause an error message, but the field in which a symbol is to be formatted is filled with question marks.<P>
Normally, <font face=Kapl>x</font> is a matrix, and the application of the formatting phrases is straightforward.  It can be of other ranks and of any depth, however.  In that case, the columns to be formatted are obtained, conceptually, by the following process.  When a nested array is encountered, it is ravelled, and its elements are successively disclosed and treated in the manner being described.  When a simple array is encountered, it is transformed into a matrix if it is not already one: a scalar becomes a 1 by 1 matrix, an n-element vector becomes an n by 1 matrix, and any other array <font face=Kapl>a</font> is reshaped as<font face=Kapl> ((«/¢1ÕÒa),¢1ÙÒa)Òa</font>.&nbsp; This produces a series of matrices, and thus a series of columns, to which the formatting phrases are applied as stated above.  Each formatted column can be viewed as a character matrix; the result has the same number of rows as the one with the most rows.  Conceptually, blank rows are appended as necessary to each of these matrices to make them the same length as the result, and they are catenated side by side (<font face=Kapl>,@0</font>) to form the result.
<P>
In the "<A HREF="#69">Format Phrases</A>" table, <i>j</i> is an optional repetition factor; <i>q</i> represents an optional qualifier and decorators; <i>w</i> is field width; <i>d</i> denotes significant digits or decimal digits; <i>p</i> is displacement; <font face=Kapl>a</font>, <font face=Kapl>e</font>, <font face=Kapl>f</font>, <font face=Kapl>i</font>, <font face=Kapl>t</font>, and <font face=Kapl>x</font> are literals giving phrase types.
<P>
<A NAME=HEADING288>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Format <A NAME=69>Phrases</B></FONT></caption>
<tr>
<th>Phrase</th><th>Application</th><th>Description</th></tr>
<tr>
<td><i>j</i><font face=Kapl>a</font><i>w</i></td>
<td>Character</td>
<td>Display each character in a field <i>w</i> positions wide.  A <i>w</i> greater
 than 1 produces blanks between adjacent characters.</td></tr>
<tr>
<td><i>jq</i><font face=Kapl>e</font><i>w</i><font face=Kapl>.</font><i>d</i></td>
<td>Exponential</td>
<td>Display each number in a field <i>w</i> positions wide, with <i>d</i> significant
 digits. Align <i>E</i>'s and decimal points in fields that are not left
 justified.</td></tr>
<tr>
<td><i>jq</i><font face=Kapl>f</font><i>w</i><font face=Kapl>.</font><i>d</i></td>
<td>Fixed point</td>
<td>Display in a field <i>w</i> positions wide, with <i>d</i> decimal digits, including
 trailing zeros. Leading zeros are shown as blanks unless the <font face=Kapl>z</font> qualifier is
 used.</td></tr>
<tr>
<td><i>jq</i><font face=Kapl>i</font><i>w</i></td><td>Integer</td>
<td>Display in a field <i>w</i> positions wide. Leading zeros are shown as blanks unless
 the <font face=Kapl>z</font> qualifier is used.</td></tr>
<tr>
<td><i>jq</i><font face=Kapl>g&lt;</font><i>txt</i><font face=Kapl>&gt;</font></td>
<td>Picture Format, rounding arguments to integers</td>
<td>In <i>txt</i>, <font face=Kapl>9</font> and <font face=Kapl>z</font> are "special characters"; the rest are
 "ordinary." Round each number to an integer, after scaling if <font face=Kapl>k</font> is present.
 If <font face=Kapl>s</font> is present, modify <i>txt</i> as required. Then format each number with as many
 digits as there are special characters in <i>txt</i>, so each digit corresponds to a
 special character. Display a digit corresponding to a <font face=Kapl>9</font> unconditionally. If
 a digit corresponding to a <font face=Kapl>z</font> is in a sequence of leading or trailing zeros,
 display a blank; otherwise, display the digit. Display ordinary characters as is, with
 one exception, intended to exclude superfluous thousands separators but include decimal
 points:  any ordinary character surrounded by special characters is displayed as blank
 if in the display a blank is next to it, unless it is the last ordinary character
 and is followed by at most two characters. The only valid decorators and qualifiers are
 <font face=Kapl>m</font> and <font face=Kapl>p</font> (but only the first character of the text of each), <font face=Kapl>s</font>,
 and <font face=Kapl>k</font>.</td></tr>
<tr>
<td><i>j</i><font face=Kapl>t</font><i>p</i></td><td>Absolute tab</td>
<td>Start the next field at position <i>p</i>+1. If <i>p</i> is too small, the next field
 may overwrite earlier ones.</td></tr>
<tr>
<td><i>j</i><font face=Kapl>x</font><i>p</i></td><td>Relative tab</td>
<td>Start the next field at a position displaced <i>p</i> positions from the end of the
 preceding field.  If <i>p</i> is negative, the next field may overwrite earlier
 ones.</td></tr>
<tr>
<td><font face=Kapl>&lt;</font><i>text</i><font face=Kapl>&gt;</font></td><td>Constant: for all</td>
<td>Insert <i>text</i> in every row of the result.</td></tr>
</table><P>
<A NAME=HEADING289>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
<A NAME=71>Qualifiers</B></FONT></caption>
<tr>
<th>Qualifier</th><th>Summary</th><th>Description</th></tr>
<tr>
<td><font face=Kapl>b</font></td><td>blanks</td>
<td>Make the entire field blank when the value is zero.</td></tr>
<tr>
<td><font face=Kapl>c</font></td><td>commas</td>
<td>Insert commas between successive triplets of digits in integer and (before the
 decimal point) fixed-point fields.</td></tr>
<tr>
<td><font face=Kapl>k</font><i>e</i></td><td>scale</td>
<td>Scale the result by displaying a value that is 10<sup><i>e</i></sup> times
 the value.</td></tr>
<tr>
<td><font face=Kapl>l</font></td><td>justify</td>
<td>Left justify. The default is right justification.</td></tr>
<tr>
<td><font face=Kapl>z</font></td><td>zeros</td>
<td>Display leading zeroes in integer and fixed-point fields.</td></tr>
</table><P>
In the <A name=73>"Decorators</A>" table, <i>text</i> may also be delimited by <font face=Kapl>¤¦</font>, <font face=Kapl>ÚØ</font>, <font face=Kapl>¡¡</font>, <font face=Kapl>//</font>, <font face=Kapl>ÌÌ</font>, <font face=Kapl>ìì</font>.<P>
<A NAME=HEADING290>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Decorators</B></FONT></caption>
<tr>
<th>Decorator</th><th>Summary</th><th>Description</th></tr>
<tr>
<td><font face=Kapl>m&lt;</font><i>text</i><font face=Kapl>&gt;</font></td><td>Negative-Left</td>
<td>Insert <i>text</i> to the left of a negative value, not APL high minus. <i>text</i>
 can be empty. <font face=Kapl>m</font> and <font face=Kapl>n</font> can be used together.</td></tr>
<tr>
<td><font face=Kapl>n&lt;</font><i>text</i><font face=Kapl>&gt;</font></td><td>Negative-Right</td>
<td>Insert <i>text</i> to the right of a negative value rather than use APL high minus.
 <i>text</i> can be empty. <font face=Kapl>m</font> and <font face=Kapl>n</font> can be used together.</td></tr>
<tr>
<td><font face=Kapl>o&lt;</font><i>text</i><font face=Kapl>&gt;</font></td><td>Zero replacement</td>
<td>When the data as formatted is zero, replace the result by <i>text</i>. Valid for the
 <font face=Kapl>e</font>, <font face=Kapl>f</font>, and <font face=Kapl>i</font> phrase types.</td></tr>
<tr>
<td><font face=Kapl>p&lt;</font><i>text</i><font face=Kapl>&gt;</font></td><td>Positive-Left</td>
<td>Insert <i>text</i> to the left of a positive value. <font face=Kapl>p</font> and <font face=Kapl>q</font> can be
 used together.</td></tr>
<tr>
<td><font face=Kapl>q&lt;</font><i>text</i><font face=Kapl>&gt;</font></td><td>Positive-Right</td>
<td>Insert <i>text</i> to the right of a positive value. <font face=Kapl>p</font> and <font face=Kapl>q</font> can be
 used together.</td></tr>
<tr>
<td><font face=Kapl>r&lt;</font><i>text</i><font face=Kapl>&gt;</font></td><td>Background</td>
<td>Fill the field cyclically with <i>text</i> where normally blanks would appear,
 including blanks from a <font face=Kapl>b</font> qualifier. For <font face=Kapl>e</font>, <font face=Kapl>f</font>, and <font face=Kapl>i</font>
 phrase types.</td></tr>
<tr>
<td><font face=Kapl>s&lt;</font><i>text</i><font face=Kapl>&gt;</font></td><td>Symbol Substitution</td>
<td>For each pair of characters in <i>text</i>, the second indicates a character to replace
 the first. In <font face=Kapl>e</font>, <font face=Kapl>f</font>, and <font face=Kapl>i</font> phrase types, punctuation, sign, and
 error characters in the result can be replaced; in a <font face=Kapl>g</font> phrase type, any
 characters in the picture text and error characters in the result can be replaced; no
 other replacements can be made. For example,<font face=Kapl> s&lt;,..,&gt; </font>in an <font face=Kapl>f</font>
 phrase type produces periods where commas usually appear and commas where periods usually
 appear.</td></tr>
</table><P>
</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Examples</b>
<BLOCKQUOTE>
<pre></font><font face=Kapl>     'e9.4' _fmt 200 .987
 2.000E 2               ã </font>Internal blank used to align decimal points and <font face=Kapl>E</font>'s.<font face=Kapl>
 9.870E¢1


     nû123456789 0 ¢123456789 123456
     'bcm&lt;-&gt;k-2f13.2' _fmt n
 1,234,567.89

-1,234,567.89
     1,234.56


     'm&lt;(&gt; n&lt;)&gt; q&lt; &gt; b c k-2 f16.2' _fmt n
   1,234,567.89                ã </font>Blanks are okay in the left argument.<font face=Kapl>

  (1,234,567.89)
       1,234.56


     'i 6' _fmt `wrong `type
??????
??????


     'g&lt;99:99:99&gt;' _fmt 100Â3Ù3Õsys.ts{}
07:19:30


     'g&lt;zz9&gt;' _fmt .49 .51 99.47
  0
  1
 99


     rfndû 1.23 10.00 12345.67 332 1234.56
     'k2 g&lt;Your refund is: $z,zz9.99&gt;' _fmt rfnd
Your refund is: $    1.23 ã k2</font> applied to 1.23 is 123, and the<font face=Kapl>
Your refund is: $   10.00 ã </font>decimal point in<font face=Kapl> 1.23 </font>is from <font face=Kapl>g</font>.<font face=Kapl>
************************* ã 12,345.67</font> is too long; if we had <font face=Kapl>s&lt;*?&gt;
Your refund is: $  332.00 ã </font>in the left arg, <font face=Kapl>*...*</font> would be <font face=Kapl>?...?</font>.<font face=Kapl>
Your refund is: $1,234.56 ã The</font> comma is needed here, and it appears.<font face=Kapl>


     'k2 g&lt;Your refund is: $z,zz9.zz&gt;' _fmt 1.23 10.00
Your refund is: $    1.23
Your refund is: $   10.   ã </font>The decimal point is the last ordinary<font face=Kapl>
                          ã </font>character and it has only two characters<font face=Kapl>
                          ã </font>after it,so it's shown even when the<font face=Kapl>
                          ã </font>trailing zeros are dropped.<font face=Kapl>

     's&lt;9#z$&gt;g&lt;$$$# units of product z9&gt;' _fmt 73
  73 units of product z9  ã s</font> allows <font face=Kapl>9</font> and <font face=Kapl>z</font> to be included literally<font face=Kapl>
                          ã </font>in the output.</pre>
</BLOCKQUOTE>
<A NAME=HEADING291>
<H2><FONT color="#20B2AA">General <A NAME=80>Search
 and Replace<font face=Kapl>  _gsr{y;x;r;n}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b>
<BLOCKQUOTE>
<font face=Kapl>y</font>, <font face=Kapl>x</font>, <font face=Kapl>r</font>, and <font face=Kapl>n</font> are all simple character arrays, normally
 vectors, except that <font face=Kapl>r</font> and <font face=Kapl>n</font> can also be null.  The result is either a
 simple character array or an integer vector or matrix.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font>, <font face=Kapl>r</font>, or <font face=Kapl>n</font> is not a vector, its ravel is used.  There are eight cases, as determined by <font face=Kapl>n</font> and <font face=Kapl>r</font>:
<UL>
<LI>If <font face=Kapl>r</font> is Null, then:
<UL>
<LI>If <font face=Kapl>n</font> is Null, then the function is the same as <A HREF="#195">String Search</A> (<font face=Kapl>_ss</font>).
<LI>If <font face=Kapl>n</font> is not Null, then the function is the same as <A HREF="#139">Name Search</A> (<font face=Kapl>_ns</font>), except that <font face=Kapl>n</font> affects the definition of "namelike" as follows:
<UL>
<LI>if <font face=Kapl>n</font> is the empty character vector (<font face=Kapl>''</font>), then the definition is exactly the same as for <font face=Kapl>_ns</font>;
<LI>if <font face=Kapl>n</font> is nonempty and <font face=Kapl>0#n</font> is not <font face=Kapl>'þ'</font>, then <font face=Kapl>n</font> replaces <font face=Kapl>'._'</font>, and <font face=Kapl>'`¢'</font> are not considered;
<LI>if <font face=Kapl>n</font> is  <font face=Kapl>'þ',c</font>, then <font face=Kapl>c</font> replaces the alphabetic characters, digits, and <font face=Kapl>'._'</font>, and <font face=Kapl>'`¢'</font> are not considered.
</UL></UL><p>
<LI>if <font face=Kapl>r</font> is not Null (but possibly <font face=Kapl>''</font>), then:
<UL>
<LI>If <font face=Kapl>n</font> is Null, then the function is the same as <A HREF="#200">String Search and Replace</A> (<font face=Kapl>_ssr</font>).
<LI>If <font face=Kapl>n</font> is not Null, then the function is the same as <A HREF="#144">Name Search and Replace</A> (<font face=Kapl>_nsr</font>), except that <font face=Kapl>n</font> affects the definition of "namelike" as follows:
<UL>
<LI>if <font face=Kapl>n</font> is the empty character vector (<font face=Kapl>''</font>), then the definition is exactly the same as for <font face=Kapl>_nsr</font>;
<LI>if <font face=Kapl>n</font> is nonempty and <font face=Kapl>0#n</font> is not <font face=Kapl>'þ'</font>, then <font face=Kapl>n</font> replaces <font face=Kapl>'._'</font>, and <font face=Kapl>'`¢'</font> are not considered;
<LI>if <font face=Kapl>n</font> is  <font face=Kapl>'þ',c</font>, then <font face=Kapl>c</font> replaces the alphabetic characters, digits, and <font face=Kapl>'._'</font>, and <font face=Kapl>'`¢'</font> are not considered.
</UL></UL></UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
Name delimiters are okay within target and replacement:
<pre><font face=Kapl>     _gsr{'ÌIOû1';'ÌIO';'ÈIO';'ÌÈü'}
ÈIOû1

     _gsr{'ÌÌIOû1,ÌIOû2,BÌIOû3';'ÌIO';'ÈIO';'ÌÈü'}
ÌÌIOû1,ÈIOû2,BÌIOû3

     _gsr{'ÌÌIOû1,ÌIOû2,BÌIOû3';'ÌIO';'ÈIO';'þÌÈü'}
ÌÌIOû1,ÈIOû2,BÈIOû3


     _gsr{'Mississippi is';'is';'IS';''}
Mississippi IS

     _gsr{'Mississippi is';'is';'IS';}
MISsISsippi IS</font></pre>
</BLOCKQUOTE><A NAME=HEADING292>
<H2><FONT color="#20B2AA">Get <A NAME=84>Attribute<font face=Kapl>  _get{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The arguments <font face=Kapl>x</font> and <font face=Kapl>y</font> are described in "<A HREF="#8">The Name Argument</A>".  The result is an array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>_set{y;(x;z)}</font> (<A HREF="#171">Set Attribute</A>) has been executed previously, then the result of this function is <font face=Kapl>z</font>, the value for attribute <font face=Kapl>x</font> on variable <font face=Kapl>y</font>.  Otherwise, the result is Null, including the case when <font face=Kapl>y</font> does not exist.<P>
</BLOCKQUOTE><A NAME=HEADING293>
<H2><FONT color="#20B2AA">Get <A NAME=87>Callback<font face=Kapl>  _gcb{y}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is a two-element nested array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>_scb{y;x}</font> (<A HREF="#175">Set Callback</A>) has been executed previously, then the value of <font face=Kapl>_gcb{y}</font> is the value of <font face=Kapl>x</font> in the last such setting: function scalar, static data.  Although the name displayed for the callback function may now have a new reference,<font face=Kapl> î0Ø_gcb{y} </font>gives the definition of the callback function.  Otherwise the value is Null.<P>
</BLOCKQUOTE><A NAME=HEADING294>
<H2><FONT color="#20B2AA">Get <A NAME=90>Client Data<font face=Kapl>  _gcd{y}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is an array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is like <font face=Kapl>_get</font> (<A HREF="#84">Get Attribute</A>), but for an implicit, unnamed attribute.  It gets the value that was set by the last execution of <font face=Kapl>_scd{y}</font> (<A HREF="#183">Set Client Data</A>);  if none was set, it returns the Null.  It has been superseded by Get Attribute and is retained only for compatibility.<P>
</BLOCKQUOTE><A NAME=HEADING295>
<H2><FONT color="#20B2AA">Get <A NAME=93>Format Symbols<font face=Kapl>  _gfmtsym{}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Result</b><BLOCKQUOTE>
The result is a vector of symbols.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function lists the symbols acceptable as values for the <A HREF="APlusRefV2_23.html#177">out</A> attribute.  See the "<A HREF="APlusRefV2_23.html#365">out Attribute Format Samples</A>" table.<P>
</BLOCKQUOTE><A NAME=HEADING296>
<H2><FONT color="#20B2AA">Get Preset <A NAME=96>Callback<font face=Kapl>  _gpcb{y}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is a two-element nested array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>_spcb{y;x}</font> (<A HREF="#188">Set Preset Callback</A>) has been executed previously, then the value of <font face=Kapl>_gpcb{y}</font> is the value of <font face=Kapl>x</font> in the last such setting: function scalar, static data.  Although the name displayed for the preset callback function may now have a new reference, you can obtain the definition of the preset callback function by entering<font face=Kapl> î0Ø_gpcb{y}</font>.<P>
Otherwise the value is Null.<P>
</BLOCKQUOTE><A NAME=HEADING297>
<H2><FONT color="#20B2AA">Get <A NAME=99>System Variable<font face=Kapl>  _gsv{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a symbol scalar or a quoted string naming a system variable whose value the user is allowed to access.  The result is the value of that system variable.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The value is the current value of the system variable named in <font face=Kapl>x</font>.  A domain error is reported if <font face=Kapl>x</font> does not name a system variable or access to the system variable named in <font face=Kapl>x</font> is forbidden, as it is for <font face=Kapl>`rl</font>.  See "<A HREF="APlusRefV2_13.html#0">System Variables</A>" for descriptions of the system variables and their values and interdictions.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
<UL>
<LI>A domain error is reported if <font face=Kapl>x</font> does not name a system variable whose value is accessible.
</UL>
</BLOCKQUOTE><A NAME=HEADING298>
<H2><FONT color="#20B2AA">Hash Table <A NAME=102>Statistics<font face=Kapl>  _hashstat{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is Null or a symbol naming a context.  The result is an integer vector.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result gives the number of entries in each bucket of a hash table.  If the argument is Null, the statistics are for the symbol table and the result length is 1024.  If the argument names a context, the statistics are for the hash table for that context and the result length is 512.  The function <font face=Kapl>+/</font> applied to the result indicates the number of names that have ever been defined, while <font face=Kapl>Ó/</font> gives a rough indication of collisions and hence possibly reduced execution speed (although for this purpose the whole vector should be examined for clumping).</BLOCKQUOTE>
<H2><FONT color="#20B2AA"><A NAME=106>Index of <font face=Kapl>_index_of{</font><i>y</i><font face=Kapl>;</font><i>x</i><font face=Kapl>}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<i>y</i> and <i>x</i> must be nested vectors of the same length.
 For each of them, its elements must all be nested vectors of the same length, or all be
 enclosed scalars. For <i>y</i>, a scalar is treated as a one-element vector.
 The result is a simple integer vector or scalar whose shape is the same as an element of
 <i>x</i>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Call <i>y</i>'s contained vectors<font face=Kapl> y1...yn</font> and <i>x</i>'s contained vectors <font face=Kapl>x1...xn</font>.  The result <font face=Kapl>r</font> is an integer vector of length <font face=Kapl>Òx1</font>;  <font face=Kapl>r[i] </font>is the least <font face=Kapl>j</font> for which <font face=Kapl>xk[i]</font> is equal to <font face=Kapl>yk[j]</font> for all <font face=Kapl>k</font>;  if there is no such <font face=Kapl>j</font>, then <font face=Kapl>r[i]</font> is <font face=Kapl>Òy1</font>.  This function is a high performance version of the expression
 <font face=Kapl>(ô&gt;</font><i>y</i><font face=Kapl>É¡</font><i>y</i><font face=Kapl>)Éô&gt;</font><i>y</i><font face=Kapl>É¡</font><i>x</i>.<P>
Regarding the arguments as matrices whose columns are the contained vectors, so that the matrices have the same number of columns, <font face=Kapl>_index_of</font> yields a vector that gives, for each row of the right argument, the index of the first row of the left argument that it matches; for any row of the right argument that does not have a matching row in the left argument, the corresponding element of the result is the number of rows in the left argument, i.e., the common length of its contained vectors.<P>
</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b>
<BLOCKQUOTE>
Consider a tiny table with three fields: styles, colors, and prices. The style and color
 fields can be used as key fields with <font face=Kapl>_index_of</font> to find row indices of the table,
 and these can be used with Pick to give prices:
</BLOCKQUOTE>
<pre><font face=Kapl>   Inventoryû(("Oxford";"Oxford";"Loafer";"Loafer");
*             ("Brown"; "Tan";   "Black"; "Brown" );
*             (128.98;  175.98;  112.50;  112.50))
   (Inventory[0 1]_index_of(&lt;"Oxford";&lt;"Tan"))Ø2ØInventory
 175.98
</font></pre>
<b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
<UL>
<LI>A length error is reported if the arguments are not the same length.
<LI>A domain error is reported if the contained vectors of an argument are not
 of the same length.
</UL>
</BLOCKQUOTE><A NAME=HEADING299>
<H2><FONT color="#20B2AA">Is a <A NAME=105>Slotfiller<font face=Kapl>  _issf{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array.  The result is a scalar boolean integer.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> is a slotfiller, the result is 1.  Otherwise the result is 0, e.g., if there are repetitions among the items of <font face=Kapl>0Øx</font>.<P>
</BLOCKQUOTE><A NAME=HEADING300>
<H2><FONT color="#20B2AA">Items of a <A NAME=108>Mapped File<font face=Kapl>  _items{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is a one-element numeric array whose element is a restricted whole number, while the argument <font face=Kapl>x</font> is a symbol or character scalar or character vector.  The result is a scalar integer.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A NAME=109>The argument <font face=Kapl>x</font> holds the name of a mapped file (see "<A HREF="APlusRefV2_19.html#4">Mapped Files</A>").  A mapped file can be processed within A+ as if it were an ordinary array.  In particular, it makes sense to speak of the items of a mapped file.  If <font face=Kapl>y</font> is -1, the result is the number of currently allocated items.  If <font face=Kapl>y</font> is nonnegative and less than the current number of items, then the effect is to truncate the file.  Otherwise, if <font face=Kapl>y</font> is nonnegative the effect of this function is to allocate space (if necessary) on the end of the file so that the file can hold <font face=Kapl>y</font> items.  See "<A HREF="#208">Work Area</A>" (<font face=Kapl>_wa</font>) regarding units of storage allocation.  The result is the current number of items before the new allocation.  See "<A HREF="APlusRefV2_19.html#41">Examples</A>", and note that the "Operation would block" message and the delay caused by trying to avoid that message can occur for <font face=Kapl>_items</font>.
<P>
When a file is written out as a mapped file, the file is made only large enough to hold
 the actual data.
<P>
After a file length is changed by <font face=Kapl>_items</font>, any variables that were associated with it
 (by Map or Map In) must be remapped (by a new application of Map or Map In), because<font face=Kapl>
 _items </font>has rewritten the file.<P>
</BLOCKQUOTE><A NAME=HEADING302>
<H2><FONT color="#20B2AA">Load <A NAME=115><font face=Kapl> _load{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a symbol scalar or a character vector.  The result is a two-element nested array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A NAME=116>The expression<font face=Kapl> _load{x} </font>provides the same function
 as<font face=Kapl> $load&nbsp;x </font>(<A HREF="APlusRefV2_15.html#92">Load </A>command).
 The argument <font face=Kapl>x </font> names the A+ script file to be loaded. The result
 is<font face=Kapl> (`ok;</font><i>file</i><font face=Kapl>)
 </font>if the file is found and can be read, where <i>file</i> is a character vector giving
 the fully qualified name of the file that is loaded, i.e., path/filename.  After a file is
 loaded, the current context and the current directory are the same as they were when the
 Load function was invoked: each is automatically restored if it was changed during
 execution of the lines of the file.<P>
If the file is not found the result has the form<font face=Kapl>
 (`error;"</font><i>error&nbsp;message</i><font face=Kapl>")</font>.  Note that a result<font face=Kapl>
 (`ok;</font><i>file</i><font face=Kapl>)&nbsp;</font> does not
 mean that the file was loaded without error, just that it was found and can be read.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre><font face=Kapl>     _load 's'
&lt; `ok
&lt; /usr/local/lib/s.+</font></pre>
</BLOCKQUOTE><A NAME=HEADING303>
<H2><FONT color="#20B2AA">Load and <A NAME=119>Remove<font face=Kapl>  _loadrm{`delete;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The right argument <font face=Kapl>x</font> is a symbol scalar or a character vector.  The result is a two-element nested array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A NAME=120><font face=Kapl>_loadrm{`delete;x} </font>provides the same function
 as<font face=Kapl> $loadrm&nbsp;x </font>(<A HREF="APlusRefV2_15.html#100">Load and Remove
 </A>command).&nbsp; The argument <font face=Kapl>x</font> holds the name of the file to be
 loaded.  The file is loaded and then deleted (this is a special function for the Emacs
 environment).  The result is the same as that of <font face=Kapl>_load</font>.  The left
 argument must be <font face=Kapl>`delete</font> or <font face=Kapl>'delete'</font> or an
 error message is issued.<P>
</BLOCKQUOTE><A NAME=HEADING304>
<H2><FONT color="#20B2AA">Locals<font face=Kapl> <A NAME=122> _locals{x}</FONT></H2>
</font><b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a symbol, function expression, or function scalar representing a defined or external function; it cannot be a primitive or derived function.  The result is a three-element nested array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The first element of the result is the name of the function, as a symbol.  If
 <font face=Kapl>x</font> represents a defined function, the second element is a vector of
the names of the arguments to the function and the third element lists its local variables.
  If <font face=Kapl>x</font> represents an external function, the second element is an
 integer vector of its argument types (see table in "<A HREF="APlusRefV2_60.html#10">Calling
 C Subroutines from A+</A>"), and the third element is null.<P>
</BLOCKQUOTE><A NAME=HEADING305>
<H2><FONT color="#20B2AA">Name<font face=Kapl> <A NAME=125> _name{x}</FONT></H2>
</font><b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a function scalar.  The result is a scalar symbol.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>x</font> is of the form<font face=Kapl> &lt;{fn}</font>,&nbsp; where <font face=Kapl>fn</font> is a defined, primitive, or system function.  For a defined function, the only case that really makes sense, the result holds the fully qualified name of <font face=Kapl>fn</font>, i.e., the name of the current context, which will be empty for the root context, followed by a dot as separator, followed by <font face=Kapl>fn</font>.  If <font face=Kapl>fn</font> is a system or primitive function, the result is just <font face=Kapl>fn</font> preceded by a backquote.<P>
The expression<font face=Kapl> _name&lt;{&amp;}</font>,&nbsp; either inside the definition of a function <font face=Kapl>fn</font> or entered when a defined function <font face=Kapl>fn</font> is suspended, will produce the fully qualified name of <font face=Kapl>fn</font>.<P>
If in context <font face=Kapl>cx</font> you enter, literally,<font face=Kapl> _name&lt;{f}</font>,&nbsp; you will get either the uninteresting result<font face=Kapl> `cx.f </font>or a value error: the only unqualified name you can use in the argument is one defined in the current context.  A more useful case is when you have an expression that yields a function that may or may not be in the current context, an expression that uses <font face=Kapl>_gcb</font> or <font face=Kapl>of</font> or the like.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
<UL>
<LI>A nonce error report is issued if <font face=Kapl>x</font> is a symbol.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre><font face=Kapl>     $cx sys
     _name &lt;{import}
 `sys.import</font></pre>
</BLOCKQUOTE><A NAME=HEADING306>
<H2><FONT color="#20B2AA">Name <A NAME=128>Class<font face=Kapl>  _nc{y;x}</FONT></H2>
</font><b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
Both arguments and the result are symbol scalars; <font face=Kapl>y</font> can also be Null.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If the symbol <font face=Kapl>x</font> holds an unqualified user name, i.e., a name without an explicit reference to its context, and if the symbol <font face=Kapl>y</font> holds a context name, the result is the symbol form of the name class of the user name <font face=Kapl>x</font>, in the context <font face=Kapl>y</font> (see the "<A HREF="#130">Name Classes</A>" table).  If <font face=Kapl>x</font> holds a fully qualified name of the form<font face=Kapl> cxt.nm</font>,&nbsp; the result refers to <font face=Kapl>nm</font> in the context <font face=Kapl>cxt</font>, and the value of <font face=Kapl>y</font> is ignored.<P>
The root context is denoted by the empty symbol (<font face=Kapl>`</font>).  The current context is denoted by Null: if <font face=Kapl>_nc</font> is referenced in the form <font face=Kapl>_nc{;x}</font>, the current context is assumed.<P>
<A NAME=HEADING307>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Name <A NAME=130>Classes</B></FONT></caption>
<tr>
<th>Name Class</th><th>Description</th></tr>
<tr>
<td><font face=Kapl>`vars</font></td><td>User variables</td></tr>
<tr>
<td><font face=Kapl>`fns</font></td><td>Defined functions</td></tr>
<tr>
<td><font face=Kapl>`xfs</font></td><td>External functions</td></tr>
<tr>
<td><font face=Kapl>`globs</font></td><td>Global objects</td></tr>
<tr>
<td><font face=Kapl>`deps</font></td><td>Dependencies</td></tr>
<tr>
<td><font face=Kapl>`ops</font></td><td>Defined operators</td></tr>
<tr>
<td><font face=Kapl>`null</font></td><td>Not in use, not a valid name, or not one of
 the above</td></tr>
</table><P>
</BLOCKQUOTE><A NAME=HEADING308>
<H2><FONT color="#20B2AA">Name <A NAME=133>List<font face=Kapl>  _nl{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
Both <font face=Kapl>y</font> and <font face=Kapl>x</font> are symbols, except that
 <font face=Kapl>x</font> can be <font face=Kapl>Ï</font> and <font face=Kapl>y</font>
 can be Null. The result is a vector of symbols.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is a vector of symbols holding the names of objects of class <font face=Kapl>x</font> (see the "<A HREF="#130">Name Classes</A>" table) in the context identified by <font face=Kapl>y</font>. The empty symbol (<font face=Kapl>`</font>) denotes the root context, and Null denotes the current context.  Dependencies are listed only when they have saved values, which need not be valid.  See the table "<A HREF="#134">Name List Expressions vs. The Kind of Objects in the Result</A>" for examples of these and other uses of Name List.  For the arguments <font face=Kapl>`apl</font> <font face=Kapl>`ascii</font>, and <font face=Kapl>`uni</font>, the order of the symbols is consistent between them (the symbols in the same positions representing the same primitive) within the same version of A+, but the order may change from version to version, and new functions may cause insertion of symbols; any such changes will not be considered upwardly incompatible.
<A NAME=HEADING309>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Name <A NAME=134>List Expressions vs. The Kind of Objects in the Result</B></FONT></caption>
<tr>
<th>Expression (<font color=red>see Note</font> <A HREF="#135">below</A>)</th>
<th>Kind of Object Named in the Result</th></tr>
<tr>
<td><font face=Kapl>_nl{`ctx;`vars}</font></td><td>Variables in the context <font face=Kapl>`ctx</font></td></tr>
<tr>
<td><font face=Kapl>_nl{`ctx;`fns}</font></td><td>Functions in the context <font face=Kapl>`ctx</font></td></tr>
<tr>
<td><font face=Kapl>_nl{`ctx;`deps}</font></td><td>Dependencies in the context <font face=Kapl>`ctx</font></td></tr>
<tr>
<td><font face=Kapl>_nl{`ctx;`ops}</font></td><td>Operators in the context <font face=Kapl>`ctx</font></td></tr>
<tr>
<td><font face=Kapl>_nl{`ctx;`globs}</font></td>
<td>Global objects in the context <font face=Kapl>`ctx</font></td></tr>
<tr>
<td><font face=Kapl>_nl{`ctx;`xfs}</font></td>
<td>External functions in the context <font face=Kapl>`ctx</font></td></tr>
<tr>
<td><font face=Kapl>_nl{`;`cxs}</font></td><td>Contexts</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`svs}</font></td><td>System variables</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`sfs}</font></td><td>System functions</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`cmds}</font></td><td>System commands</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`apl}</font></td><td>All keywords and primitive symbols in APL mode</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`ascii}</font></td><td>All keywords and primitive symbols in ASCII mode</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`uni}</font></td><td>All keywords and primitive symbols in UNI mode</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`circle} </font>or<br><font face=Kapl>_nl{;Ï}</font></td>
<td>List of symbolic left arguments for Circle function. (Although<font face=Kapl>
 `&nbsp;_nl&nbsp;`circle </font>works fine, the parser is confused by<font face=Kapl>
 `&nbsp;_nl&nbsp;Ï</font>. &nbsp;Left arg can be null, with correct result
 in any current context.)</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`errors}</font></td><td>Names (as symbols) of errors defined in
 A+</td></tr>
<tr>
<td><font face=Kapl>_nl{`;`nl}</font></td><td>Valid right arguments to
 <font face=Kapl>_nl</font></td></tr>
<tr>
<td><font face=Kapl>_nl{`;`wa}</font></td><td>Valid symbol arguments to
 <font face=Kapl>_wa</font></td></tr>
</table><P>
<A NAME=135><b>Note:</b>
<ul>
<li>
Where the left argument is shown as <font face=Kapl>`ctx</font>, it can also be Null
 (absent), indicating the current context.
<li>
Where the left argument is shown as <font face=Kapl>`</font> (the root context), it can also
 be Null (absent), indicating the current context.
</ul>
</BLOCKQUOTE><A NAME=HEADING310>
<H2><FONT color="#20B2AA">Name <A NAME=139>Search<font face=Kapl>  _ns{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
Both <font face=Kapl>y</font> and <font face=Kapl>x</font> are character arrays, normally vectors.  The result is an integer vector or matrix.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> is not a vector, its ravel is used.  If <font face=Kapl>y</font> is a vector, the result is a vector of indices of nonoverlapping <i>namelike </i>occurrences of the vector <font face=Kapl>x</font> in <font face=Kapl>y</font>.  Each index marks the beginning of an occurrence in <font face=Kapl>y</font>.  An empty result signifies that there are no occurrences.  A namelike occurrence is one that satisfies the following restrictions:<P>
<UL>
<LI>not part of a comment;
<LI>not in quotes;
<LI>not immediately preceded by a backquote or a high minus (<font face=Kapl>`¢</font>) or preceded or followed by an alphabetic character (in upper or lower case), a digit, or a dot or an underscore (<font face=Kapl>._</font>).
</UL>
If <font face=Kapl>y</font> is a matrix or higher-rank array, then an occurrence is
 required to be entirely on one line; occurrences spanning rows are not accepted. (An
 unbalanced quotation mark, perhaps intended as an apostrophe, will block name recognition
 in later lines, however.)  The result is an r
 by n matrix, where r is the rank of <font face=Kapl>y</font> and n is the number of
 occurrences found.  A column of the result gives the indices of the corresponding
 occurrence, with the highest-order index at the top and the column index at the bottom.
 Thus <font face=Kapl>0#</font> applied to the result gives a list of the items in which
 occurrences were found.
</BLOCKQUOTE>
<A NAME=140><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre><font face=Kapl>      _ns{'This is ''is''';'is'}
 5
     4 3Ò'abc abc  abc'
abc
 ab
c
abc
     _ns{4 3Ò'abc abc  abc';'abc'}
 0 3
 0 0</font></pre>
</BLOCKQUOTE><A NAME=HEADING311>
<H2><FONT color="#20B2AA">Name <A NAME=144>Search and Replace<font face=Kapl>  _nsr{y;x;r}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font>, <font face=Kapl>x</font>, <font face=Kapl>r</font>, and the result are all character arrays, normally vectors.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definitio</b>n<BLOCKQUOTE>
If <font face=Kapl>x</font> or <font face=Kapl>r</font> is not a vector, its ravel is used.  Occurrences of <font face=Kapl>x</font> are sought in exactly the same way as they are in Name Search, <font face=Kapl>_ns{y;x}</font>, but in two different objects, depending upon <font face=Kapl>y</font>, <font face=Kapl>x</font>, and <font face=Kapl>r</font>:
<UL>
<LI>If <font face=Kapl>y</font> is a vector or the ravels of <font face=Kapl>x</font> and <font face=Kapl>r</font> are the same length, then the result is <font face=Kapl>y</font> with <font face=Kapl>r</font> in place of every occurrence of <font face=Kapl>x</font> found in <font face=Kapl>y</font> itself.<p>
<LI>Otherwise, the result is the ravel of <font face=Kapl>y</font> with <font face=Kapl>r</font> in place of every occurrence of <font face=Kapl>x</font> found in the ravel of <font face=Kapl>y</font>; if no occurrences were found, the result is simply the ravel of <font face=Kapl>y</font>.
</UL>
See also the <A HREF="#201">examples</A> in "<A HREF="#200">String Search and Replace</A>".
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre><font face=Kapl>     _nsr{'This is ''is''';'is';'are'}
This are 'is'</font></pre>
</BLOCKQUOTE><A NAME=HEADING312>
<H2><FONT color="#20B2AA">NaN <A NAME=148>Find<font face=Kapl>  _nanfind{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is any array.  The result is an integer vector.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If the type of <font face=Kapl>x</font> is floating point (so <font face=Kapl>x</font> is simple), then the result is a vector consisting of the indices of those elements of the ravel of <font face=Kapl>x</font> that are NaN's.  Otherwise the result is <font face=Kapl>É0</font>.<P>
NaN's are used in some systems to represent indeterminate numbers.  They are like
 <font face=Kapl>Inf</font>s, but more general.  This function can be used to locate NaN's
 occurring in loaded files or resulting from dynamically loaded code.  The
 <A HREF="APlusRefV2_15.html#34"><font face=Kapl>nan</font></A> subcommand of the
 <font face=Kapl>$dbg</font> command can be used to screen files being beamed in for NaN's.
 (NaN's are not generated by A+ primitive functions.)<P>
</BLOCKQUOTE><A NAME=HEADING313>
<H2><FONT color="#20B2AA">Permissive <A NAME=151>Indexing<font face=Kapl>  _index{i;x;d}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>i</font> is a simple array of restricted whole numbers, <font face=Kapl>x</font> is any array, and <font face=Kapl>d</font> conforms to the items of <font face=Kapl>x</font>, i.e., its general type is the same as theirs, and either it is a scalar or its shape is the same as theirs.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is like <font face=Kapl>i#x</font>, with three exceptions:  (1) Only a simple <font face=Kapl>i</font> is allowed, so only items of <font face=Kapl>x</font> are chosen.  (2) If <font face=Kapl>i</font> is Null, the result is no items of <font face=Kapl>x</font>, not all items of <font face=Kapl>x</font>.  (3) If an element of <font face=Kapl>i</font> is out of range, no index error is reported; instead, <font face=Kapl>d</font> is placed in the corresponding position in the result, replicated if necessary so that it matches the items of <font face=Kapl>x</font>.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre><font face=Kapl>     _index{2 19 14 1;
        ('Mar 06';'Jul 18';'May 15';'Nov 26');&lt;'n.a.'}
&lt; May 15
&lt; n.a.
&lt; n.a.
&lt; Jul 18

     _index{10 11;É11 4;¢1}
 40 41 42 43
 ¢1 ¢1 ¢1 ¢1</font></pre>
</BLOCKQUOTE><A NAME=HEADING314>
<H2><FONT color="#20B2AA">Remove Dependency <A NAME=154>Definition<font face=Kapl>  _undef{name}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>name</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is a boolean integer.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The function removes the dependency definition for <font face=Kapl>name</font>, if any, and
 leaves everything else, such as value and callback function, unchanged. After this function
 is executed, <font face=Kapl>name</font> is an ordinary, not a dependent, variable. It may
 not have a value, since Remove Dependency Definition does not cause an evaluation.  You may
 sometimes want to force an evaluation before invoking this function.  The result is 0 if a
 definition was removed, and 1 otherwise - <font face=Kapl>name</font> does not name a
 dependency.  Cf. "<A HREF="APlusRefV2_15.html#128">Remove Dependency Definition</A>"
 (<font face=Kapl>$undef</font>).<P>
</BLOCKQUOTE><A NAME=HEADING315>
<H2><FONT color="#20B2AA">Scalar <A NAME=159>Comma Fix Input<font face=Kapl>  _scfi{s}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a character array, normally a vector, and the
 result is a numeric scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is like <A HREF="#31">Comma Fix Input</A> (<font face=Kapl>_cfi</font>),
 except that:&nbsp; it handles only a single number (so there must be no internal
 blanks);&nbsp; it has a simple scalar result;&nbsp; it has no boolean part to its result,
 an invalidity being reported as an error instead;&nbsp; and it treats commas properly,
 requiring that they be internal to the integer portion of the number, properly placed
 every three digits leftward from the decimal point (or right end, if there is no decimal
 point), and that there be either no commas or the full set.&nbsp; I.e., if
 <font face=Kapl>s</font> is a valid argument for<font face=Kapl>
 _scfi</font>,<font face=Kapl> _scfi{s} </font>is exactly equivalent to<font face=Kapl>
 ''Ò1Ø_cfi{s;1}</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
<UL>
<LI>A domain error is reported if the first item of <font face=Kapl>_cfi{s;1}</font> would be zero.
</UL>
</BLOCKQUOTE><A NAME=HEADING316>
<H2><FONT color="#20B2AA">Scalar <A NAME=164>Fix Input<font face=Kapl>  _sfi{s}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>s</font> is a character array, normally a vector, and the result is a numeric scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is like <A HREF="#60">Fix Input</A> (<font face=Kapl>_fi</font>), except that
 it handles only a single number, has a scalar result, and has no boolean part to its
 result, an invalidity being reported as an error instead.  I.e., if
 <font face=Kapl>s</font> is a valid argument, <font face=Kapl>_sfi{s}</font> is exactly
 equivalent to <font face=Kapl>''Ò1Ø_fi{s;1}</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
<UL>
<LI>A domain error is reported if the first item of <font face=Kapl>_fi{s;1}</font> would be zero.
</UL>
</BLOCKQUOTE><A NAME=HEADING317>
<H2><FONT color="#20B2AA">Screen <A NAME=167>Format<font face=Kapl>  _sfmt{f;d}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument is a format specification, either one shown in the
 "<A HREF="APlusRefV2_23.html#365">out Attribute Format Samples</A>" table, or one
 acceptable as a left argument for <font face=Kapl>_fmt</font> (<A HREF="#66">Format</A>),
 or <font face=Kapl>î</font> (<A HREF="APlusRefV2_8.html#130">Format</A>).  The right
 argument is a simple numeric scalar. The result is a character vector.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If the left argument is a symbol, then it and the result are as described in the
 "<A HREF="APlusRefV2_23.html#365">out Attribute Format Samples</A>" table. If the left
 argument is character, then it and the result are as described for
 <font face=Kapl>_fmt</font> (<A HREF="#66">Format</A>). Otherwise, the left argument is
 numeric and the result is as described for <font face=Kapl>î</font>
 (<A HREF="APlusRefV2_8.html#130">Format</A>).<P>
Formats containing<font face=Kapl> y2 </font>are
 restricted to the years 1950 through 2049, errors in dates return<font face=Kapl>
 0</font>'s except that an erroneous<font face=Kapl> `y2 </font>is set to
 "<font face=Kapl>**</font>", and the length of the result returned for a bad date is the
 same as for a good date.<P>
<b><font color="#FF0000">Warning! </font></b>If the right argument is numeric but nonscalar,
 only the first element is used.<P>
</BLOCKQUOTE><A NAME=HEADING318>
<H2><FONT color="#20B2AA">Set <A NAME=171>Attribute<font face=Kapl>  _set{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a nested vector<font face=Kapl> (w;z)</font>,&nbsp; where <font face=Kapl>z</font> is any array.  Both <font face=Kapl>w</font> and the argument <font face=Kapl>y</font> are described in "<A HREF="#8">The Name Argument</A>".  The result is a scalar integer.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Sets the value for attribute <font face=Kapl>w</font> on global variable <font face=Kapl>y</font> to the value <font face=Kapl>z</font>.  If <font face=Kapl>z</font> is Null the attribute is removed.  The result is 1 if the value was not previously set or the attribute was removed or <font face=Kapl>y</font> does not exist, and 0 otherwise.  The attribute <font face=Kapl>w</font>, which is commonly a name, can be whatever you want; it simply allows you to associate data with <font face=Kapl>y</font> in an easily retrievable way.<P>
</BLOCKQUOTE><A NAME=HEADING319>
<H2><FONT color="#20B2AA">Set <A NAME=175>Callback<font face=Kapl>  _scb{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is described in "<A HREF="#8">The Name Argument</A>".  The argument <font face=Kapl>x</font> is a two-element nested array.  The result is Null.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A NAME=177>The argument <font face=Kapl>x</font> is a pair of the form<font face=Kapl> (f;s)</font>,&nbsp; where <font face=Kapl>s</font> is any array and <font face=Kapl>f</font> is a function expression.  Thus the first element of <font face=Kapl>x</font> is a function scalar and not the name of a function, so this assignment is unaffected by any later changes to the meaning of the name of the function <font face=Kapl>f</font>.  Executing<font face=Kapl> _scb{y;x} </font>causes the "callback" function <font face=Kapl>f</font> to be called each time the value of the global variable (or, indeed, function) named in <font face=Kapl>y</font> is modified through certain assignments, <i>after</i> the modification has been made.  The array <font face=Kapl>s</font> is known as the static data, and is passed as a parameter to <font face=Kapl>f</font> on every call that results from an assignment to the global variable named in <font face=Kapl>y</font>.<P>
<A NAME=178>If <font face=Kapl>s</font> is omitted the static data is Null.  If <font face=Kapl>f</font> is omitted then any callback previously established for the global variable named in <font face=Kapl>y</font> is removed.<P>
The general form of the syntax of <font face=Kapl>f</font> is<BR><font face=Kapl>f{s;d;i;p;c;v}</font> where
<BLOCKQUOTE>
<font face=Kapl>s</font> is the static data<br>
<font face=Kapl>d</font> is the new value<br>
<font face=Kapl>i</font> is an index, nested if for <font face=Kapl>y</font> and simple if
 for <font face=Kapl>,y</font><br>
<font face=Kapl>p</font> is a path<br>
<font face=Kapl>c</font> is a symbol naming the context in which <font face=Kapl>y</font>
 is defined, and<br>
<font face=Kapl>v</font> is <font face=Kapl>`y</font>
</BLOCKQUOTE>
such that<P>
<font face=Kapl>&nbsp;&nbsp;(i#pØc%v)ûd&nbsp; ã </font>if <font face=Kapl>i</font> is
 nested<br>
<font face=Kapl>&nbsp;&nbsp;(i#,pØc%v)ûd ã </font>if <font face=Kapl>i</font> is simple<br>
<font face=Kapl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>or<br>
<font face=Kapl>&nbsp;&nbsp;(pØc%v)[,]ûd ã </font>if <font face=Kapl>i</font> is out of
 range for <font face=Kapl>c%v</font> before this assignment</P>
describes the change that caused <font face=Kapl>f</font> to be called.<P>
A callback function can have any number of arguments from to zero to six, but the meaning of the arguments is always as above, reading from the left. For example, if it has three arguments then the first is static data, the second is new data, and the third is an index. Any explicit result of a callback function is ignored by A+.<P>
<A NAME=180><b>Dependencies</b> are global variables, and callbacks can be set on them.
 However, such a callback function is called only when the dependent variable is
 explicitly specified using ordinary or selective assignment, and in the latter case only
 as described above. A callback does not occur when a dependency is marked for evaluation,
 or when an evaluation occurs (although a <i>preset</i> callback <i>is</i> called in
 this latter case). Furthermore, during a callback on a dependency, the dependency's value
 is not marked invalid by any change the function makes in a variable on which it depends.
 (Cf. "<A HREF="#188">Set Preset Callback</A>".)<P>
Only one callback can be set on a global variable.  For example, if<font face=Kapl>
 _scb{`a;(fn;)} </font>is executed, and then<font face=Kapl> _scb{`a;(gn;)}</font>,&nbsp;
 the first callback function <font face=Kapl>fn</font> is removed when the second one
 <font face=Kapl>gn</font> is established.  Since it is the callback function itself, and
 not a name, that is given to <font face=Kapl>_scb</font>, if you redefine the function and
 want the new definition to apply to the callback, you must call
 <font face=Kapl>_scb</font> again to set it.<P>
For examples and more detail, see "<A HREF="APlusRefV2_18.html#0">Callback Functions</A>".<P>
</BLOCKQUOTE><A NAME=HEADING320>
<H2><FONT color="#20B2AA">Set <A NAME=183>Client Data<font face=Kapl>  _scd{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is any array.  The argument <font face=Kapl>y</font> is described in "<A HREF="#8">The Name Argument</A>".  The result is an array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function is like <font face=Kapl>_set</font> (<A HREF="#171">Set Attribute</A>),
 except that there is no explicit, named attribute and the result is the previous client
 data, i.e., what the result of <font face=Kapl>_gcd{y}</font>, <A HREF="#90">Get Client
 Data</A>, would be if it were executed immediately before <font face=Kapl>_scd{y}</font>.
 This function has been superseded by Set Attribute and is retained only for
 compatibility.<P>
</BLOCKQUOTE><A NAME=HEADING321>
<H2><FONT color="#20B2AA">Set <A NAME=188>Preset Callback<font face=Kapl>  _spcb{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is described in "<A HREF="#8">The Name Argument</A>".  The argument <font face=Kapl>x</font> is a two-element nested array, as described for Set Callback.  The result is Null.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The differences between callback functions established by <font face=Kapl>_spcb</font> and <font face=Kapl>_scb</font> are:
<UL>
<LI>preset callback functions on dependencies are called when either a dependent variable is assigned a value or a dependency is evaluated (after the evaluation of the dependency definition is completed), whereas callback functions are called only when the dependent variable is assigned a value;<p>
<LI><font face=Kapl>_spcb{y;x}</font> causes the callback function specified in <font face=Kapl>x</font> to be called <i>just before </i>the value of the global variable (or, indeed, function) named in <font face=Kapl>y</font> is changed, but <font face=Kapl>_scb</font> is called <i>just after</i>;<p>
<LI>preset callback functions are used to validate new values for global variables and they therefore return meaningful results (namely, the validated data), whereas callback functions do not;<p>
<LI>for the Append form of Selective Assignment, the indices <font face=Kapl>i</font> are not valid for <font face=Kapl>_spcb</font>, since the appending has not yet been done, but they are valid for <font face=Kapl>_scb</font>.
</UL>
Since preset callbacks are used for validating new values of global variables, the following rules should be followed in their definitions:<P>
<UL>
<LI>if a new value is valid, set the result of the preset callback function to that value;
<LI>if a new value is invalid, signal an error (see
 "<A HREF="APlusRefV2_8.html#293">Signal</A>"); the value of the global variable
 will remain unchanged.
</UL>
For examples and more detail, see "<A HREF="APlusRefV2_18.html#0">Callback Functions</A>".<P>
</BLOCKQUOTE><A NAME=HEADING322>
<H2><FONT color="#20B2AA">Set <A NAME=191>System Variable<font face=Kapl>  _ssv{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is a symbol scalar or a quoted string.  The result is always Null.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
This function sets the value of the system variable named in <font face=Kapl>y</font> to the
 value of the right argument <font face=Kapl>x</font>.  A domain error is reported or a
 correction made (e.g., <font face=Kapl>100Íx</font> for <font face=Kapl>`pp</font>) if the
 right argument is not a valid value of the system variable named in
 <font face=Kapl>y</font> or if that system variable is not allowed to be set. See
 "<A HREF="APlusRefV2_13.html#0">System Variables</A>" for descriptions of the various
 system variables and their values and interdictions.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
<UL>
<LI>A domain error is reported if <font face=Kapl>y</font> does not name a system variable that can be set or <font face=Kapl>x</font> is an impermissible setting for <font face=Kapl>y</font>.  Although<font face=Kapl> $Df&nbsp;2 </font>is a no-op,<font face=Kapl> _ssv{`Df;2} </font>is a domain error.
</UL>
</BLOCKQUOTE><A NAME=HEADING323A>
<H2><FONT color="#20B2AA">Stack Information<font face=Kapl> _doErrorStack{}</font></FONT></H2>
Returns the stack information for the last error that
 occurred under a Protected Execute while<font face=Kapl> `doErrorStack </font>was enabled
 (1).<P>
This facility should enable developers to mail error information without having to exit
 the application.<P>
</BLOCKQUOTE><A NAME=HEADING323>
<H2><FONT color="#20B2AA">String <A NAME=195>Search<font face=Kapl>  _ss{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
Both <font face=Kapl>y</font> and <font face=Kapl>x</font> are character arrays, normally vectors.  The result is an integer vector or matrix.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> is not a vector, its ravel is used.  If <font face=Kapl>y</font> is a vector, the result is a vector of indices of nonoverlapping occurrences of <font face=Kapl>x</font> in <font face=Kapl>y</font>.  Each index marks the beginning of an occurrence.<P>
If <font face=Kapl>y</font> is a matrix or higher-rank array, then an occurrence is required to be entirely on one line; occurrences spanning rows are not accepted.  The result is an r by n matrix, where r is the rank of <font face=Kapl>y</font> and n is the number of occurrences found.  A column of the result gives the indices of the corresponding occurrence, with the highest-order index at the top and the column index at the bottom.  Applying <font face=Kapl>0#</font> to the result gives the indices of the items in which occurrences were found.  See also the <A HREF="#140">examples</A> for Name Search.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples<A NAME=196> </b><BLOCKQUOTE>
<pre></font><font face=Kapl>     _ss{'Mississippi';'is'}
 1 4
     _ss{'Mississippi';'issi'}
 1     ã </font>The instances must be nonoverlapping.</pre>
</BLOCKQUOTE><A NAME=HEADING324>
<H2><FONT color="#20B2AA">String <A NAME=200>Search and Replace<font face=Kapl>  _ssr{y;x;r}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font>, <font face=Kapl>x</font>, <font face=Kapl>r</font> and the result are all character arrays, normally vectors.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> or <font face=Kapl>r</font> is not a vector, its ravel is used.  Occurrences of <font face=Kapl>x</font> are sought in exactly the same way as they are in String Search, <font face=Kapl>_ss{y;x}</font>, but in two different objects, depending upon <font face=Kapl>y</font>, <font face=Kapl>x</font>, and <font face=Kapl>r</font>:
<UL>
<LI>If <font face=Kapl>y</font> is a vector or the ravels of <font face=Kapl>x</font> and <font face=Kapl>r</font> are the same length, then the result is <font face=Kapl>y</font> with <font face=Kapl>r</font> in place of every occurrence of <font face=Kapl>x</font> found in <font face=Kapl>y</font> itself.<p>
<LI>Otherwise, the result is the ravel of <font face=Kapl>y</font> with <font face=Kapl>r</font> in place of every occurrence of <font face=Kapl>x</font> found in the ravel of <font face=Kapl>y</font>; if no occurrences were found, the result is simply the ravel of <font face=Kapl>y</font>.
</UL>
</BLOCKQUOTE><b><A NAME=201>Examples </b><BLOCKQUOTE>
<pre><font face=Kapl>     _ssr{'Mississippi';'is';'IS'}
MISsISsippi
     3 6Ò'abc abc defgh abcd'
abc ab
c defg
h abcd
     _ssr{3 6Ò'abc abc defgh abcd';'abc';'xyz'}
xyz ab
c defg
h xyzd
     _ssr{3 6Ò'abc abc defgh abcd';'abc';'wxyz'}
wxyz wxyz defgh wxyzd</font></pre>
</BLOCKQUOTE><A NAME=HEADING325>
<H2><FONT color="#20B2AA">Valence<font face=Kapl> <A NAME=204> _valence{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is either the name of a defined or external function, as described in "<A HREF="#8">The Name Argument</A>", or a function expression or scalar holding a defined, external, or system function.  The result is an integer scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is the number of arguments taken by the function specified in the argument <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
<UL>
<LI>A nonce error is reported if <font face=Kapl>x</font> is a function scalar that is a primitive function;
<LI>a domain error is reported if <font face=Kapl>x</font> is a symbol naming a system function, but not if <font face=Kapl>x</font> is a function scalar that is a system function.
</UL>
</BLOCKQUOTE><A NAME=HEADING326>
<H2><FONT color="#20B2AA">Work <A NAME=208>Area<font face=Kapl>  _wa{x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a symbol or integer scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The expression<font face=Kapl> _wa&nbsp;n</font>,&nbsp; for <font face=Kapl>n</font> greater than or equal to 1,
 increases the workspace size by approximately <font face=Kapl>n</font> megabytes; see the first
 <A HREF="#HEADING327">table</A> entry regarding IBM machines.  Other values of the argument
 <font face=Kapl>x</font> will produce information about the amount of available storage in
 the workspace,
 as well as the amount and distribution of storage in use, and in one case cause the areas
 of unused storage to be coalesced.  See the "<A HREF="#209"><font face=Kapl>_wa</font>
 Arguments and Results</A>" table.<P>
Memory allocation for A+ objects is based on an increasing set of integers called
 <i>fragment sizes</i>.  The storage area for a particular object will be a <i>fragment</i>
 of sufficiently large fragment size to hold the object, but perhaps with extra, unused
 room.  (It always uses a fragment of smallest possible size.  Fragments can be split off
 larger ones as needed.)  As noted in "<A HREF="#209"><font face=Kapl>_wa</font> Arguments
 and Results</A>", <font face=Kapl>_wa</font> can be employed to find out how many fragments
 of each size are currently in use.<P>
<A NAME=HEADING327>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
<font face=Kapl>_wa</font> <A NAME=209>Arguments and Results</B></FONT></caption>
<tr>
<th>Argument</th><th>Effect and Result</th></tr>
<tr>
<td><font face=Kapl>n</font>,&nbsp; for<font face=Kapl> n¦1</font></td>
<td>The effect is to increase the workspace size,<font face=Kapl> `size</font>,&nbsp; by
 <font face=Kapl>n</font> megabytes (a megabyte is 2<sup>20</sup> bytes).
 The effect of giving a noninteger
 argument is undefined. The result is 0 if successful.<P>
On IBM machines, the workspace size cannot be increased when a mapped file exists for an A+
 process, because A+ requires that the entire workspace be contiguous and AIX requires that
 all space be taken from one end of the address space; thus, the mapped file blocks
 enlargement of the workspace.</td></tr>
<tr>
<td><font face=Kapl>`fragsizes</font></td>
<td>The result is a vector of integers of fragment sizes, in words. This vector is fixed
 for every A+ session, but may vary with the release number and the machine on which you
 are running.</td></tr>
<tr>
<td><font face=Kapl>`fragcounts </font>or<font face=Kapl> 0</font></td>
<td>The result is a vector of integers giving the number of free, or available, storage
 fragments of each fragment size. (Note that these numbers are computed after the argument
 to <font face=Kapl>_wa</font> is allocated.)</td></tr>
<tr>
<td><font face=Kapl>`coalesce </font>or<font face=Kapl> ¢1</font></td>
<td>The effect is to combine contiguous free fragments into larger fragments. The result is
 a vector of the new fragment counts. If there is no writable
 <font face=Courier>/var/atmp</font> (see the <font face=Courier>-m</font> invocation flag,
 <a href="#210B">below</a>) nothing is done and the result is all zeros.</td></tr>
<tr>
<td><font face=Kapl>`size</font></td>
<td>The result is the workspace size, i.e., its current maximum permitted size, in bytes.
 It can be increased by<font face=Kapl>  _wa n</font>,<font face=Kapl> </font>or by a naked left arrow (<font face=Kapl>û</font>,
 indicating resumption) with a pending wsfull error.</td></tr>
<tr>
<td><font face=Kapl>`avail</font></td>
<td>The result is the amount of available storage in the workspace. (Note that the amount
 is computed after the argument to<font face=Kapl> _wa </font>is allocated.)  It is the difference
 between the workspace size,<font face=Kapl> `size</font>,<font face=Kapl> </font>and the space actually being used, and is
 almost equal to the result of the command<font face=Kapl> $wa</font>.<font face=Kapl> </font>Usually, some of<font face=Kapl>
 `avail </font>is in<font face=Kapl> `atmp </font>and some is not.</td></tr>
<tr>
<td><font face=Kapl>`atmp</font></td>
<td>The result is the current total size of the files used to hold the workspace. It
 includes both space that is in use and space that is available. See<font face=Kapl> `avail</font>.<br>
<font face=Kapl>$df&nbsp;/var/atmp </font>tells more about available atmp.</td></tr>
<tr>
<td><font face=Kapl>`info</font></td>
<td>The result is a combination of the above information in the following arrangement:<br>
<font face=Kapl>(`size `atmp `avail; `fragcounts; `fragsizes)</font>.</td></tr>
</table><P>
A+ data objects (including function arrays but not functions) are stored as 56-byte headers and bodies of varying size.  If the number of elements of an object is <font face=Kapl>n</font>, then its body will take, in bytes, depending on its type:<BR>
<font face=Kapl>`char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n+1<BR>
`int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4«nÓ1<BR>
`float&nbsp;&nbsp;&nbsp;&nbsp;8«nÓ1<BR>
`sym&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4«nÓ1<BR>
`box&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4«nÓ1 </font>plus the storage for each of
 its elements<BR>
<font face=Kapl>`func&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4«nÓ1<BR>
`null&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font>usually no space, but sometimes the same
 formula as <font face=Kapl>`box</font>.<P>
<A NAME=210>A+ looks for its atmp space in<font face=Courier> /var/atmp/*</font>. If
 several A+ processes are running on the same machine, they will compete for the same atmp
 space. The atmp space is used as both workspace area and mapped file area, so if large
 mapped files are used it may even be necessary to <i>reduce</i> the workspace size to get
 an application to work.  Usually, it is best to keep the workspace about twice as large as
 the amount of memory you expect to use; 256Meg is the recommended safe limit, beyond which
 you may run out of address space.
<p>
<b>Modifying Memory Mapping Characteristics</b><p>
<A NAME=210B>
The memory mapping characteristics of atmp can be modified
 by means of the
 invocation flag<font face=Courier> -m </font>with the value<font face=Courier>
 ws_atmp_shared</font>,<font face=Courier> ws_atmp_noreserve</font>,<font face=Courier>
 ws_atmp_private</font>,<font face=Courier> ws_atmp_heap</font>,<font face=Courier>
 </font>or<font face=Courier> ws_malloc</font>. The same settings
 can be given to <font face=Courier>APLUS_ATMP_MODEL</font>, an environment variable,
 with the same effect.
<p>
<font face=Courier>ws_atmp_shared</font>,<font face=Courier> ws_atmp_noreserve</font>,
 and<font face=Courier> ws_atmp_private </font>control the flags used for mmap and atmp (see
 the man page for mmap);<font face=Courier> ws_atmp_noreserve </font>is implemented
 as<font face=Courier> MAP_AUTORESRV </font>on sgi.<font face=Courier> ws_atmp_heap
 </font>will put atmp in memory.<font face=Courier> ws_malloc </font>will just
 use<font face=Courier> malloc </font>and<font face=Courier> free </font>as needed.&nbsp;
 If there is no<font face=Courier> /var/atmp </font>then the default will
 be<font face=Courier> ws_malloc</font>.
 When<font face=Courier> /var/atmp </font>does exist, the default
 is<font face=Courier> ws_atmp_shared </font>except on UltraSparc and all Solaris machines, which have a
 default of<font face=Courier> ws_atmp_noreserve</font>.&nbsp; Alternatively and
 temporarily, the memory mapping characteristics of atmp can be modified by setting the
 environment variable <font face=Courier>APLUS_ATMP</font>.&nbsp; This variable is intended
 for use by system administrators to configure new architectures.&nbsp; The possible
 settings for <font face=Courier>APLUS_ATMP</font> are:<font face=Courier>
 MAP_PRIVATE</font>,<font face=Courier> MAP_NORESERVE</font>,<font face=Courier>
 </font>and<font face=Courier> FROM_HEAP</font>.<p>
<A NAME=210A>
<p><b>The Heap</b><p>
There is another area of storage in A+, aside from atmp space, namely, the <i>heap</i>.
 The heap is used for A+ internal memory needs, either temporary or permanent, such as in
 creating contexts or global names, parsing nested arrays, and
 buffering outgoing messages in adap.  Subsequent uses of a symbol or
 name within a process do not use more memory, because expunging a name does not free the
 heap space used for it.<p>
A long-running A+ process can eventually use up its heap, although the heap is pretty large
 and A+'s demands on it are fairly small. A <font face=Courier>brealloc()</font> error can
 then occur. The obvious way of controlling this potential problem is to not use a
 tremendous number of names. The heap size can be changed at A+ invocation by using
 the<A HREF="APlusRefV2_51.html#6"><font face=Courier> -h </font>flag</A>;&nbsp; caution: do
 not use this flag unless it is specifically needed to solve a memory-related problem. The
 size can be measured using<font face=Courier> pmon</font>, remotely, from an XTerm, but not
 from within an A+ process, since<font face=Courier> pmon </font>is interactive,
 so<font face=Kapl> $pmon </font>cannot be used.<p>
Another way to monitor heap space use is to run in an XTerm, while A+ is
 running,<br>
<nobr><font face=Courier>while [ true ]; do pstat -s; sleep 1; done</font></nobr></p>

<p><b>Handling of Symbols</b><p>
Memory allocation and hashing algorithms
 are intended to provide high performance even for applications using
 10,000 or more symbols.
 Symbols are kept in the atmp area rather than in the heap, preventing the bus errors that
 could occur when an application used hundreds of thousands of symbols, exhausting the heap.
 Such an application may need a relatively large
 <font face=Kapl>_wa</font> allocation.<P>
The address space for an A+ process is fixed at two gigabytes. Four things use address space:
<ul>
<li>the actual code of the A+ process, and dynamically loaded routines;
<li>dynamic memory (heap space);
<li>atmp space;
<li>mapped files.
</ul>
<p>
<A NAME=211>See also "<A HREF="APlusRefV2_60.html#11">Memory Allocation - What to Do and
 What Not to Do</A>" and "<A HREF="APlusRefV2_60.html#18">Memory Allocation in A+ - a
 Closer Look</A>" in "<A HREF="APlusRefV2_60.html#0">Calling C Subroutines from A+</A>".<P>
</BLOCKQUOTE>
<HR>
<ADDRESS><table width="100%"><tr><td><font size=2><i><a href="mailto:doc@aplusdev.org">doc@aplusdev.org</a></i></font></td><td align=right><font size=2><i>&#169; Copyright 1995&#150;2008 Morgan Stanley Dean Witter &amp; Co.  All rights reserved.</i></font></td></tr></table></ADDRESS>
</BODY>
</HTML>
