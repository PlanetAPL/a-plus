<HTML>
<HEAD>
<TITLE>A+ Reference: The Syntax and Semantics of A+</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME=HEADING48>
<H1><FONT color="#FF0000">The Syntax and <A NAME=0>Semantics of A+</FONT></H1>

<a name="CONTENTS4">
<UL>
<A HREF="#HEADING49"> Names and Symbols</A><BR>
<UL>
<A HREF="#HEADING50"> Primitive Function Symbols</A><BR>
<A HREF="#HEADING51"> User Names</A><BR>
<A HREF="#HEADING52"> System Names</A><BR>
<A HREF="#HEADING53"> System Command Names</A><BR>
</UL>
<A HREF="#HEADING54"> Comments</A><BR>
<A HREF="#HEADING55"> Infix Notation and Ambi-valence</A><BR>
<A HREF="#HEADING56"> Syntactic Classes</A><BR>
<UL>
<A HREF="#HEADING57"> Numeric Constants</A><BR>
<A HREF="#HEADING58"> Character Constants</A><BR>
<UL>
<A HREF="#41">Table:&nbsp; Double-Quote Translations</A><BR>
</UL>
<A HREF="#HEADING59"> Symbols and Symbol Constants</A><BR>
<A HREF="#HEADING60"> The Null</A><BR>
<A HREF="#HEADING61"> Variables</A><BR>
<A HREF="#HEADING62"> Functions and Function Call Expressions</A><BR>
<A HREF="#HEADING63"> Operators and Derived Functions</A><BR>
<UL>
<A HREF="#HEADING64">Table:&nbsp; Special Character Sequences (Quasi-Operators)</A><BR>
<A HREF="#HEADING65">Table:&nbsp; Operator Call Expressions</A><BR>
</UL>
<A HREF="#HEADING66"> Function Expressions</A><BR>
<A HREF="#HEADING67"> Bracket Indexing</A><BR>
<A HREF="#HEADING68"> Expression Group</A><BR>
<A HREF="#HEADING69"> Expression Result and Expression Group Result</A><BR>
<A HREF="#HEADING70"> Strands</A><BR>
<A HREF="#HEADING71"> Function Scalars</A><BR>
<A HREF="#HEADING72"> Assignment, or Specification</A><BR>
<A HREF="#HEADING73"> Execution Stack References</A><BR>
</UL>
<A HREF="#HEADING74"> Precedence Rules</A><BR>
<UL>
<A HREF="#HEADING75"> Right to Left Order of Execution</A><BR>
<A HREF="#HEADING76"> Scope Rules for Function Expressions</A><BR>
<A HREF="#HEADING77"> Sequences of Expressions</A><BR>
</UL>
<A HREF="#HEADING78"> Control Statements</A><BR>
<UL>
<A HREF="#HEADING79"> Case Statement</A><BR>
<A HREF="#HEADING80"> Do Statement</A><BR>
<A HREF="#HEADING81"> If Statement</A><BR>
<A HREF="#HEADING82"> If-Else Statement</A><BR>
<A HREF="#HEADING83"> While Statement</A><BR>
</UL>
<A HREF="#HEADING84"> Function Definitions</A><BR>
<UL>
<A HREF="#HEADING85">Table:&nbsp; Function Call Expressions and Function Header Formats</A><BR>
<A HREF="#HEADING86"> Function Result</A><BR>
</UL>
<A HREF="#HEADING87"> Operator Definitions</A><BR>
<UL>
<A HREF="#HEADING88"> Operator Result</A><BR>
<A HREF="#HEADING89">Table:&nbsp; Operator Header Formats</A><BR>
</UL>
<A HREF="#HEADING90"> Dependency Definitions</A><BR>
<UL>
<A HREF="#HEADING91"> Dependency Result</A><BR>
</UL>
<A HREF="#HEADING92"> Well-Formed Expressions</A><BR>
</UL>
<HR>
<blockquote>
<A NAME=1>The main purpose of this chapter is to describe the syntax of A+, but through a series of examples, rather than in a formal way.  Consequently some commonly understood terms are used without being formally defined.  In particular, the phrase <i>A+ expression</i>, or simply <i>expression</i>, is taken to have the same general meaning it does in mathematics, namely a well formed sentence that produces a value.  In addition, some discussion of semantics has been included, but only where it seemed reasonable in order to complete a description.  A brief discussion of well formed expressions is presented at the end of this section, after all the rules for the components of expressions have been presented.
</blockquote>
<A NAME=HEADING49>
<H1><FONT color="#20B2AA">Names and Symbols</FONT></H1>
<A NAME=HEADING50>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Primitive <A NAME=3>Function Symbols</FONT></H2>
<blockquote>
A+ <A NAME=5>uses a mathematical symbol set to denote the functions that are native to the
 language, which are called <i>primitive functions</i>.  This symbol set, part of the APL
 character set, consists of common mathematical symbols such as <font face=Kapl>+</font> and <font face=Kapl>«</font>,
 commonly used punctuation symbols, and specialized symbols such as <font face=Kapl>Ù</font> and
 <font face=Kapl>Õ</font>.  In some cases it takes more than one symbol to represent a primitive function,
 as in <font face=Kapl>+/</font>, but the meaning can be deduced from the individual symbols. The symbols
 are listed in the table "<A HREF="APlusRefV2_63.html#3">Primitive Function and Operator
 Names and References</A>".<P>
<A NAME=6>Two of the symbols can be used alone, viz., <font face=Kapl>û</font> and <font face=Kapl>ý</font>.  If the execution of a function or operator has been suspended, they mean resume execution (with increased workspace size if necessary) and abandon execution, respectively; in the absence of a suspension, they are ignored.  Instead of <font face=Kapl>ý</font>, a dollar sign ($) can be used.  Inside a function definition, an expression can consist of the symbol <font face=Kapl>û</font> alone, but it will be ignored, and the parser rejects <font face=Kapl>ý</font> alone as a token error.
</blockquote>
<A NAME=HEADING51>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;User <A NAME=9>Names</FONT></H2>
<blockquote>
<A NAME=10>User names fall into two categories, unqualified and qualified.  An <i>unqualified name</i> is made up of alphanumeric (alphabetic and numeric) characters and underbars (<font face=Kapl>_</font>).  The first character must be alphabetic.  For example, <font face=Kapl>a</font>, <font face=Kapl>a1c</font>, and <font face=Kapl>a_1c</font> are unqualified names, but <font face=Kapl>3xy</font> and <font face=Kapl>_xy</font> are not. (Although underbar is currently permitted as the first character in user names, this manual has been written as if it were not, and you should consider this form reserved for system names and avoid it.) The identifying words in control statements (case, do, else, if, while) are reserved by A+ for that use; they cannot appear as
 user names, even in qualified names.<P> A <A NAME=12><i>qualified
name</i> is either an unqualified user name preceded by a dot
(<font face=Kapl>.</font>), or a pair of unqualified user names separated by a dot.
In either case there are no intervening blanks.  For example,
<font face=Kapl>.xw1</font> and <font face=Kapl>w_2.r2_a</font> are qualified user names. An
unqualified name preceding the dot in a qualified name is the name of
a <i>context</i>. If there is a dot but no preceding name, the
context is the <i>root</i> context.
</blockquote>
<A NAME=HEADING52> <H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;System
<A NAME=14>Names</FONT></H2>
<blockquote>
System <A NAME=15>function names are unqualified
names preceded by an underbar, with no intervening spaces,
<font face=Kapl>_argv</font> for instance.  The use of system function names is
reserved by A+.<P> <A NAME=16>The name of an object traditionally (and
therefore in A+) called a system variable is an unqualified name
preceded by a backquote, with no intervening spaces.  For example,
<font face=Kapl>`rl</font> is the name of the system variable called Random Link.
These objects cannot be dealt with directly in A+, but only through
certain system and primitive functions and system commands, to which
they act as parameters.  As indicated in "<A HREF="#49">Symbols and
Symbol Constants</A>", they look just like symbols (and may be
considered such).  They are not, however, the symbol forms of names:
A+ will not recognize <font face=Kapl>rl</font>, for instance, as having anything to
do with <font face=Kapl>`rl</font>; the quoted form <font face=Kapl>'rl'</font>, however, is
recognized by system functions such as <A
href="APlusRefV2_14.html#HEADING297"><font face=Kapl>_gsv</font></A>.
</blockquote>
<A NAME=HEADING53> <H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;System <A NAME=17>Command Names</FONT></H2>
<blockquote>
System command names begin with a dollar sign, followed immediately by an
unqualified name, which is the name of the command.  The name is
sometimes followed by a space and then by a sequence of characters
whose meaning is specific to the command, usually separated from the name by a space.
</blockquote>
<A NAME=HEADING54>
<H1><FONT color="#20B2AA">Com<A NAME=18>ments</FONT></H1>
<blockquote>
<A NAME=19>Comments can appear either
alone on a line or to the right of an expression.  A comment is
indicated by the <font face=Kapl>ã</font> symbol (usually called "lamp," since it
looks like a bulb filament and since comments illuminate code), and it
and everything to its right on the line constitute the comment.  For
example:
<pre></font><font face=Kapl>     a+b  ã This is the A+ notation for addition.</font></pre>
</blockquote>
<A NAME=HEADING55> <H1><FONT color="#20B2AA">Infix Notation and <A
NAME=23>Ambi-valence</FONT></H1>
<blockquote>
A+ is a mathematical notation, and as such
uses infix notation for primitive functions with two arguments.  In
infix notation, the symbol or user name for a function with two
arguments appears between them.  For example, <font face=Kapl>a+b</font> denotes
addition, <font face=Kapl>a-b</font> subtraction, <font face=Kapl>a«b</font> multiplication, and
<font face=Kapl>aßb</font> division.  <P> In mathematics, the symbol - can also be
used with one argument, as in -b, in which case it denotes negation.
This is true in A+ as well.  Because the symbol denotes two functions,
one with one argument and the other with two, it is called
<i>ambi-valent</i> (e.g., it uses "both valences").  A+ has extended the idea of ambi-valence to most of
its primitive functions.  For example, just as <font face=Kapl>-b</font> denotes the
negative of <font face=Kapl>b</font>, so <font face=Kapl>ßb</font> denotes the reciprocal of
<font face=Kapl>b</font>.  <P> Defined functions cannot be ambi-valent.<P> <A
NAME=27>Functions with one argument are called <i>monadic, </i>and
functions with two arguments are called <i>dyadic</i>. One often speaks of the
 <i>monadic use</i> or <i>dyadic use</i> of an ambi-valent primitive function symbol.
</blockquote>
<A NAME=HEADING56>
<H1><FONT color="#20B2AA">Syntactic <A NAME=29>Classes</FONT></H1>
<A NAME=HEADING57> <H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Numeric
<A NAME=31>Constants</FONT></H2>
<blockquote>
<A NAME=32>Individual numbers can be
expressed in the usual integer, decimal, and exponential formats, with
one exception: negative number constants begin with a "high minus"
sign (<font face=Kapl>¢</font>) - including
 <font face=Kapl>¢Inf</font>, which we will come to
later - instead of the more conventional minus sign (<font face=Kapl>-</font>),
although negative exponents in the exponential format are denoted by
the conventional minus sign.<P> <A NAME=34>Exponential format is of
the form <font face=Kapl>1.23e5</font>, meaning 1.23 times 10 to the power 5,
<font face=Kapl>¢5e2</font>, meaning -500, and <font face=Kapl>1e-2</font>, meaning .01.  Only
numbers can appear around the <font face=Kapl>e</font>.  The one following it must
be an integer - no decimal point - and have a regular minus sign if
negative: a high minus there elicits a parse error report.  A negative
number before the <font face=Kapl>e</font> must have a high minus: a regular minus
is considered to lie outside the format.<P> It is also possible to
express a list of numbers as a constant, simply by separating the
individual numbers by one or more blank spaces.  For example:
<pre><font face=Kapl> 1.23 ¢7 45 3e-5</font></pre>
is a numeric constant with four
numbers: 1.23, negative 7, 45, and .00003. <font face=Kapl>Inf</font> can
appear in such a list.  If you omit the blanks, A+ will give you a
numeric vector, but probably not the one you intended.  If a number is
being parsed and a character is encountered that can't be part of the
number, then a new number is started if the character could begin a
number.  For instance,<BR>
<font face=Kapl> 1e-3.5&nbsp;40.358.62.7 </font>is read by A+ as<font face=Kapl>
 0.001&nbsp;0.5&nbsp;40.358&nbsp;0.62&nbsp;0.7</font> .
</blockquote>
<A NAME=HEADING58>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Character <A NAME=35>Constants</FONT></H2>
<blockquote>
A <A NAME=37>character
constant is expressed as a list of characters surrounded by a pair of
single quote marks or a pair of double quote marks.  For a quote mark of the same kind as the
 surrounding quote marks to be included in a list of characters, it must be doubled.  For
example, both <font face=Kapl>'abc''d'</font> and <font face=Kapl>"abc'd"</font> are constant
expressions for the list of characters <font face=Kapl>abc'd</font>.  There is,
however, a distinction between the two kinds of quotation marks.<P> <A
NAME=39>Within single quotes (<font face=Kapl>'</font>) the C escape sequences and indeed
 any <font face=Kapl>\</font>c are not treated in any way, but left as is.
<P>
In strings contained within double quotes (<font face=Kapl>"</font>) these sequences
and <font face=Kapl>\c</font> are treated as follows:<P>
<UL>
<LI><font face=Kapl>\n</font> is
replaced by a newline character; <LI><font face=Kapl>\</font><i>o</i>, <font face=Kapl>\</font><i>oo</i>, and
<font face=Kapl>\</font><i>ooo</i> (each <i>o</i> a digit) are replaced by a character (see
below); and
<LI><A NAME=40>the other sequences <i>simply have the
leading backslash removed</i>.
</UL>
These sequences and their
translations are (where parenthesis indicates that A+ does not perform
the substitution that the parenthesized term implies):<P>
<A NAME=41><table border=1 cellspacing=0 cellpadding=8>
<caption><b>Double-Quote Translations</b></caption>
<tr>
<th>Name</th><th>String</th><th>Translation</th><th>Comment</th></tr>
<tr>
<td><A NAME=45>newline</td><td><font face=Kapl>\n</font></td><td>newline character</td><td>&nbsp;</td></tr>
<tr>
<td>(horizontal tab)</td><td><font face=Kapl>\t</font></td><td><font face=Kapl>t</font></td><td>for tab use <font face=Kapl>"\11"</font></td></tr>
<tr>
<td>(vertical tab)</td><td><font face=Kapl>\v</font></td><td><font face=Kapl>v</font></td><td>&nbsp;</td></tr>
<tr>
<td>(backspace)</td><td><font face=Kapl>\b</font></td><td><font face=Kapl>b</font></td><td>for backspace use <font face=Kapl>"\10"</font></td></tr>
<tr>
<td>(carriage return)</td><td><font face=Kapl>\r</font></td><td><font face=Kapl>r</font></td><td>for carriage return use <font face=Kapl>"\15"</font></td></tr>
<tr>
<td>(formfeed)</td><td><font face=Kapl>\f</font></td><td><font face=Kapl>f</font></td><td>for formfeed use <font face=Kapl>"\14"</font></td></tr>
<tr>
<td>(audible alert)</td><td><font face=Kapl>\a</font></td><td><font face=Kapl>a</font></td><td>&nbsp;</td></tr>
<tr>
<td>backslash</td><td><font face=Kapl>\\</font></td><td><font face=Kapl>\</font></td><td>&nbsp;</td></tr>
<tr>
<td>question mark</td><td><font face=Kapl>\?</font></td><td><font face=Kapl>?</font></td><td>&nbsp;</td></tr>
<tr>
<td>single quote</td><td><font face=Kapl>\'</font></td><td><font face=Kapl>'</font></td><td>&nbsp;</td></tr>
<tr>
<td>double quote</td><td><font face=Kapl>\"</font></td><td><font face=Kapl>"</font></td><td>&nbsp;</td></tr>
<tr>
<td>octal number</td><td><font face=Kapl>\</font><i>ooo</i></td><td>a character</td><td>see below</td></tr>
<tr>
<td>(hex number)</td><td><font face=Kapl>\x</font><i>hh</i></td><td><font face=Kapl>x</font><i>hh</i></td><td>&nbsp;</td></tr>
<tr>
<td>(any other char)</td><td><font face=Kapl>\</font>c</td><td>c</td><td>&nbsp;</td></tr>
</table><P>
Thus <font face=Kapl>"\?\\"</font> is equal to<font face=Kapl>'?\'</font> and
 <font face=Kapl>"\r\t"</font> is equal to <font face=Kapl>'rt'</font>;&nbsp;
 <font face=Kapl>\"</font> prevents the double quote from ending a string within double
 quotes, and <font face=Kapl>\\</font> allows literal inclusion of <font face=Kapl>\</font>
in a translated string in double quotes.<P> <A NAME=46>The translation
of an octal sequence - which is of <i>variable length</i> and could be
shown as <font face=Kapl>\</font>[[<i>o</i>]<i>o</i>]<i>o</i> - is best understood as
occurring in three steps.  First, the digits to be translated are
found: there is at least one (else this would not be an octal
sequence) and at most three, but the end of the string and any
nondigit character also act as terminators.  Second, the string of
digits is taken as an octal number and is translated to a decimal
number.  Any <font face=Kapl>8</font> and <font face=Kapl>9</font> digits are accepted as 10 octal
and 11 octal, and any overflow is ignored, since only the 256 residue
is used.  Third, the ASCII character corresponding to that number is
found.  If the string being translated is <font face=Kapl>digits</font>, the
translation is<BR>
<font face=Kapl>`char©8Â10&nbsp;10&nbsp;10Îâdigits </font>
where&nbsp;<font face=Kapl>1¤(Òdigits)¤3</font>&nbsp;and&nbsp;<font face=Kapl>©digits</font>&nbsp;is&nbsp;<font face=Kapl>`char</font>.<P>
 The foregoing implies these equivalences:<BR>
<font face=Kapl>"\99"ûý"\121" &nbsp;&nbsp;&nbsp; "\6a"ûý"\006a"ûý"\06",'a' &nbsp;&nbsp;&nbsp;
 "\123456"ûý"\123",'456'</font>.
</blockquote>
<A NAME=HEADING59> <H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Symbols and Symbol <A NAME=49>Constants</FONT></H2>
<blockquote>
A <A NAME=50>symbol is a backquote (<font face=Kapl>`</font>) followed immediately by
a character string made up of alphanumeric characters, underscores
(<font face=Kapl>_</font>), and dots (<font face=Kapl>.</font>).  Symbol constants can be thought
of as character-based counterparts to numeric constants, aggregating
several characters into a single symbol.  Just as<font face=Kapl>
 1&nbsp;2.34&nbsp;12e3&nbsp;3e5 </font>is a list of four numbers,
 so<font face=Kapl> `a.s&nbsp;`12&nbsp;`b`w_3 </font>is a list of
four symbols.  A backquote alone represents the empty symbol.<P>
A user name, like <font face=Kapl>balance</font>, can be put in symbol form by placing
a backquote before it, as in <font face=Kapl>`balance</font>.  A user name in
symbolic form is always taken to refer to a global object (see "<A
HREF="APlusRefV2_16.html#2">Scope of Names</A>"), never a local
object.  If it has no dot in it, it refers to a global object in the
current context.<P> System variable names, like <font face=Kapl>`rl</font>, are in
the form of symbols.  Unlike backquoted user names, they are not decomposable.
If <font face=Kapl>var</font> is a user name, then <font face=Kapl>`var</font> is recognized
by A+ in certain situations as referring to the same object.  A+ sees no relation, however,
between <font face=Kapl>rl</font> and the system variable <font face=Kapl>`rl</font>.
</blockquote>
<A NAME=HEADING60> <H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The <A NAME=51>Null</FONT></H2>
<blockquote>
The Null is a special
constant that can be formed as follows: <font face=Kapl>()</font>.  It is neither
numeric nor character, but has a special type, null.  It is an empty
vector, i.e., its rank is 1 and the length of its only axis is 0.
</blockquote>
<A NAME=HEADING61>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Var<A NAME=52>iables</FONT></H2>
<blockquote>
Variables are data
objects that are named.  They receive their values through Assignment,
or Specification, which is denoted by the left-pointing arrow
(<font face=Kapl>û</font>).  For example, the expression
<pre><font face=Kapl>     abcû1 2 3</font></pre>
assigns the three-element list consisting of 1, 2,
and 3 to the variable named </font><font face=Kapl>abc</font>. Any user name can
serve as a variable name. For more on assignment, see the
 "<A HREF="#111">Assignment, or Specification</A>" section.
</blockquote>
<A NAME=HEADING62>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Functions and <A NAME=54>Function Call Expressions</FONT></H2>
<blockquote>
<A NAME=57>Functions take zero or more arguments and return results.  A
sequence of characters that constitutes a valid reference to a
function will be called a <i>function call expression</i>.  That is, a
function call expression includes a function symbol or name together
with all its arguments and all necessary punctuation.  It may also
include unnecessary parentheses and blanks; if it does not, we will
call it <i>irredundant</i>.  In general, the arguments of a function
are data objects, which may appear in function call expressions as
variable names, constants, or expressions that require evaluation.  In
addition, for the various forms of function call expressions using
braces, arguments can be function expressions (see "<A
HREF="#92">Function Expressions</A>").  For example,
<font face=Kapl>f{9.98;.0775;«}</font> and <font face=Kapl>f{59;125;g}</font>, where <font face=Kapl>g</font> is
a defined function, are valid function call expressions.<P> <A
NAME=59>A function with no arguments, or parameters, - which must be a
defined or system, not a primitive, function - is said to be
<i>niladic</i>.  The only valid irredundant function call expression
for a niladic function <font face=Kapl>f</font> is <font face=Kapl>f{}</font>.<P> <A
NAME=61>Functions with one argument, <i>monadic</i> functions, can be
primitive, defined, or system.  The valid irredundant function call
expressions for a function <font face=Kapl>f</font> with one argument <font face=Kapl>a</font>
are<font face=Kapl> f&nbsp;a </font>and <font face=Kapl>f{a}</font>.  In the form<font face=Kapl> f&nbsp;a</font>,<font face=Kapl>
</font>the blank is required only if <font face=Kapl>f</font> followed by some initial
part of <font face=Kapl>a</font> would form a valid name.<P>
<i><A NAME=67>Dyadic</i> functions can also be primitive, defined, or
system.  The valid irredundant function call expressions for a
function <font face=Kapl>f</font> with two arguments <font face=Kapl>a</font> and <font face=Kapl>b</font>
are<font face=Kapl> a&nbsp;f&nbsp;b </font>and <font face=Kapl>f{a;b}</font>, where <font face=Kapl>a</font> is called the
<i>left argument</i> and <font face=Kapl>b</font> the <i>right argument</i>.  In the
infix form, each blank is required only if its absence could cause a
name to be extended, and if the left argument is itself an infix
expression it must be parenthesized.<P> Functions with more than two
arguments must be defined or system, not primitive, functions.  The
only valid irredundant function call expression for a function of more
than two arguments <font face=Kapl>a</font>, <font face=Kapl>b</font>,
 ... , <font face=Kapl>c</font> is
<font face=Kapl>f{a;b;</font> ... <font face=Kapl>;c}</font>.
<P>
In functional expressions that use braces,
any position adjacent to a semicolon can be left blank.  For example,
each of the following is a valid functional expression:
<font face=Kapl>f{a;}</font>, <font face=Kapl>f{;b}</font>, <font face=Kapl>f{;}</font>, <font face=Kapl>g{;a;b}</font>,
<font face=Kapl>g{;;b}</font>.  However, if <font face=Kapl>f</font> is monadic then <font face=Kapl>f{}</font>
is not valid because <font face=Kapl>f{}</font> is reserved for niladic function
call expressions.  When an argument position is legitimately left
blank, A+ assumes that the argument is the Null.<P> <A NAME=69>The
number of arguments that a function takes is called its
<i>valence</i>.  The valence of a defined function is fixed by the
form of its definition.<P> The table "<A HREF="#152">Function Call
Expressions and Function Header Formats</A>"
 summarizes the function call expressions discussed here.
</blockquote>
<A NAME=HEADING63>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Operators and <A NAME=72>Derived Functions</FONT></H2>
<blockquote>
<A NAME=77>There are three primitive formal operators in A+, known as Apply, Each, and Rank.  By a <i>formal operator</i> we mean an operator in the mathematical sense, i.e., a function that takes a function as an operand, or produces a function as a result, or both.  The resulting function is called a <i>derived function</i>.<P>
The Apply and Each operators are both denoted by the dieresis, <font face=Kapl>¡</font>.  For a given function <font face=Kapl>f</font>, the function derived from the Each operator is denoted by <font face=Kapl>f¡</font>.  The function <font face=Kapl>f</font> can be either monadic or dyadic, and <font face=Kapl>f¡</font> has the same valence as <font face=Kapl>f</font>.  For a given function scalar <font face=Kapl>g</font>, where <font face=Kapl>g</font> is equal to <font face=Kapl>&lt;{f}</font>, the function derived from the Apply operator is denoted by <font face=Kapl>g¡</font>.  The function <font face=Kapl>f</font> can be either monadic or dyadic, and <font face=Kapl>g¡</font> has the same valence as <font face=Kapl>f</font>.<P>
The Rank operator is denoted by the <i>at</i> symbol, <font face=Kapl>@</font>.  Unlike the Each operator, the Rank operator has both a function argument and a data argument.  For a given function <font face=Kapl>f</font> and data value <font face=Kapl>a</font>, the function derived from the Rank operator is denoted by <font face=Kapl>f@a</font>.  This derived function has the same valence as <font face=Kapl>f</font>, which can be either monadic or dyadic.<P>
<A NAME=78>A+ permits defined formal operators.  As with primitive operators, only infix notation is allowed for operator and operands.  Like the Each operator, the operand of a monadic defined operator is to the left of the operator name.  For example, if the operator is <font face=Kapl>monop</font> then <font face=Kapl>+monop</font> denotes the derived function for <font face=Kapl>+</font>.  In the case of a dyadic defined operator, one operand is on the left of the operator name and the other is on the right, like the Rank operator.  For example, if the operator is <font face=Kapl>dyop</font> then <font face=Kapl>+dyop«</font> denotes the derived function for <font face=Kapl>+</font> and <font face=Kapl>«</font>.  A dyadic defined
 operator can have a data right operand: see the note following the table
 "<A HREF="#162">Operator Header Formats</A>".  See also the
 "<A HREF="APlusRefV2_16.html#15">Operator Syntax</A>" section.
<P>
<A NAME=79>Unlike a primitive operator, the valence of a function derived from a defined
 operator is not determined by the valence of the function operands, but, like a defined
 function, by the form of the operator definition.
<P>
<A NAME=81>There are four other symbols (<font face=Kapl>\./®</font>) that can appear with
 certain primitive function symbols and jot (<font face=Kapl>Ê</font>), the resulting
 sequences representing functions.  Their syntax might suggest that these symbols represent
 operators; however, not all primitive function symbols can be used in these sequences, and
 neither can defined function names.  Consequently it would be misleading to think of them
 as formal operators, so we have simply listed all the sequences that are allowed.  It is
 often convenient, however, to speak loosely of these sequences as representing derived
 functions, and of the three symbols in question as representing operators.
<P>
From now on, the general terms <i>operator</i> and <i>derived function</i> will include
 Apply, Each, Rank, defined operators, their derived functions, and the "operators" and
 "derived functions" in the table "<A HREF="#85">Special Character Sequences
 (Quasi-Operators)</A>".<P>
<A NAME=HEADING64>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>Special <A NAME=85>Character Sequences
 (Quasi-Operators)</B></FONT></caption>
<tr>
<th>"Operator" Name</th>
<th>"Derived" Functions</th></tr>
<tr>
<td>Bitwise</td>
<td><font face=Kapl>©®</font> (Cast and Or)<font face=Kapl> ^® ~® &lt;® ¤® =® ¦® &gt;® ¨®</font></td></tr>
<tr>
<td>Inner Product</td>
<td><font face=Kapl>+.«  &nbsp;Ä.+  &nbsp;Ó.+</font></td></tr>
<tr>
<td>Outer Product</td>
<td><font face=Kapl>Ê.+ &nbsp;Ê.- &nbsp;Ê.« &nbsp;Ê.ß &nbsp;Ê.* &nbsp;Ê.Ä &nbsp;Ê.Ó<br>
Ê.| &nbsp;Ê.&lt; &nbsp;Ê.&gt; &nbsp;Ê.¤ &nbsp;Ê.¦ &nbsp;Ê.= &nbsp;Ê.¨</font></td></tr>
<tr>
<td>Reduction</td>
<td><font face=Kapl>+/ &nbsp;«/ &nbsp;^/ &nbsp;©/ &nbsp;Ä/ &nbsp;Ó/</font></td></tr>
<tr>
<td>Scan</td>
<td><font face=Kapl>+\ &nbsp;«\ &nbsp;^\ &nbsp;©\ &nbsp;Ä\ &nbsp;Ó\</font></td></tr>
</table>
<P>
Operator call expressions should be understood in terms of derived functions and function
 call expressions.  Namely, an operator symbol and its function operands, or in the case of
 the Rank operator, its function operand to its left and its data object operand immediately
 to its right, form a derived function.  A derived function is syntactically like any other
 function, and so can be used in the function position of any function call expression, as
 in <font face=Kapl>f@a{c;d}</font> and<font face=Kapl> b&nbsp;f@a&nbsp;c </font>. See the
 table "<A HREF="#89">Operator Call Expressions</A>" for a summary; it shows both
 irredundant expressions and expressions in which the derived functions are parenthesized.
 As in function call expressions, the blanks are not required in some instances and the left argument may need to be in parenthesis; moreover, a constant data operand and a constant
 right argument may require punctuation to separate them.
</blockquote>
<A NAME=HEADING65>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>Operator Call
 <A NAME=89>Expressions</B></FONT></caption>
<tr>
<th>Operator Valence</th>
<th colspan=2>Forms for Derived Function Having Monadic Valence</th>
<th colspan=2>Forms for Derived Function Having Dyadic Valence</th></tr>
<tr>
<td rowspan=2>monadic</td>
<td><font face=Kapl>(f&nbsp;op)a</font></td><td><font face=Kapl>f&nbsp;op&nbsp;a</font></td>
<td><font face=Kapl>a(f&nbsp;op)b</font></td><td><font face=Kapl>a&nbsp;f&nbsp;op&nbsp;b</font></td></tr>
<tr>
<td><font face=Kapl>(f&nbsp;op){a}</font></td><td><font face=Kapl>f&nbsp;op{a}</font></td>
<td><font face=Kapl>(f&nbsp;op){a;b}</font></td><td><font face=Kapl>f&nbsp;op{a;b}</font></td></tr>
<tr>
<td rowspan=2>dyadic</td>
<td><font face=Kapl>(f&nbsp;op&nbsp;g)a</font></td><td><font face=Kapl>f&nbsp;op&nbsp;g&nbsp;a</font></td>
<td><font face=Kapl>a(f&nbsp;op&nbsp;g)b</font></td><td><font face=Kapl>a&nbsp;f&nbsp;op&nbsp;g&nbsp;b</font></td></tr>
<tr>
<td><font face=Kapl>(f&nbsp;op&nbsp;g){a}</font></td><td><font face=Kapl>f&nbsp;op&nbsp;g{a}</font></td>
<td><font face=Kapl>(f&nbsp;op&nbsp;g){a;b}</font></td><td><font face=Kapl>f&nbsp;op&nbsp;g{a;b}</font></td></tr>
</table>
<A NAME=HEADING66>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Function <A NAME=92>Expressions</FONT></H2>
<blockquote>
The function arguments of operators are function expressions. The simplest function
 expressions are the names of defined functions and the symbols for primitive functions
 <i>other than Assignment and Bracket Indexing</i>.  Any formulation of a derived function
 is also a function expression (see "<A HREF="#72">Operators and Derived Functions</A>").
<P>
Function expressions are limited to infix notation, since operators are limited to it.
<P>
A function expression can be enclosed in parentheses.  For example, <font face=Kapl>a(f@1)b</font> is
 equivalent to<font face=Kapl> a&nbsp;f@1&nbsp;b</font>.  Moreover, a function expression is a valid
 function argument to a formal operator, and therefore quite complicated function
 expressions can be built.  For example, <font face=Kapl>+/ </font>is a function expression, and therefore so are the following:<font face=Kapl> +/¡</font>, <font face=Kapl>+/¡¡</font>, and <font face=Kapl>+/¡@a</font>.  See the "<A HREF="#131">Scope Rules for Function Expressions</A>" section.
</blockquote>
<A NAME=HEADING67>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Bracket <A NAME=93>Indexing</FONT></H2>
<blockquote>
A+ data objects are arrays, and Bracket Indexing is a way to select subarrays.  Bracket Indexing uses special syntax, whose form is
<pre><font face=Kapl>     x[a;b;</font> ... <font face=Kapl>;c]</font></pre>
where </font><font face=Kapl>x</font> represents a variable name or an expression in parenthesis, <font face=Kapl>a</font>, <font face=Kapl>b</font>, ... <font face=Kapl>,c</font> denote expressions, and the number of semicolons is at most one less than the rank of the array being indexed.  (The form <font face=Kapl>x[]</font> is, however, allowed for scalars.)  The space between the left bracket and the first semicolon, between successive semicolons, and between the last semicolon and the right bracket, can be empty.  If there are no semicolons, the space between the left and right brackets can be empty.  Inserting semicolons immediately to the left of the right bracket does not change the meaning of the entire expression, as long as the maximum allowable number of semicolons is not exceeded.  <A NAME=94>The form <font face=Kapl>[a;b;</font> ... <font face=Kapl>;c]</font> is an <i>index group</i>.  See "<A HREF="#133">Sequences of Expressions</A>" and "<A HREF="APlusRefV2_8.html#38">Bracket Indexing</A>".
</blockquote>
<A NAME=HEADING68>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Expression <A NAME=97>Group</FONT></H2>
<blockquote>
An expression group is a sequence of expressions contained in a pair of braces in which the
 expressions are separated by semicolons, where there is not a function expression
 immediately preceding it (except perhaps for spaces), so it is not a set of arguments for
 a function. Any of the expressions can be null, consisting of zero or more blanks. For
 example:
<pre></font><font face=Kapl>     {a;b;</font> ... <font face=Kapl>;c;}</font>
and
<font face=Kapl>     {a;b;</font> ... <font face=Kapl>;c}</font></pre>
are expression groups, where </font><font face=Kapl>a</font>,
 <font face=Kapl>b</font>, ... ,<font face=Kapl>c</font> denote expressions.
 See "<A HREF="#133">Sequences of Expressions</A>".
</blockquote>
<A NAME=HEADING69>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Expression Result and
 <A NAME=102>Expression Group Result</FONT></H2>
<blockquote>
The result of an expression is the result of the last function executed in the expression, whether primitive, defined, or derived.  See "<A HREF="#169">Well Formed Expressions</A>".
<P>
The result of an expression group is the result of the last expression executed. It is
 possible that the last expression in the group may not be the last one executed - indeed,
 may not be executed at all; see "<A HREF="APlusRefV2_8.html#239">Result</A>".
</blockquote>
<A NAME=HEADING70>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Stran<A NAME=104>ds</FONT></H2>
<blockquote>
Aggregate data objects (nested arrays) can be formed by separating the individual data objects by semicolons and surrounding the result with a pair of parentheses.  For example:
<pre><font face=Kapl>     (a;b;</font> ... <font face=Kapl>;c)</font></pre>
where </font><font face=Kapl>a</font>, <font face=Kapl>b</font>, ... ,
 <font face=Kapl>c</font> denote expressions.  Any of these expressions can be function
 expressions.  There must be at least one semicolon.  See "<A HREF="#133">Sequences of
 Expressions</A>".
</blockquote>
<A NAME=HEADING71>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Function <A NAME=105>Scalars</FONT></H2>
<blockquote>
The above strand notation produces objects with at least two elements.  <A NAME=108>One-element aggregates of data can be formed with the primitive function <A HREF="APlusRefV2_8.html#97">Enclose</A>, denoted by <font face=Kapl>&lt;</font>.  A one-element object holding a function expression, such as
<pre><font face=Kapl>     &lt;{a}</font></pre>
where <font face=Kapl>a</font> is a function expression, is called a function scalar.<P>
<A NAME=109>The symbol <font face=Kapl>¡</font>, used also for the <A HREF="APlusRefV2_10.html#11">Each</A> operator, serves as the <A HREF="APlusRefV2_10.html#7">Apply</A> operator when the operand (argument) of the operator is a function scalar.  For example,
 <font face=Kapl>a(&lt;{Ò})¡b</font> is <font face=Kapl>aÒb</font>.
</blockquote>
<A NAME=HEADING72>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Assignment, or <A NAME=111>Specification</FONT></H2>
<blockquote>
The Assignment primitive, denoted by <font face=Kapl>û</font>, is used to associate a name with a value.  For example:
<pre><font face=Kapl>     aû1
     fû+</font></pre>
assigns the value 1 to the name </font><font face=Kapl>a</font> and the function Add to the
 name <font face=Kapl>f</font>. The name to the left of the assignment arrow is assigned
 the value of the expression to the right. If that expression is a function expression, the
 name to which it is assigned represents a function - not the name of a function, but a
 function itself. Otherwise it represents a variable.
<P>
<A NAME=112>A series of names can be associated with a series of values, using strand notation; for example,
<pre><font face=Kapl>     (a;b;c)û(1 2 3;3 4Ò7;'txt')</font></pre>
Ordinary Assignment can also be expressed as <font face=Kapl>(a)ûb</font>. Any appearance
 of <font face=Kapl>aûb</font>  inside a function or operator definition means that
 <font face=Kapl>a</font> will be a local variable, if <font face=Kapl>a</font> is an
 unqualified name. The form <font face=Kapl>(a)ûb</font> can be used to assign a value to
 the global variable <font face=Kapl>a</font>, provided
 that <font face=Kapl>aû</font>... doesn't appear elsewhere in the definition.
 If both <font face=Kapl>aû</font>... and <font face=Kapl>(a)û</font>... appear,
 they are equivalent: the latter has no
 special significance.
<P>
<A NAME=114>Assignment behaves somewhat like a dyadic function, in that it has a result, namely, the right argument.  The left argument expression is syntactically limited to certain forms.  See the table "<A HREF="APlusRefV2_8.html#267">Targets of Selective Assignment</A>", for a summary of Selective Assignment target expressions, which are additional to those in ordinary assignment.<P>
Assignment, in any form, cannot be the operand of an operator.
</blockquote>
<A NAME=HEADING74>
<H1><FONT color="#20B2AA">Precedence <A NAME=121>Rules</FONT></H1>
<blockquote>
<A NAME=122>Precedence rules describe a hierarchy in the syntactic elements of a language that determines how these elements are grouped for execution in an expression.  For example, in mathematics <font face=Kapl>«</font> has higher precedence than <font face=Kapl>+</font>, which means that <font face=Kapl>«</font> is evaluated before <font face=Kapl>+</font>.  For example, in the mathematical expression a<font face=Kapl>«</font>b<font face=Kapl>+</font>c, the subexpression a<font face=Kapl>«</font>b is grouped for execution, and the result is added to c.<P>
The precedence rules in A+ are simple:<P>
<UL>
<LI>all functions have equal precedence, whether primitive, defined, or derived
<LI>all operators have equal precedence
<LI>operators have higher precedence than functions
<LI>the formation of numeric constants has higher precedence than operators.
</UL>
</blockquote>
<A NAME=HEADING75>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Right to Left <A NAME=128>Order of Execution</FONT></H2>
<blockquote>
The way to read A+ expressions is from left to right, like English.  For the most part we also read mathematical notation from left to right, although not strictly, because the notation is two-dimensional.  To illustrate reading A+ expressions from left to right, consider the following examples.<br>
<font face=Kapl>b+c+d&nbsp;&nbsp;&nbsp;ã&nbsp;</font>Read as: "<font face=Kapl>b</font> plus the result of <font face=Kapl>c</font> plus <font face=Kapl>d</font>."<br>
<font face=Kapl>x-ßy &nbsp;&nbsp;&nbsp;ã&nbsp;</font>Read as: "<font face=Kapl>x</font> minus the reciprocal of <font face=Kapl>y</font>."<p>
As you can see, reading from left to right in the suggested style implies that execution takes place right to left.  In the first example, to say "<font face=Kapl>b</font> plus the result of <font face=Kapl>c</font> plus <font face=Kapl>d</font>" means that <font face=Kapl>c+d</font> must be formed first, and then added to <font face=Kapl>b</font>. And in the second example, to say "<font face=Kapl>x</font> minus the reciprocal of <font face=Kapl>y</font>" means that <font face=Kapl>ßy</font> must be formed before it is subtracted from <font face=Kapl>x</font>.<P>
To be sure, reading from left to right is not necessarily associated with execution from right to left.  For example, the expression <font face=Kapl>bßc+d</font> is read left to right in conventional mathematical notation as well as A+, but the order of evaluation is different in the two; in mathematics <font face=Kapl>b</font> divided by <font face=Kapl>c</font> is formed and added to <font face=Kapl>d</font>, and consequently the expression is read as "<font face=Kapl>b</font> divided by <font face=Kapl>c</font>, [pause] plus <font face=Kapl>d</font>," while in A+, <font face=Kapl>b</font> is divided by <font face=Kapl>c+d</font>. The order of execution is controlled by the relative precedence of the functions, or operations.  In mathematics, division has higher precedence than addition, so that in <font face=Kapl>bßc+d</font>, division is performed before addition.<P>
Another way to say that A+ expressions are executed from right to left is that functions have long right scope and short left scope.  For example, consider:
<pre><font face=Kapl>     a+b-cße«f</font></pre>
The arguments of the subtraction function are </font><font face=Kapl>b</font> on the left (short scope) and <font face=Kapl>cße«f</font> on the right (long scope).  The left argument is found by starting at the subtraction symbol and moving to the left until the smallest possible complete subexpression is found.  In this example it is simply the name <font face=Kapl>b</font>.  If the first nonblank character to the left of the symbol had been a right parenthesis, then the left argument would have included everything to the left up to the matching left parenthesis.  For example, the left argument of subtraction in <font face=Kapl>a+(xßb)-cße«f</font> is <font face=Kapl>xßb</font>.<P>
The right argument is found by starting at the function symbol and moving to the right, all the way to the end of the expression; or until a semicolon is encountered at the same level of parenthesization, bracketing, or braces; or until a right parenthesis, brace, or bracket is encountered whose matching left partner is to the left of the symbol.  In the above example, the right argument of subtraction is everything to its right.  If the case of <font face=Kapl>a+b-(cße)«f</font>, the right argument is also everything to its right.  However, for <font face=Kapl>a+(b-cße)«f</font>, the right argument is <font face=Kapl>cße</font>.
</blockquote>
<A NAME=HEADING76>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Scope Rules for <A NAME=131>Function Expressions</FONT></H2>
<blockquote>
Interestingly enough, the scope rules for function expressions are the mirror image of those for ordinary expressions.  Namely, operators have long scope to the left and short scope to the right.  For example, <font face=Kapl>+/¡@a</font> is equivalent to <font face=Kapl>((+/)¡)@a</font>, and if <font face=Kapl>dyop</font> is a dyadic defined operator, <font face=Kapl>+dyopô¡</font> is equivalent to <font face=Kapl>(+dyopô)¡</font>, not <font face=Kapl>+dyop(ô¡)</font>.
</blockquote>
<A NAME=HEADING77>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Sequences <A NAME=133>of Expressions</FONT></H2>
<blockquote>
Index groups, expression groups, and strands are forms for sequences of expressions separated by semicolons.  The expressions in an expression group are executed in the order suggested for reading, from left to right, like successive statements in a function.  Index groups and strands, however, fall within other expressions and are executed right to left.  For example, if the variable <font face=Kapl>a</font> has the value 2 and the strand
<pre><font face=Kapl>     bû(aû5;a«a)</font></pre>
is executed, the value in the second element of </font><font face=Kapl>b</font> will be 4, proving that the assignment <font face=Kapl>aû5</font> happened after the multiplication <font face=Kapl>a«a</font>.  (A Strand Assignment, however, like an expression group, is executed left to right, after its righthand argument has been evaluated in the usual way.)<P>
To improve readability in source files, sequences of expressions are often broken at the semicolons and continued on the next physical line.  Note that in such cases for expression groups the left to right order of execution for the expressions within a sequence becomes a natural top to bottom order.
</blockquote>
<A NAME=HEADING73>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Execution <A NAME=116>Stack References</FONT></H2>
<blockquote>
Execution stack <A NAME=120>references are<font face=Kapl> &amp;</font>,<font face=Kapl> &amp;0</font>,<font face=Kapl> &amp;1</font>,
 etc. The symbol<font face=Kapl> &amp; </font>can be used in a function definition to refer to that
 function. For example, a factorial function can be defined in either of the following ways:
<pre><font face=Kapl>     fact{n}:if (n&gt;0) n«fact{n-1} else 1

     fact{n}:if (n&gt;0) n«&amp;{n-1} else 1</font></pre>
When execution is suspended, the objects on the execution stack can be referred to
 by<font face=Kapl> &amp;0 </font>(top of the stack),<font face=Kapl> &amp;1</font>, and
 so on.  These objects can be examined
 and respecified, and execution resumed (<font face=Kapl>û</font>). The left to right order of arguments
 generally corresponds to increasing stack numbers.<P>
In the definition of a dependency<font face=Kapl> a</font>, the symbol<font face=Kapl> &amp; </font>refers to that definition
 but<font face=Kapl> a </font>always denotes the (stored) value of<font face=Kapl> a</font>, whereas in the definition of a
 function<font face=Kapl> f</font>, both<font face=Kapl> &amp; </font>and<font face=Kapl> f </font>denote the definition of<font face=Kapl> f</font>.
</blockquote>
<A NAME=HEADING78>
<H1><FONT color="#20B2AA">Control <A NAME=134>Statements</FONT></H1>
<blockquote>
For the interpretation of these control statements, see the
 "<A HREF="APlusRefV2_12.html#0">Control Statements</A>" chapter. The words <font face=Kapl>case</font>,
 <font face=Kapl>do</font>, <font face=Kapl>else</font>, <font face=Kapl>if</font>, and <font face=Kapl>while</font> are reserved by A+; they
 cannot be employed as user names.
</blockquote>
<A NAME=HEADING79>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Case <A NAME=135>Statement</FONT></H2>
<blockquote>
The form of a case statement is the word <font face=Kapl>case</font>, followed by an expression in
 parentheses, followed by an expression group.  When <font face=Kapl>case</font> followed by an
 expression in parenthesis is entered alone on a line (with no pending unbalanced
 punctuation), the statement is taken to be complete, with Null for the expression group.
</blockquote>
<A NAME=HEADING80>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Do <A NAME=136>Statement</FONT></H2>
<blockquote>
There are two do statements, which together have the same syntax as an ambi-valent
 primitive function (with the word <font face=Kapl>do</font> in place of the function
 symbol). Both the monadic and dyadic forms have an expression or expression group to the
 right of the word <font face=Kapl>do</font>. The dyadic form also has an expression to the
 left which would serve as the left argument if the word <font face=Kapl>do</font> were the
 name of a dyadic function. In the absence of pending punctuation, if
 <font face=Kapl>do</font> is entered alone on a line, it is taken to be complete, and
 echoed by A+, and if it is preceded by an expression but followed by nothing, a parse
 error is reported.
</blockquote>
<A NAME=HEADING81>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;If <A NAME=137>Statement</FONT></H2>
<blockquote>
The form of an if statement is the word <font face=Kapl>if</font>, followed by an expression in
 parentheses, followed by another expression or an expression group.  When <font face=Kapl>if</font>
 followed by an expression in parenthesis is entered alone on a line (with no pending
 unbalanced punctuation), the statement is taken to be complete, with Null for the
 expression group.
</blockquote>
<A NAME=HEADING82>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;If-Else <A NAME=138>Statement</FONT></H2>
<blockquote>
The form of an if-else statement is the word <font face=Kapl>if</font>, followed by an expression in
 parenthesis, followed by an expression or expression group, followed by the word
 <font face=Kapl>else</font>, followed by another expression or expression group.  When an if-else is
 entered, if there is nothing following the <font face=Kapl>else</font>, a parse error is reported in the
 absence of pending punctuation.
</blockquote>
<A NAME=HEADING83>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;While <A NAME=139>Statement</FONT></H2>
<blockquote>
The form of a while statement is the word <font face=Kapl>while</font>, followed by an expression in
 parentheses, followed by another expression or an expression group. When <font face=Kapl>while</font>
 followed by an expression in parenthesis is entered alone on a line (with no pending
 unbalanced punctuation), the statement is taken to be complete, with Null for the
 expression group.  If the expression in parenthesis is valid and nonzero, it is necessary
 to interrupt execution (by <b>Control-c Control-c</b>) before anything else can be done.
</blockquote>
<A NAME=HEADING84>
<H1><FONT color="#20B2AA">Function <A NAME=142>Definitions</FONT></H1>
<blockquote>
A function definition consists of a function header, followed by a colon, followed by the function body, which is either an A+ expression or an expression group.<P>
<A NAME=144>Function headers take the same forms as functional expressions (see "<A HREF="#54">Functions and Function Call Expressions</A>"), except that only names can appear and none can be omitted.  A function header has the monadic form, dyadic form, or general form.  The monadic form is the function name followed by the argument name, with the two names separated by at least one space.  For example, if the function name is <font face=Kapl>correlate</font> then
<pre><font face=Kapl>     correlate a:{</font> ... <font face=Kapl>}</font></pre>
is a function definition with the monadic form of the header.<P>
The dyadic form of function header is the function name with one argument name on each side, with the names separated by at least one blank.  For example:
<pre><font face=Kapl>     a correlate b:{</font> ... <font face=Kapl>}</font></pre>
is a function definition with the dyadic form of the header.<P>
The third form of function header is the general form, which is the function name followed by a left brace, followed by a list of from zero to nine argument names separated by semicolons, and terminated by a right brace.  For example:
<pre><font face=Kapl>     correlate{a;b;c}:{</font> ... <font face=Kapl>}</font></pre>
is a function definition with the general form of the header.  In this example the function has three arguments.  Names must appear in all positions of the argument list - no position can be left empty.  (In a niladic function definition no argument position is left empty; there just is no argument position.)<P>
A function with one argument can be defined with either the monadic form of function header or the general form and a function with two arguments can be defined with either the dyadic form or the general form.  In a reference to the function, either form (of the correct valence) can be used, no matter how it was defined.<P>
The number of arguments of a defined function is nine or fewer.  See the table
 "<A HREF="#152">Function Call Expressions and Function Header Formats</A>" for a summary.<P>
<b><A NAME=145>Note: </b>A position adjacent to a semicolon can be left empty for function call expressions.<P>
<A NAME=HEADING85>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>Function <A NAME=152>Call Expressions and
 Function Header Formats</B></FONT></caption>
<tr>
<th>Valence</th><th>Forms (<A HREF="#145">see note above</A>)</th></tr>
<tr><td>niladic</td><td><font face=Kapl>f{}</font></td></tr>
<tr><td>monadic</td><td><font face=Kapl>f a &nbsp;</font>or<font face=Kapl> &nbsp;f{a}</font></td></tr>
<tr><td>dyadic</td><td><font face=Kapl>a&nbsp;f&nbsp;b &nbsp;</font>or<font face=Kapl> &nbsp;f{a;b}</font></td></tr>
<tr><td>general</td><td><font face=Kapl>f{a;b;</font> ... <font face=Kapl>;c}</font></td></tr>
</table>
</blockquote>
<A NAME=HEADING86>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Function <A NAME=154>Result</FONT></H2>
<blockquote>
The result of a defined function is the result of the expression or expression group that forms the function body.  The result can be used in the same ways as the result of a primitive function.
</blockquote>
<A NAME=HEADING87>
<H1><FONT color="#20B2AA">Operator <A NAME=157>Definitions</FONT></H1>
<blockquote>
An operator definition consists of an operator header, followed by a colon, followed by the body of the definition, either an A+ expression or an expression group.  The header must be in infix, not general, form.<P>
An operator can be monadic or dyadic, depending on whether it has one argument or two, and the derived function can also be monadic or dyadic.  Consequently there are four forms for the header.  See the table "<A HREF="#162">Operator Header Formats</A>" for a summary.
<p>
Note the parentheses in the forms in this table.  While parentheses are not necessary in operator call expressions, they are necessary in operator definition headers to specify the function expression part.  Compare with the table "<A HREF="#89">Operator Call Expressions</A>".<p>
<A NAME=HEADING89>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>Operator <A NAME=162>Header
 Formats</B></FONT></caption>
<tr>
<th>Operator Valence</th><th>Monadic Derived Function</th><th>Dyadic
 Derived Function</th></tr>
<tr>
<td>monadic</td><td><font face=Kapl>(f&nbsp;op)a</font></td><td><font face=Kapl>a(f&nbsp;op)b</font></td></tr>
<tr>
<td>dyadic</td><td><font face=Kapl>(f&nbsp;op&nbsp;h)a</font></td><td><font face=Kapl>a(f&nbsp;op h)b</font></td></tr>
</table><P>
<i><b>NOTE:</b></i> In the dyadic form, if the right operand is the letter <font face=Kapl>g</font>, then it must be a function; otherwise, it must be data unless every occurrence in the body of the operator syntactically requires it to be a function.
</blockquote>
<A NAME=HEADING88>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Operator <A NAME=159>Result</FONT></H2>
<blockquote>
The result of a defined operator, which is strictly speaking the result of the derived function, is the result of the expression or expression group that forms the body of the definition.  The result can be used in the same ways as the result of a primitive operator.<P>
</blockquote>
<A NAME=HEADING90>
<H1><FONT color="#20B2AA">Dependency <A NAME=163>Definitions</FONT></H1>
<blockquote>
<A NAME=164>A dependency definition consists of a name (the name of the dependency), followed by a colon, followed by either an A+ expression, or an expression group.  An itemwise dependency has the same form except that the name is followed by <font face=Kapl>[i]</font> where <font face=Kapl>i</font> can be any unqualified user name (except the name of the dependency).
</blockquote>
<A NAME=HEADING91>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Dependency <A NAME=166>Result</FONT></H2>
<blockquote>
The result of a dependency is either a value that was assigned to the name, or the result of the expression or expression group that forms the definition, or, for itemwise dependencies, a combination of the two - see the "<A HREF="APlusRefV2_57.html#164">Dependencies</A>" chapter.  The results of dependencies are referenced in the same way that values of variables are referenced, simply by their names.
</blockquote>
<A NAME=HEADING92>
<H1><FONT color="#20B2AA">Well-Formed <A NAME=169>Expressions</FONT></H1>
<blockquote>
A well-formed expression is one of the basic forms described above, in which all of the constituent expressions are well formed.  The potential for complicated expressions arises from the fact that every one of these basic forms produces a result and can therefore be used as a constituent in other forms, except that the right arrow (<font face=Kapl>ý</font>) can only appear alone and the left arrow (<font face=Kapl>û</font>) must appear alone unless it has an expression to its right.  In this building of expressions from simpler ones A+ is very much like mathematical notation.<P>
<A NAME=171>The concept of the <i>principal subexpression</i> of an expression is useful for analysis.  As execution of an expression proceeds in the manner described in the "<A HREF="#128">Right to Left Order of Execution</A>" section, one can imagine that parts of the expression are executed and replaced by their results, and then other parts are executed using these results, and are replaced by their results, and so on.  Ultimately the execution comes to the last expression to be executed, which is called the principal subexpression.  Once it is executed, its value is the value of the expression.  If the principal subexpression is a function call expression or operator call expression, that function or derived function is called the <i>principal function</i>.<P>
For example, the principal subexpression of <font face=Kapl>(a+bßc-d)*10«n</font> is <font face=Kapl>x*y</font>, where <font face=Kapl>x</font> is the result of <font face=Kapl>a+bßc-d</font> and <font face=Kapl>y</font> is the result of <font face=Kapl>10«n</font>.  The power function <font face=Kapl>*</font> is the principal function.<P>
As a second example, the principal expression of <font face=Kapl>(x+y;x-y)</font> is <font face=Kapl>(w;z)</font>, where <font face=Kapl>w</font> is <font face=Kapl>x+y</font> and <font face=Kapl>z</font> is <font face=Kapl>x-y</font>. In this case we do not refer to a principal function; the last thing done in executing the expression is what is implied by the strand notation - enclosing <font face=Kapl>w</font> and <font face=Kapl>z</font> and catenating them.
</blockquote>
<HR>
<ADDRESS><table width="100%"><tr><td><font size=2><i><a href="mailto:doc@aplusdev.org">doc@aplusdev.org</a></i></font></td><td align=right><font size=2><i>&#169; Copyright 1995&#150;2008 Morgan Stanley Dean Witter &amp; Co.  All rights reserved.</i></font></td></tr></table></ADDRESS>
</BODY>
</HTML>

