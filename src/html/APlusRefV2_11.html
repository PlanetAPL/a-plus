<HTML>
<HEAD>
<TITLE>A+ Reference: Dyadic Operators</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME=HEADING220>
<H1><FONT color="#FF0000">Dyadic<A NAME=0> Operators</FONT></H1>

<a name="CONTENTS10">
<UL>
<A HREF="#HEADING221"> Common Error Reports</A><BR>
<A HREF="#HEADING222"> Definitions of Dyadic Operators</A><BR>
<UL>
<A HREF="#HEADING223"> Inner Product</A><font face=Kapl> y f.g x</font><BR>
<A HREF="#HEADING224"> Outer Product</A><font face=Kapl> y Ê.f x</font><BR>
<A HREF="#HEADING225"> Rank</A><font face=Kapl> f@n x </font>and<font face=Kapl> y f@n x</font><BR>
<UL>
<A HREF="#HEADING226"> Rank Operator uses Frames and Cells</A><BR>
<A HREF="#HEADING227"> The Rank Operator and Empty Arguments</A><BR>
<A HREF="#HEADING228"> Rank Deriving Monadic</A><font face=Kapl> f@n x</font><BR>
<A HREF="#HEADING229"> Rank Deriving Dyadic</A><font face=Kapl> y f@n x</font><BR>
</UL>
</UL>
</UL>
<HR>
<A NAME=HEADING221>
<H1><FONT color="#20B2AA">Common <A NAME=3>Error Reports</FONT></H1>
<blockquote>
Multiple errors elicit but one report.  If an error report in the following list is issued, then the ones preceding it do not apply.  Five reports are common to all dyadic operators:<P>
<UL>
<LI>parse;
<LI>value: an argument has no value;
<LI>nondata: an argument (not an operand) is a function or some other nondata object;
<LI>an error report from an operand function;
<LI>wsfull: the workspace is currently not large enough to execute the function in; a bare left arrow (<font face=Kapl>û</font>), which dictates resumption of execution, causes the workspace to be enlarged if possible;
<LI>interrupt (not an error): the user pressed <B>c</B> twice (once if A+ was started from a
 shell) while holding the <B>Control</B> key down.
</UL>
</blockquote>
<A NAME=HEADING222>
<H1><FONT color="#20B2AA">Definitions of Dyadic Operators</FONT></H1>
<A NAME=HEADING223>
<H2><FONT color="#20B2AA">Inner Product<font face=Kapl> <A NAME=7> y f.g x</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
There are three inner products in A+:<font face=Kapl> +.«</font>,<font face=Kapl> Ó.+</font>,&nbsp; and<font face=Kapl> Ä.+</font>.  The arguments <font face=Kapl>y</font> and <font face=Kapl>x</font> must be nonscalars, and <font face=Kapl>¢1ÙÒy</font> must equal <font face=Kapl>1ÙÒx</font>.  The shape of the result is <font face=Kapl>(¢1ÕÒy),1ÕÒx</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
For matrices <font face=Kapl>y</font> and <font face=Kapl>x</font>, the function <font face=Kapl>g</font> is applied to row vectors of <font face=Kapl>y</font> on the left and column vectors of <font face=Kapl>x</font> on the right, in all combinations; <font face=Kapl>f/</font> is applied to each these results.  That is:
<pre><font face=Kapl>      (y f.g x)[i;j] ûý f/y[i;]g x[;j]</font></pre>
for all scalar indices <font face=Kapl>i</font> and <font face=Kapl>j</font>.  The general definition of <font face=Kapl>+.«</font> is:
<pre><font face=Kapl>     y (pdt@1 1 0)(¢1÷ÉÒÒx)ôx</font></pre>
where
<pre><font face=Kapl>     a pdt b:+/a«b</font></pre>
The function <font face=Kapl>pdt</font> must be applied to vectors along the last axis of <font face=Kapl>y</font> and vectors along the first axis of <font face=Kapl>x</font>, in all combinations.  In order to do this with the Rank operator, the vectors along the first axis of <font face=Kapl>x</font> must be moved to the last axis.  The expression <font face=Kapl>(¢1÷ÉÒÒx)ôx</font> has the effect of moving the first axis of <font face=Kapl>x</font> to the last, while leaving all other axes in their original order.  <P>
Analogous definitions hold for <font face=Kapl>Ó.+</font> and <font face=Kapl>Ä.+</font>.<P>
As pointed out in "<A HREF="APlusRefV2_5.html#72">Operators and Derived Functions</A>", Inner Product is not in the strictest sense an operator, but for most purposes it can be regarded as one.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error report (see "<A HREF="APlusRefV2_10.html#3">Common Error Reports</A>") - the token report preceding the value report -, and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a token error is reported if <font face=Kapl>f</font> or <font face=Kapl>g</font> is a defined function name or a primitive function or operator symbol such that the derived function is not one of the three permitted forms;
<LI>a valence error is reported if there is no left argument for the derived function (a missing right argument is a parse error);
<LI>a rank error is reported if one of the arguments is a scalar;
<LI>a length error is reported if the last dimension of <font face=Kapl>y</font> and the first dimension of <font face=Kapl>x</font> are not equal.
</UL></BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre><font face=Kapl>     (É2 3)+.«(É3 4)
 20 23 26 29
 56 68 80 92</font></pre></BLOCKQUOTE>
<A NAME=HEADING224>
<H2><FONT color="#20B2AA">Outer <A NAME=10>Product</FONT>
<A NAME=APlusRefV2_FootNote_950 HREF=APlusRefV2_FootNote_950.html>
<b><sup>1</sup></b></A>
<FONT color="#20B2AA"><font face=Kapl>&nbsp;  y Ê.f x</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>f</font> can be one of <font face=Kapl>+</font>, <font face=Kapl>«</font>, <font face=Kapl>-</font>, <font face=Kapl>ß</font>, <font face=Kapl>Ó</font>, <font face=Kapl>Ä</font>, <font face=Kapl>|</font>, <font face=Kapl>&lt;</font>, <font face=Kapl>¤</font>, <font face=Kapl>=</font>, <font face=Kapl>¦</font>, <font face=Kapl>&gt;</font>, <font face=Kapl>¨</font>, and <font face=Kapl>*</font>.  The arguments <font face=Kapl>y</font> and <font face=Kapl>x</font> are any arrays whose elements are suitable left and right arguments of <font face=Kapl>f</font>, respectively.  The shape of the result is <font face=Kapl>(Òy),(Òx)</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The function <font face=Kapl>f</font> is applied to all combinations of scalars from <font face=Kapl>y</font> and <font face=Kapl>x</font>.  In particular, for vectors <font face=Kapl>x</font> and <font face=Kapl>y</font>:
<pre><font face=Kapl>     (yÊ.f x)[i;j] ûý y[i]f x[j]</font></pre>
for all scalar indices <font face=Kapl>i</font> and <font face=Kapl>j</font>.  Similar relations hold for arrays of other ranks.  In general, <font face=Kapl>yÊ.f x</font> is equivalent to <font face=Kapl>y(f@0 0 0)x</font>.<P>
As pointed out in the "<A HREF="APlusRefV2_5.html#72">Operators and Derived Functions</A>", Outer Product is not in the strictest sense an operator, but for most purposes it can be regarded as one.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
If there is no error reported as a parse error, then a similar error may be reported:<P>
<UL>
<LI>a token error is reported if <font face=Kapl>f</font> is a defined function name or a primitive function or operator symbol such that the derived function is not one of the permitted forms.
</UL>
The following report is issued only if there is no parse, token, or value error (see "<A HREF="APlusRefV2_10.html#3">Common Error Reports</A>"):<P>
<UL>
<LI>a valence error is reported if there is no left argument for the derived function (a missing right argument is a parse error).
</UL></BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre><font face=Kapl>
     1 10 100Ê.«1.2 ¢3 98.2 5
   1.2   ¢3     98.2    5
  12    ¢30    982     50
 120   ¢300   9820    500</font></pre></BLOCKQUOTE>
<A NAME=HEADING225>
<H2><FONT color="#20B2AA">Rank <A NAME=13> <font face=Kapl>f@n x</font>  and   <font face=Kapl>y f@n x</font></FONT></H2>
<blockquote>
(Just as for all operators, <font face=Kapl>f</font> cannot be Assignment.) Rank's derivation of monadic functions and its derivation of dyadic functions are covered in separate sections below.  First, however, you should understand how the operator decomposes arrays, and the implications for its handling of empty arrays.</blockquote>
<A NAME=HEADING226>
<H3><FONT color="#20B2AA"><b>&nbsp;&nbsp;&nbsp;Rank Operator uses Frames and Cells</b></FONT></H3>
<blockquote>
<A NAME=20>The Rank operator&nbsp; (<font face=Kapl>f@n x </font>and<font face=Kapl> y f@n x</font>)&nbsp; splits an array into equal-shaped cells held in a frame and applies its function to each cell.  The frame's shape consists of zero or more leading dimensions of the array and the cells' shape consists of the remaining zero or more trailing dimensions.  (Cf. "<A HREF="APlusRefV2_4.html#17">Dimension, Shape, and Rank</A>".)  Rank deriving dyadic splits each argument separately.<P>
For example, a function applied to an array of shape 3 4 5 using the Rank operator may be applied to:<P>
<UL>
<LI>cells of shape <font face=Kapl>É0</font> (scalar) in a frame of shape 3 4 5; or
<LI>cells of shape 5 in a frame of shape 3 4; or
<LI>cells of shape 4 5 in a 3-item frame; or
<LI>a single cell with shape 3 4 5 in a frame with shape <font face=Kapl>É0</font> (scalar).
</UL>
Rank allows specification of the rank of either the cells (a positive number in <font face=Kapl>n</font>) or the frame (a negative number in <font face=Kapl>n</font>, whose magnitude is used).  For example, to have the Rank operator apply a function to rank-2 cells in a 3-dimensional array, you can use either 2 (for the rank of each cell) or -1 (for a frame rank of 1).<P>
If<font face=Kapl> |n </font>exceeds the rank of an argument to which it is applied, it is treated as if it equaled that rank.  Thus you can specify both extreme cases in a way independent of rank: to allot all the axes to the frame, you specify cell rank to be 0, of course; to give all axes to the cells, you specify cell rank to be 9, the limit on ranks.<P>
</blockquote>
<A NAME=HEADING227>
<H3><FONT color="#20B2AA"><b>&nbsp;&nbsp;&nbsp;The Rank Operator and Empty Arguments</b></FONT></H3>
<blockquote>
The shape of the result of the derived function is always determined in the same way (with any additional axes on the right produced by the operand function), whether the arguments are empty or not.  The type of the result, however, is a different matter.  In the absence of an empty frame, the type is determined by the operand function, for the empty cells.  On the other hand, if a frame is empty, the Rank operator never calls this function.  For a primitive function, Rank uses its result type, or at least its default result type.  For a nonprimitive function, it uses null.  These examples show this type selection:
<pre></font><font face=Kapl>     y f x:x     ã </font>A simple function to be used as an operand.</pre>
<pre></font><font face=Kapl>     ©2(f@1)É0   ã </font>Scalar frames, empty-vector cells (left argument is made<font face=Kapl>
 `int            ã </font>to conform to right). An empty integer vector is returned<font face=Kapl>
                 ã </font>to Rank by <font face=Kapl>f</font>.</pre>
<pre></font><font face=Kapl>     ©2(f@0)É0   ã </font>An empty-vector frame (from right argument); no (scalar)<font face=Kapl>
 `null           ã </font>cells for <font face=Kapl>f</font>, so no call. Rank makes the result type null.</pre>
<pre></font><font face=Kapl>     ©2(+@1)É0   ã </font>Like the first example.<font face=Kapl>
 `int            ã +É0 </font>is integer.</pre>
<pre></font><font face=Kapl>     ©2(+@0)É0   ã </font>Rank doesn't apply Add to anything, but does use the type<font face=Kapl>
 `int            ã </font>implied by Add: the Add result type for integers is integer,<font face=Kapl>
                 ã </font>if the result can be so represented.</pre>
<pre></font><font face=Kapl>     (É0) ß@0 É0 ã </font>Rank passes fake args (the usual zeros, unhappily)<font face=Kapl>
 ß: domain       ã </font>to the operand function to determine the size and<font face=Kapl>
                 ã </font>type of the result.<font face=Kapl> Divide</font> is not amused.</pre>
</blockquote>
<A NAME=HEADING228>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Rank <A NAME=21>Deriving Monadic  <font face=Kapl>f@n x</font></FONT></H3><BLOCKQUOTE>
The rank specification <font face=Kapl>n</font> is a one-element integer array.  For conformity with the discussion of Rank deriving dyadic, assume <font face=Kapl>n</font> is a vector.  Then if <font face=Kapl>n</font> is nonnegative, Rank applies <font face=Kapl>f</font> to cells of rank <font face=Kapl>jûn[0]ÄÒÒx</font> within a frame of shape <font face=Kapl>(-j)ÕÒx</font>.<P>
If <font face=Kapl>n</font> is negative, Rank applies <font face=Kapl>f</font> to cells of rank <font face=Kapl>kû0Ó(ÒÒx)-|n[0]</font> within a frame of shape <font face=Kapl>(-k)ÕÒx</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued for Rank deriving monadic only if there is no parse or value error (see "<A HREF="APlusRefV2_10.html#3">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if <font face=Kapl>n</font> is not a simple integer array;
<LI>a length error is reported if <font face=Kapl>n</font> has more than 3 elements (although only the first element is used);
<LI>a nonfunction error is reported if <font face=Kapl>f</font> is not a function.
</UL></BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     (+/@1) 2 3Ò10 20 30 1 2 3 ã </font>The data operand must be separated<font face=Kapl>
 60 6              ã </font>from the left argument of Reshape: parentheses used.</pre>
<pre></font><font face=Kapl>     ÷@¢1 É2 3 4   ã </font>The frame is of rank 1, so the cells are of rank 2.<font face=Kapl>
  8  9 10 11       ã ÷</font> is called twice, with matrices as arguments,<font face=Kapl>
  4  5  6  7       ã </font>so the items whose order is reversed by<font face=Kapl>
  0  1  2  3       ã ÷</font> are rows.<font face=Kapl>

 20 21 22 23
 16 17 18 19
 12 13 14 15</font></pre>
<pre></font><font face=Kapl>     ÷@1 É2 3 4    ã </font>The cells are of rank 1, so the frame is of rank 2.<font face=Kapl>
  3  2  1  0       ã ÷</font> is called six times, with rows as arguments,<font face=Kapl>
  7  6  5  4       ã </font>so the items whose order is reversed by<font face=Kapl>
 11 10  9  8       ã ÷</font> are scalars.<font face=Kapl>

 15 14 13 12
 19 18 17 16
 23 22 21 20</font></pre>
<pre></font><font face=Kapl>     ÷@3 É2 3 4    ã </font>The cells are of rank 3, so the frame is scalar.<font face=Kapl>
 12 13 14 15       ã ÷</font> is called just once, with a rank-3 array as arg,<font face=Kapl>
 16 17 18 19       ã </font>so the items whose order is reversed by<font face=Kapl>
 20 21 22 23       ã ÷</font> are matrices.<font face=Kapl>
                   ã ÷@3 É2 3 4 </font>is equivalent to<font face=Kapl> ÷É2 3 4
  0  1  2  3
  4  5  6  7
  8  9 10 11</font></pre></BLOCKQUOTE>
<A NAME=HEADING229>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Rank <A NAME=23>Deriving Dyadic  <font face=Kapl>y f@n x</font></FONT></H3><BLOCKQUOTE>
The rank specification <font face=Kapl>n</font> must be an integer array with one, two, or three elements.   For convenience, assume <font face=Kapl>n</font> is a vector throughout this description.<P>
There are three behaviors for Rank deriving dyadic, depending upon <font face=Kapl>n</font>;<P>
<UL>
<LI><A NAME=25>when <font face=Kapl>n</font> has one or two elements, Rank deriving dyadic bears some similarity to a scalar dyadic function: the resulting frames on <font face=Kapl>x</font> and <font face=Kapl>y</font> must be the same shape after any deficiency in the rank of one of them is made up by replication (a very permissive scalar extension), and the operand function is applied to pairs of corresponding cells;<P>
<LI><A NAME=27>when <font face=Kapl>n</font> has a third element of zero, the operator bears a similarity to Outer Product: the operand function is applied to pairs of cells in all possible combinations;<P>
<LI>when <font face=Kapl>n</font> has a nonzero third element, the operator bears some similarity to a scalar dyadic function on the trailing <font face=Kapl>n[2]</font> axes of the frames and a similarity to Outer Product on the remaining (leading) axes of the frames (but see below for the subtleties glossed over here).
</UL>
If <font face=Kapl>n</font> has one element and is nonnegative, Rank applies <font face=Kapl>f</font> to cells of rank <font face=Kapl>jûn[0]ÄÒÒx</font> within a frame of shape <font face=Kapl>(-j)ÕÒx</font> on <font face=Kapl>x</font> and to cells of rank <font face=Kapl>kûn[0]ÄÒÒy</font> within a frame of shape <font face=Kapl>(-k)ÕÒy</font> on <font face=Kapl>y</font>.<P>
If <font face=Kapl>n</font> has one element and is negative , Rank applies <font face=Kapl>f</font> to cells of rank <font face=Kapl>jû0Ó(ÒÒx)-|n[0]</font> within a frame of shape <font face=Kapl>(-j)ÕÒx</font> on <font face=Kapl>x</font> and to cells of rank <font face=Kapl>kû0Ó(ÒÒy)-|n[0]</font> within a frame of shape <font face=Kapl>(-k)ÕÒy</font> on <font face=Kapl>y</font>.  A common case is <font face=Kapl>f@¢1</font> (which pairs items from both arguments and applies the function <font face=Kapl>f</font> to each pair).<P>
If <font face=Kapl>n</font> has two elements, then the first element of <font face=Kapl>n</font> is used for <font face=Kapl>y</font> and the second element is used for <font face=Kapl>x</font>, each interpreted in the same way as when <font face=Kapl>n</font> has one element.<P>
<A NAME=28>When <font face=Kapl>n</font> has three elements, the first two are used in the manner just stated.  The third element of <font face=Kapl>n</font> breaks the frame into two subframes, leading and trailing.  It specifies the number of trailing axes in the frames of <font face=Kapl>x</font> and <font face=Kapl>y</font> in which cells will be paired with corresponding cells, and in which, therefore, mismatched dimensions are forbidden.  Any leading dimensions present in one trailing subframe and absent in the other - which must in this case be a whole frame -, are supplied by replicating the latter subframe.  Any remaining (leading) axes of the frames are used to create subframes whose members are paired in all possible ways, in the manner of an outer product.  Again, <font face=Kapl>n</font> can be excessive; any excess is dealt with as described in the next paragraphs.<P>
Assume, just for convenience, that the first two elements of <font face=Kapl>n</font> are positive. Set<br>
<NOBR><font face=Kapl>cyûn[0]ÄÒÒy </font>and<font face=Kapl> cxûn[1]ÄÒÒx</font></NOBR><font face=Kapl> </font>
<NOBR>(cell ranks),</NOBR><font face=Kapl> </font>
<NOBR><font face=Kapl>tyûn[2]Ä(ÒÒy)-cy </font>and<font face=Kapl> txûn[2]Ä(ÒÒx)-cx</font></NOBR><font face=Kapl> </font>
<NOBR>(ranks of the trailing parts of the frames), and</NOBR><font face=Kapl> </font>
<NOBR><font face=Kapl> lyû0Ó(ÒÒy)-cy+ty </font>and<font face=Kapl> lxû0Ó(ÒÒx)-cx+tx</font></NOBR><font face=Kapl> </font>
<NOBR>(ranks of the leading parts of the frames).</NOBR><P>
That is, the cell specifications are honored to the extent possible, then the trailing subframe specification is honored to the extent possible, and the leading subframes are whatever is left.  The function <font face=Kapl>f</font> is applied to pairs of cells of rank <font face=Kapl>cy</font> and <font face=Kapl>cx</font> taken from <font face=Kapl>y</font> and <font face=Kapl>x</font> respectively, using all combinations of subscripts for the first <font face=Kapl>ly</font> and <font face=Kapl>lx</font> axes and corresponding subscripts for the next <font face=Kapl>tyÓtx</font> axes (after possible replication of one trailing subframe to make these subframes match).<P>
Whether the cells match is the responsibility of the operand function.  The two leading subframes have no compatibility requirement.  The two trailing subframes must match only as far as they both exist: specifically,
<pre><font face=Kapl>     (-tyÄtx)Ù(-cy)ÕÒy  ûý  (-tyÄtx)Ù(-cx)ÕÒx</font>.</pre>
Clearly, if <font face=Kapl>ty</font> is less than <font face=Kapl>tx</font> (and so the trailing subframe for <font face=Kapl>y</font> is replicated to match the shape of the trailing subframe for <font face=Kapl>x</font>), then <font face=Kapl>ly</font> is zero, and if <font face=Kapl>tx</font> is less than <font face=Kapl>ty</font>, then <font face=Kapl>lx</font> is zero.<P>
<pre></font>Note that:
if <font face=Kapl>n</font> has only one element,<font face=Kapl> y (f@n) x </font>is equivalent to<font face=Kapl> y (f@ n,n) x
</font>        which is equivalent to<font face=Kapl> y (f@ n,n,9) x
</font>and if <font face=Kapl>n</font> has exactly two elements,<font face=Kapl> y (f@n) x </font>is equivalent to<font face=Kapl> y (f@ n,9) x</font>.
When <font face=Kapl>n</font> has fewer than three elements, the trailing subframes are simply the frames.</pre></BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued for Rank deriving dyadic only if there is no parse or value error (see "<A HREF="APlusRefV2_10.html#3">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if <font face=Kapl>n</font> is not a simple integer array;
<LI>a length error is reported if <font face=Kapl>n</font> has more than 3 elements;
<LI>a mismatch error is reported if the shapes of the subframes do not match;
<LI>a nonfunction error is reported if <font face=Kapl>f</font> is not a function.
</UL></BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     '--&gt;' ,@1 Û4!'abcdABCD' ã </font>Rank 1 cell (rank 0 frame) vs. rank 1<font face=Kapl>
 --&gt;abcd                     ã </font>cell (rank 1 frame). The scalar left<font face=Kapl>
 --&gt;ABCD                     ã </font>frame is treated as a 2-element vector.<font face=Kapl>

     '01' ,@¢1 Û4!'abcdABCD' ã </font>Rank 1 frame (rank 0 cell) vs. rank 1<font face=Kapl>
 0abcd                       ã </font>frame (rank 1 cell).<font face=Kapl>
 1ABCD

     (É3)(,@0 1)É2 3 4       ã </font>Rank 0 cell (rank 1 frame) vs. rank 1<font face=Kapl>
   0  0  1  2  3             ã </font>cell (rank 2 frame). The vector left<font face=Kapl>
   1  4  5  6  7             ã </font>frame is treated as a 2 by 3 matrix: the<font face=Kapl>
   2  8  9 10 11             ã </font>"missing" dimension is supplied.<font face=Kapl>

   0 12 13 14 15
   1 16 17 18 19
   2 20 21 22 23

     (1990+É2)(,@0 1 0)É2 3  ã </font>Both left argument scalars vs.<font face=Kapl>
 1990    0    1    2         ã </font>both right argument vectors. Cells left<font face=Kapl>
 1990    3    4    5         ã </font>rank 0, right rank 1; rank 0 trailing<font face=Kapl>
                             ã </font>subframes and rank 1 leading subframes<font face=Kapl>
 1991    0    1    2         ã </font>for both.<font face=Kapl>
 1991    3    4    5

     (É2 3 4),@1 1 2(É2 3 9) ã </font>Vector vs. vector, rank 0 leading<font face=Kapl>
   0  1  2  3  0  1  2  3  4  5  6  7  8  ã </font>subframes. The<font face=Kapl>
   4  5  6  7  9 10 11 12 13 14 15 16 17  ã 1 1 2 </font>operand<font face=Kapl>
   8  9 10 11 18 19 20 21 22 23 24 25 26  ã </font> could as well be<font face=Kapl>
                                          ã 1 1
  12 13 14 15 27 28 29 30 31 32 33 34 35
  16 17 18 19 36 37 38 39 40 41 42 43 44
  20 21 22 23 45 46 47 48 49 50 51 52 53

</font></pre>
Now vector cells, from corresponding rows, both planes vs. both planes (rank 1
 cells, rank 1 trailing subframes, and rank 1 leading subframes for both). The
 arguments are:
<pre></font><font face=Kapl>     2 3 3Ò"my you it  t hedog"
my
you
 it

  t
 he
dog

</font>and<font face=Kapl>

     2 3 4Ò"hat  did is win rs  's  "
hat
 did
 is

win
rs
's
</font></pre>
Applying<font face=Kapl> ,@1&nbsp;1&nbsp;1 </font>to them yields
<pre><font face=Kapl>     (2 3 3Ò"my you it  t hedog")(,@1 1 1
*     )2 3 4Ò"hat  did is win rs  's  "
my hat
you did
 it is
my win
yours
 it's


  that
 he did
dog is

  twin
 hers
dog's</font></pre>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Errors</b><BLOCKQUOTE>
Errors may be reported by either the operator or an operand:
<pre></font><font face=Kapl>
     (É2 4 4),@1 1(É2 3 9)  ã </font>One trailing subframe a vector of length<font face=Kapl>
,@1: mismatch               ã </font>four, the other a vector of length three.<font face=Kapl>
*     ý                     ã </font>Rank notes the discrepancy in lengths.<font face=Kapl>

     (É24)(+@0)É23
+@0: mismatch               ã </font>Rank can't pair scalar cells for Add.<font face=Kapl>
*     ý

     (É24)(+@1)É23          ã </font>Rank can pair vector cells for Add,<font face=Kapl>
 +: length                  ã </font>but Add can't pair scalar items.<font face=Kapl>
*      ý</font></pre>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inner and Outer Products</b><BLOCKQUOTE>
If there is no Outer Product for <font face=Kapl>f</font>,<font face=Kapl>
 f@0&nbsp;0&nbsp;0 </font>may be used.<br>
Sine, cosine, tangent of 0&nbsp;45&nbsp;90&nbsp;...&nbsp;360 degrees, with the
 result doctored to show <font face=Kapl>Inf</font>:
<pre><font face=Kapl>     8.4î 1 2 3 Ï@0 0 0 Ï.25«É9
  0.0000  0.7071  1.0000  0.7071  0.0000 -0.7071 -1.0000 -0.7071  0.0000
  1.0000  0.7071  0.0000 -0.7071 -1.0000 -0.7071  0.0000  0.7071  1.0000
  0.0000  1.0000     Inf -1.0000  0.0000  1.0000    ¢Inf -1.0000  0.0000</font></pre>
If there is no Inner Product for <font face=Kapl>f</font> and
 <font face=Kapl>g</font>,<font face=Kapl> f/@(ÒÒy)&nbsp;x&nbsp;g@0&nbsp;¢1&nbsp;y
 </font>may be used (if there is no Reduction for <font face=Kapl>f</font> a
 defined reduction operator may be used). For<font face=Kapl>
 (É2&nbsp;12)^.&lt;É12&nbsp;24</font>:
<A NAME=29><pre><font face=Kapl>     ^/@2 (É2 12) &lt;@0 ¢1 É12 24
 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1</font></pre>
</BLOCKQUOTE>
<HR>
<ADDRESS><table width="100%"><tr><td><font size=2><i><a href="mailto:doc@aplusdev.org">doc@aplusdev.org</a></i></font></td><td align=right><font size=2><i>&#169; Copyright 1995&#150;2008 Morgan Stanley Dean Witter &amp; Co.  All rights reserved.</i></font></td></tr></table></ADDRESS>
</BODY>
</HTML>
