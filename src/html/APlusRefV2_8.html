<HTML>
<HEAD>
<TITLE>A+ Reference: Nonscalar Primitive Functions</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME=HEADING134>
<H1><FONT color="#FF0000">Nonscalar <A NAME=0>Primitive Functions</FONT></H1>

<a name="CONTENTS7">
<UL>
<A HREF="#HEADING135"> Classification of Nonscalar Primitive Functions</A><BR>
<A HREF="#HEADING136"> Common Error Reports</A><BR>
<A HREF="#HEADING136A"> Function Definitions</A><BR>
<UL>
<A HREF="#HEADING137"> Assignment</A><font face=Kapl> xûa</font> and <font face=Kapl>(x)ûa</font><BR>
<UL>
<A HREF="#HEADING138"> Strand Assignment</A><BR>
<A HREF="#HEADING139"> Value and Value in Context Assignment</A><BR>
<A HREF="#HEADING140"> Assignment of Objects Bound to Display Classes</A><BR>
</UL>
 In Separate Chapter on Files: <A HREF="APlusRefV2_19.html#0">Beam</A><font face=Kapl> àx </font>and<font face=Kapl> yàx</font><BR>
<A HREF="#HEADING141"> Bins</A><font face=Kapl> yèx</font><BR>
<UL>
<A HREF="#HEADING142">Table:&nbsp; Bins for Numeric Vectors</A><BR>
</UL>
<A HREF="#HEADING143"> Bracket Indexing</A><font face=Kapl> x[a;b;...;c]</font><BR>
<A HREF="#HEADING144"> Cast</A><font face=Kapl> y©x</font><BR>
<A HREF="#HEADING145"> Catenate</A><font face=Kapl> y,x</font><BR>
<A HREF="#HEADING146"> Choose</A><font face=Kapl> y#x</font><BR>
<A HREF="#HEADING147"> Count</A><font face=Kapl> #x</font><BR>
<A HREF="#HEADING148"> Deal</A><font face=Kapl> y?x</font><BR>
<A HREF="#HEADING149"> Decode</A><font face=Kapl> yÂx</font><BR>
<A HREF="#HEADING150"> Default Format</A><font face=Kapl> îx</font><BR>
<A HREF="#HEADING151"> Depth</A><font face=Kapl> ½x</font><BR>
<A HREF="#HEADING152"> Disclose</A><font face=Kapl> &gt;x</font><BR>
<A HREF="#HEADING153"> Drop</A><font face=Kapl> yÕx</font><BR>
<A HREF="#HEADING154"> Enclose</A><font face=Kapl> &lt;x</font><BR>
<A HREF="#HEADING155"> Encode</A><font face=Kapl> yÎx</font><BR>
<A HREF="#HEADING156"> Execute</A><font face=Kapl> âx</font><BR>
<A HREF="#HEADING157"> Execute in Context or Protected Execute</A><font face=Kapl> yâx</font><BR>
<A HREF="#HEADING158"> Expand</A><font face=Kapl> y\x</font><BR>
<A HREF="#HEADING159"> Find</A><font face=Kapl> yÉx</font><BR>
<A HREF="#HEADING160"> Format</A><font face=Kapl> yîx</font><BR>
<A HREF="#HEADING161"> Grade down</A><font face=Kapl> çx</font><BR>
<A HREF="#HEADING162"> Grade up</A><font face=Kapl> èx</font><BR>
<A HREF="#HEADING163"> Interval</A><font face=Kapl> Éx</font><BR>
<A HREF="#HEADING164"> Item Ravel</A><font face=Kapl> !x</font><BR>
<A HREF="#HEADING165"> Laminate</A><font face=Kapl> y~x</font><BR>
<A HREF="#HEADING166"> Left</A><font face=Kapl> yÝx</font><BR>
<A HREF="#HEADING167"> Match</A><font face=Kapl> y½x</font><BR>
<A HREF="#HEADING168"> Matrix Inverse</A><font face=Kapl> ­x</font><BR>
<A HREF="#HEADING169"> Member</A><font face=Kapl> yÅx</font><BR>
<A HREF="#HEADING170"> Null</A><font face=Kapl> Ýx</font><BR>
<A HREF="#HEADING171"> Pack</A><font face=Kapl> Âx</font><BR>
<A HREF="#HEADING172"> Partition</A><font face=Kapl> yÚx</font><BR>
<A HREF="#HEADING173"> Partition Count</A><font face=Kapl> Úx</font><BR>
<A HREF="#HEADING174"> Pick</A><font face=Kapl> yØx</font><BR>
<A HREF="#HEADING175"> Print</A><font face=Kapl> Õx</font><BR>
<A HREF="#HEADING176"> Rake</A><font face=Kapl> Åx</font><BR>
<A HREF="#HEADING177"> Ravel</A><font face=Kapl> ,x</font><BR>
<A HREF="#HEADING178"> Raze</A><font face=Kapl> Øx</font><BR>
<A HREF="#HEADING179"> Replicate</A><font face=Kapl> y/x</font><BR>
<A HREF="#HEADING180"> Reshape</A><font face=Kapl> yÒx</font><BR>
<A HREF="#HEADING181"> Restructure</A><font face=Kapl> y!x</font><BR>
<A HREF="#HEADING182"> Result</A><font face=Kapl> ûx</font><BR>
<A HREF="#HEADING183"> Reverse</A><font face=Kapl> ÷x</font><BR>
<A HREF="#HEADING184"> Right</A><font face=Kapl> Ûx</font><BR>
<A HREF="#HEADING185"> Rotate</A><font face=Kapl> y÷x</font><BR>
<A HREF="#HEADING186"> Selective Assignment</A><font face=Kapl> targetûa</font><BR>
<UL>
<A HREF="#HEADING187"> Bracket Indexing Selective Assignment</A><BR>
<A HREF="#HEADING188"> Replace All</A><font face=Kapl> x[]ûa</font><BR>
<A HREF="#HEADING189"> Append</A><font face=Kapl> x[,]ûa</font><BR>
<A HREF="#HEADING190">Table:&nbsp; Targets of Selective Assignment</A><BR>
<A HREF="#HEADING191"> Primitive Functions in Selective Assignment Expressions</A><BR>
<A HREF="#HEADING192"> Defined Functions in Selective Assignment Expressions</A><BR>
<A HREF="#HEADING193"> Brace Assignment</A><font face=Kapl> {w;y;...;z;x}ûa</font><BR>
<A HREF="#HEADING194"> Selective Assignment of Objects Bound to Display Classes</A><BR>
</UL>
<A HREF="#HEADING195"> Separate Symbols</A><font face=Kapl> Öx</font><BR>
<A HREF="#HEADING196"> Shape</A><font face=Kapl> Òx</font><BR>
<A HREF="#HEADING197"> Signal</A><font face=Kapl> Ùx</font><BR>
<A HREF="#HEADING198"> Solve</A><font face=Kapl> y­x</font><BR>
<A HREF="#HEADING199"> Stop</A><font face=Kapl> ^x</font><BR>
<A HREF="#HEADING200"> Take</A><font face=Kapl> yÙx</font><BR>
<UL>
<A HREF="#HEADING201">Table:&nbsp; Fill Elements</A><BR>
</UL>
 In Separate Chapter on Timing Execution:&nbsp; <A HREF="APlusRefV2_20.html#0">Time<font face=Kapl></A> time{} </font>and<font face=Kapl> time x</font><BR>
<A HREF="#HEADING202"> Transpose</A><font face=Kapl> ôx</font><BR>
<A HREF="#HEADING203"> Transpose Axes</A><font face=Kapl> yôx</font><BR>
<A HREF="#HEADING204"> Type</A><font face=Kapl> ©x</font><BR>
<A HREF="#HEADING205"> Unpack</A><font face=Kapl> Îx</font><BR>
<A HREF="#HEADING206"> Value</A><font face=Kapl> %x</font><BR>
<A HREF="#HEADING207"> Value in Context</A><font face=Kapl> y%x</font><BR>
</UL>
</UL>
<HR>
<BLOCKQUOTE>
As noted earlier, the term</font><i> integer</i> indicates here a domain of values and a particular internal representation.  The term <i>restricted whole number</i> refers to the same domain of values when both integer and floating-point representations are allowed.  The floating-point representations need only be tolerably equal to integers.
</BLOCKQUOTE>
<A NAME=HEADING135>
<H1><FONT color="#20B2AA">Classification <A NAME=1>of Nonscalar Primitive Functions</FONT></H1>
<BLOCKQUOTE>
Although (except for Beam and Time) they are listed alphabetically in this chapter, for
 convenient reference, the A+ nonscalar primitive functions can be grouped, among many
 other ways, in these eight categories:<P>
<UL>
<LI>informational functions: Shape, Count, Depth, Type;
<LI>structural functions: Reshape, Interval, Restructure, Reverse, Rotate, Transpose, Transpose Axes, Ravel, Item Ravel, Enclose, Disclose, Rake, Raze, Partition, Take, Drop, Replicate, Expand, Catenate, Laminate;
<LI>selection functions: Pick, Choose, Bracket Indexing, Right, Left, Null, Separate Symbols;
<LI>computational functions: Matrix Inverse, Solve, Deal, Pack, Unpack, Encode, Decode;
<LI>comparison functions: Match, Member, Find, Bins, Grade up, Grade down, Partition Count;
<LI>format and representation functions: Format, Default Format, Cast;
<LI>specificational functions:  Assignment, Append, Bracket Indexing Selective Assignment, Replace All, Selective Assignment;&nbsp; Beam;
<LI>evaluative, display, and control functions: Execute, Execute in Context, Protected Execute, Value, Value in Context, Result, Signal, Print, Stop;&nbsp; Time.
</UL>
</BLOCKQUOTE>
<A NAME=HEADING136>
<H1><FONT color="#20B2AA">Common <A NAME=4>Error Reports</FONT></H1>
<BLOCKQUOTE>
Multiple errors elicit but one report.  If an error report in the following list is issued, then the ones preceding it do not apply.  Five reports are common to all nonscalar primitive functions:<P>
<UL>
<LI>parse: this error class includes valence errors that result from three or more arguments in braces;
<LI>value: an argument has no value;
<LI>nondata: an argument is a function or some other nondata object;
<LI>wsfull: the workspace is currently not large enough to execute the function in; a bare left arrow (<font face=Kapl>û</font>), which dictates resumption of execution, causes the workspace to be enlarged if possible;
<LI>interrupt (not an error): the user pressed <b>c</b> twice (once if A+ was started from a
 shell) while holding the <b>Control</b> key down.
</UL>
Except where noted, inappropriate omission or inclusion of a left argument results not in a valence error report but in the invocation of the function or operator that shares the function symbol.
</BLOCKQUOTE>
<A NAME=HEADING136A>
<H1><FONT color="#20B2AA">Function Definitions</FONT></H1>
<A NAME=HEADING137>
<H2><FONT color="#20B2AA">Assignment<A NAME=13><font face=Kapl>  xûa</font> and <font face=Kapl>(x)ûa</font></font></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The right argument <font face=Kapl>a</font> is any array or function expression (see "<A HREF="APlusRefV2_5.html#92">Function Expressions</A>").  <A NAME=14>The left argument is the <i>target</i> of the assignment.  <font face=Kapl>x</font> represents a valid user name.  The explicit result is equal to <font face=Kapl>a</font>; it is not displayed in an Emacs session, unlike other explicit results, unless it is the result of an expression group.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The explicit result is the value <font face=Kapl>a</font> if <font face=Kapl>a</font> is an array, and otherwise a function expression identical to <font face=Kapl>a</font>.  The side effect is to assign the value or function expression <font face=Kapl>a</font> to the object <font face=Kapl>x</font>.  For a function expression, note that it is the function that is assigned to the target, not the name of the function.  See also "<A HREF="#257">Selective Assignment</A>".<P>
The two forms of Assignment are equivalent when used outside function and operator definitions, but have different meanings inside if <font face=Kapl>x</font> is an unqualified name.  Inside a function or operator definition, any appearance of <font face=Kapl>xûa</font> means that <font face=Kapl>x</font> will be a local variable, while, in the absence of that form, the form <font face=Kapl>(x)ûa</font> can be used to assign a value to the global variable <font face=Kapl>x</font>, whose context will be the context in which the function was defined.<P>
Assignment, in any form, cannot be the operand of an operator.</BLOCKQUOTE>
<A NAME=HEADING138>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Strand <A NAME=17>Assignment</FONT></H3>
<BLOCKQUOTE>
Several <i>ordinary</i> assignments can be incorporated into one by means of strand
 assignment. For example:<P>
<pre></font><font face=Kapl>     (a;c.b;f;d;d)û('ABC';10+É3 4;+.«;2;5)</font></pre>
Each item of the right argument is disclosed and assigned to the corresponding name
 on the left. Note that <font face=Kapl>f</font> becomes a function scalar in this example,
 not a function, and that <font face=Kapl>d</font> ends up with the value 5. After all the
 individual assignments have been made, the saved values for any dependencies among the
 targets are marked valid.  Strand assignment is important when working with dependencies.
 See the discussion of commit and cancel for sets of dependencies in
 "<A HREF="APlusRefV2_17.html#48">Cyclic Dependencies</A>". Strands are not permitted as
 targets of Selective Assignments.<P>
The left argument must appear in strand notation. The right argument, therefore, must be a
 vector (of the same length as the left argument) or a scalar, but, since it is its <i>value</i> that is
 used, it can appear in any form, and, since Disclose accepts a simple argument, it can be
 a simple vector.<P>
This example demonstrates that the righthand side is evaluated right to left and then the
 assignments are made left to right:<P>
<pre></font><font face=Kapl>     aû1; bû2;
     f{s;d;i;p;c;v}:Õv
     (a;b)û(b Ý `a`b _scb¡ &lt;(f;); aû3)
 `a
 `b</font></pre>
Strand Assignment does
 not trigger a screen update until the interpreter has made the assignments for
 <i>all</i> the variables involved.
This is done in order to avoid problems which could occur
 when several columns of a displayed table object,
 including the first, are
 being updated, with changed lengths.
</BLOCKQUOTE>
<A NAME=HEADING139>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Value and <A NAME=19>Value in Context Assignment</FONT></H3>
<BLOCKQUOTE>
Both <A NAME=21><A HREF="#331">Value</A> and <A HREF="#339">Value in Context</A> can be used in targets, viz., <font face=Kapl>(c%x)ûa</font> and <font face=Kapl>(%x)ûa</font>, where <font face=Kapl>c</font> and <font face=Kapl>x</font> are any expressions producing simple scalar symbols.  The form <font face=Kapl>(k%¡y)ûa</font> can also be used; it has the same effect as <A HREF="#17">Strand Assignment</A>, but is more flexible, since the statement does not involve a fixed number of variables with fixed names.  The latter form cannot be combined with <A HREF="#257">Selective Assignment</A> in any way.
 See the <A HREF="#17">Strand Assignment</A> discussion regarding the timing of screen updates.
<P>
The context for the object of a Value Assignment is always the current context, so if the Assignment is in a function, the context is the one in which the function was called or the one which the function set before executing the Value Assignment.  The use of these functions in assignment is important for working with callback functions;  see the "<A HREF="APlusRefV2_18.html#0">Callback Functions</A>" chapter.
</BLOCKQUOTE>
<A NAME=HEADING140>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Assignment of <A NAME=26>Objects Bound to Display Classes</FONT></H3>
<BLOCKQUOTE>
<A NAME=27>The assignment primitive <font face=Kapl>xûa</font> is affected by display class bindings.  If <font face=Kapl>a</font> is bound but <font face=Kapl>x</font> is not, <font face=Kapl>x</font> does not inherit the class of <font face=Kapl>a</font> or any of its attributes.  If <font face=Kapl>x</font> is bound then <font face=Kapl>a</font> must be in the domain of the class of <font face=Kapl>x</font>, i.e., it must be possible to bind <font face=Kapl>a</font> to the class of <font face=Kapl>x</font>.  This rule applies to Selective Assignment as well.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
The following report is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>an invalid error is reported if <font face=Kapl>x</font> is bound to a display class and
 the value it is to be given is not valid for objects bound to that display class - see
 <font face=Kapl><A HREF="APlusRefV2_57.html#286">s.VERIFY</A></font> in the
 "<A HREF="APlusRefV2_57.html#251">s-Context Parameters (Global Variables)</A>" table
 regarding the message that is issued.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
The following illustrates successful and rejected assignments for objects bound to
 display classes:
<pre></font><font face=Kapl>     $load s
     aû"Spec test"
     `a is `label
     bû"any character vector"   ã </font>A valid label value.<font face=Kapl>
     aûb                        ã </font>Okay.<font face=Kapl>
     bûÉ2 3                     ã </font>An invalid label value.<font face=Kapl>
     aûb                        ã </font>Specification fails.<font face=Kapl>
 û: invalid
*     ý<P></font></pre>
</BLOCKQUOTE><A NAME=HEADING141>
<H2><FONT color="#20B2AA">Bins<A NAME=31><font face=Kapl>  yèx</font></font></H2>
<A NAME=32><b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument is a simple numeric or character array; its items must be in ascending order (no duplicates) for a meaningful result.  (Ascending order has the Grade-up meaning: items compared lexicographically, i.e., leading elements in their ravels compared first, without comparison tolerance, and following elements compared only in the case of ties; and alphabetic characters sorted in accordance with their ASCII codes, which are shown in "<A HREF="APlusRefV2_63.html#10">Graphic Characters for Atomic Vector</A>".)  The right argument, <font face=Kapl>x</font>, is of the same general type as <font face=Kapl>y</font>, and its <font face=Kapl>¢1+ÒÒy</font> trailing axes must have length <font face=Kapl>1ÕÒy</font>.  The result is an array of integers whose shape is defined by the A+ expression <font face=Kapl>(-0Ó(ÒÒy)-1)ÕÒx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The idea is to partition <font face=Kapl>x</font> into cells of the same shape as the items of <font face=Kapl>y</font> and then to find where each cell falls among those items.  Specifically, partition <font face=Kapl>x</font> in the same way as for Find: viz., into cells of rank <font face=Kapl>0Ó(ÒÒy)-1</font>.  For each such cell, the result has one element, whose value is the number of items of <font face=Kapl>y</font> which the cell is greater than, in the sense described in the "Arguments and Result" subsection.<P>
For a numeric vector <font face=Kapl>y</font>, each element of the result indicates the subinterval of <font face=Kapl>y</font> into which the corresponding element of <font face=Kapl>x</font> falls, without using comparison tolerance.  That is, if <font face=Kapl>i#r</font> is an element of the result <font face=Kapl>r</font>, its value can be determined from the "<A HREF="#33">Bins for Numeric Vectors</A>" table.
<A NAME=HEADING142>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Bins for <A NAME=33>Numeric Vectors</B></FONT></caption>
<tr>
<th>Value of <font face=Kapl>i#r</font></th><th>Condition (comparisons without tolerance)</th></tr>
<tr>
<td><font face=Kapl>0</font></td><td><font face=Kapl>(i#x)¤y[0]</font></td></tr>
<tr>
<td><font face=Kapl>j</font>, where<font face=Kapl> 0&lt;j </font>and <font face=Kapl>j&lt;#y</font></td>
<td><font face=Kapl>y[j-1]&lt;i#x </font>and<font face=Kapl> (i#x)¤y[j]</font></td></tr>
<tr>
<td><font face=Kapl>#y</font></td><td><font face=Kapl>y[(#y)-1]&lt;i#x</font></td></tr>
</table>
<P>
One use for Bins is preparing data for a bar graph.
<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if an argument is not simple or if the arguments are not of the same general type;
<LI>a rank error is reported if the rank of <font face=Kapl>x</font> is less than that of the items of <font face=Kapl>y</font>, so the partitioning fails;
<LI>a length error is reported if the items of <font face=Kapl>y</font> and the cells into which <font face=Kapl>x</font> is partitioned have different shapes.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     ¢1 0 1 è 0.3 ¢0.3 ¢2 .1 1 5
 2 1 0 2 2 3

     vû?5000Ò1000     ã </font>sample set of random numbers<font face=Kapl>
ã </font>Put in cells; count how many in each cell, showing distribution of the random numbers:<font face=Kapl>
     +/((100«1+É10)èv)Ê.=É10
 494 480 477 533 506 472 521 512 524 481
ã </font>An equivalent but slightly faster way; shows distribution of the set:<font face=Kapl>
     Ø+/¡(&lt;(100«1+É10)èv)=¡É10
 494 480 477 533 506 472 521 512 524 481</font></pre>
</BLOCKQUOTE><A NAME=HEADING143>
<H2><FONT color="#20B2AA">Bracket <A NAME=38>Indexing<font face=Kapl>  x[a;b;</font>...<font face=Kapl>;c]</font></font></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array, and <font face=Kapl>a</font>, <font face=Kapl>b</font>, ...&nbsp;, <font face=Kapl>c</font> are simple arrays of restricted whole numbers, or absent or the Null.  The number of semicolons must be less than the rank of <font face=Kapl>x</font>, or zero.  Roughly speaking, the shape of the result is the shape of <font face=Kapl>x</font> with the shapes of <font face=Kapl>a</font>, <font face=Kapl>b</font>, ...&nbsp;, <font face=Kapl>c</font> substituted for the corresponding dimensions.<P>
More precisely: If <font face=Kapl>x</font> is a scalar, the form is <font face=Kapl>x[]</font>, and the result is <font face=Kapl>x</font>.  Otherwise, the shape of the result is determined as follows.  Let <font face=Kapl>Ra</font> be <font face=Kapl>Òa</font>, <font face=Kapl>Rb</font> be <font face=Kapl>Òb</font>, etc., except that if the <font face=Kapl>i</font>th one, <font face=Kapl>d</font>, is absent or the Null, let <font face=Kapl>Rd</font> be <font face=Kapl>i#Òx</font>.  If there are <font face=Kapl>k-1</font> semicolons, the shape of the result is <font face=Kapl>Ra,Rb,</font> ... <font face=Kapl>,Rc,kÕÒx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Bracket Indexing is a way of selecting elements from an array.  Semicolons separate indices for different axes.  The result has the shape described above.  For each axis, a corresponding argument can give an array of indices.  For an axis for which no argument or a Null argument is given, the vector <font face=Kapl>0,1,</font> ... <font face=Kapl>,n-1</font> is used, where <font face=Kapl>n</font> is the length of that axis.  Elements are selected by taking one index from each index array.  The order of selection is determined by running through the index arrays in odometer fashion: all of the rightmost for the first combination of the rest, then all of the rightmost for the second combination of the rest, and so on.  Duplicate selections are permitted.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error  (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>rank: the number of unenclosed semicolons within the brackets is equal to or greater than the rank of <font face=Kapl>x</font> and <font face=Kapl>x</font> is nonscalar, or <font face=Kapl>x</font> is a scalar and there is something (anything) between the brackets;
<LI>type: a member of the index group (<font face=Kapl>a</font>, <font face=Kapl>b</font>, ...&nbsp;, or <font face=Kapl>c</font>) is not a simple array of restricted whole numbers;
<LI>maxrank: the rank of the result would be greater than nine;
<LI>index: a number in the index group is negative or not less than the length of the axis it indexes.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     (É2 3 4)[1;2;3]
 23
     'adrv'[2 3Ò0 0 2 3 0 2]
aar
var
     (É5 5 5)[0;É2;É3]
 0 1 2
 5 6 7
     (É5 5 5)[0;2 5Ò0 1;0]
 0 5 0 5 0
 5 0 5 0 5
     (`a `b;5 1 9;&lt;{+})[1]
&lt;  5 1 9
     Ò(É2 3 4)[É0;'';()]
 0 0 4</font></pre>
</BLOCKQUOTE><A NAME=HEADING144>
<H2><FONT color="#20B2AA">Cast<A NAME=44><font face=Kapl>  y©x</font></font></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a scalar symbol and <font face=Kapl>x</font> is any simple character or numeric array or the Null.<br>
The result has the type indicated by <font face=Kapl>y</font>. (Since the Null is already an empty symbol vector, if <font face=Kapl>x</font> is the Null then <font face=Kapl>©`sym©x</font> is <font face=Kapl>`null</font>.)<br>
The shape of the result is:<br>
<font face=Kapl>Òx</font> if <font face=Kapl>x</font> and the result are neither or both symbolic; else<br>
<font face=Kapl>¢1ÕÒx</font> if <font face=Kapl>y</font> is <font face=Kapl>`sym</font>; and otherwise<br>
<font face=Kapl>(Òx),n</font>, where <font face=Kapl>n</font> is the number of characters
 (excluding <font face=Kapl>`</font>) in the representation of the "longest" symbol in
 <font face=Kapl>x</font>.

<!----
 By exception, the shape of<font face=Kapl> `char©() </font>is 0;
 although the Null is an empty symbol vector, Version 2, which doesn't allow conversion
 from symbols, nevertheless permits this expression; Version 4 gave a 0,0 result briefly,
 but changed back to 0 because the NUC from Version 2 was too troublesome.
//---->

<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The value of <font face=Kapl>y</font> is one of the symbols <font face=Kapl>`char `int `float </font>or<font face=Kapl> `sym </font>(but see the last paragraph of the additional error reports section, below).  The result is <font face=Kapl>x</font> with each element converted to the type specified by <font face=Kapl>y</font>.
<p>
Any character, integer, floating-point, or simple symbol array can be converted to any of these four types.<p>
In the case of floating point to integer, the elements of <font face=Kapl>x</font> are rounded.  For integer to character, <font face=Kapl>256|x</font> is used.  The conversion is based, of course, on the character codes used in the implementation, namely ASCII.<P>
Related functions: <A HREF="#185">Pack</A> and <A HREF="#327">Unpack</A> convert between symbol and character.  <A HREF="#130">Format</A> and <A HREF="#78">Default Format</A> convert numbers to characters and employ IEEE rounding; they also convert symbols, and Default Format handles function scalars.  <A HREF="APlusRefV2_6.html#27">Floor</A> and <A HREF="APlusRefV2_6.html#17">Ceiling</A> round in specific directions to whole numbers and may perform type conversions. <A HREF="APlusRefV2_14.html#60">Fix Input</A> and its variants and <A HREF="#105">Execute</A> convert characters to numbers. <a href="APlusRefV2_10.html#9">Bitwise Cast</a> leaves the data part of the variable unchanged but changes the type indicator and (usually) shape.<P>
<A NAME=45></BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and a type error is reported only if a domain error is not:<P>
<UL>
<LI>a domain error is reported if either argument is nested or <font face=Kapl>y</font> is Null or contains more than one element;
<LI>a type error is reported if the arguments specify an impermissible conversion (but see note below) or <font face=Kapl>y</font> is not a symbol, unless the arguments are suitable for the function Or.
</UL>
<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     `char©97     ã </font>Return character.<font face=Kapl>
a
     `int©3.4 4.5 5.6
 3 5 6
     `sym©'abcd'
 `abcd</font></pre>
</BLOCKQUOTE><A NAME=HEADING145>
<H2><FONT color="#20B2AA">Catenate<A NAME=51><font face=Kapl>  y,x</font></font></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The arguments <font face=Kapl>x</font> and <font face=Kapl>y</font> are any arrays of the same general type, conforming in shape as described here:<P>
<UL>
<LI>If <font face=Kapl>x</font> is a scalar then <font face=Kapl>y</font> can be any shape, and the shape of the result is <font face=Kapl>(1+#y),1ÕÒy</font>.  Similarly if <font face=Kapl>y</font> is a scalar.
<LI>If the rank of <font face=Kapl>x</font> is one less than the rank of <font face=Kapl>y</font>, then the shape of <font face=Kapl>x</font> must equal the shape of the items of <font face=Kapl>y</font>, and the shape of the result is <font face=Kapl>(1+#y),Òx</font>.  Similarly if the rank of <font face=Kapl>y</font> is one less than the rank of <font face=Kapl>x</font>.
<LI>If the rank of <font face=Kapl>x</font> is equal to the rank of <font face=Kapl>y</font>, then the items of <font face=Kapl>x</font> and <font face=Kapl>y</font> must have the same shape, and so do the items of the result: <font face=Kapl>1ÕÒx</font> is equal to <font face=Kapl>1ÕÒy</font> and the shape of result is <font face=Kapl>((#x)+#y),1ÕÒx</font>.
</UL>
The result has the same type as:<P>
<UL>
<LI>the floating-point argument, if the other one is integer; else
<LI>the left argument, if neither argument is empty; else
<LI>the nonempty argument, if exactly one argument is empty; else
<LI>the right argument.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> and <font face=Kapl>y</font> are the same rank, the items of <font face=Kapl>y</font> and the items of <font face=Kapl>x</font> are joined in the result.  That is, item <font face=Kapl>i</font> of <font face=Kapl>y</font> equals item <font face=Kapl>i</font> of the result and item <font face=Kapl>j</font> of <font face=Kapl>x</font> equals item <font face=Kapl>j+#y</font> of the result.<P>
If the arguments differ in rank by one, the argument of lower rank is treated as though it had an additional leading axis of length one.  If one argument is a scalar, it is treated as though it had been reshaped to have the shape of the items of the other argument with an additional leading axis of length one.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the arguments are not of the same general type;
<LI>a rank error is reported if neither argument is a scalar and their ranks differ by more than 1;
<LI>a length error is reported if either their ranks are equal and the shapes of their items are not the same or their ranks differ by 1 and the argument of lesser rank is not the same shape as the items of the other.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     (É2 3),(100+É4 3)       ã </font>Same rank.<font face=Kapl>
   0   1   2
   3   4   5
 100 101 102
 103 104 105
 106 107 108
 109 110 111
     'Treasury ','note'      ã </font>Same rank.<font face=Kapl>
'Treasury note'<P>
     (É3),(100+É4 3)         ã </font>Ranks differ by 1.<font face=Kapl>
   0   1   2
 100 101 102
 103 104 105
 106 107 108
 109 110 111<P>
     3,É2 3 4       ã </font>A scalar argument is extended to the size of an item<font face=Kapl>
  3  3  3  3
  3  3  3  3
  3  3  3  3

  0  1  2  3
  4  5  6  7
  8  9 10 11

 12 13 14 15
 16 17 18 19
 20 21 22 23</font></pre>
</BLOCKQUOTE><A NAME=HEADING146>
<H2><FONT color="#20B2AA">Choose<A NAME=56><font face=Kapl>  y#x</font></font></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is either a simple array of restricted whole numbers, or a nested scalar or vector whose elements are enclosed, simple arrays of restricted whole numbers,
or the Null.  <font face=Kapl>x</font> is any array.  If <font face=Kapl>y</font> is nested then <font face=Kapl>Òy</font> is less than or equal to <font face=Kapl>ÒÒx</font>.  The result has the same type as <font face=Kapl>x</font> if <font face=Kapl>x</font> is numeric or character, and otherwise the same general type.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> is scalar, <font face=Kapl>y</font> must be the Null, and the result is <font face=Kapl>x</font>.  Assume <font face=Kapl>x</font> is nonscalar for the rest of the definition.<P>
If <font face=Kapl>y</font> is simple the result is
<pre></font><font face=Kapl>     x[y;;...;]</font></pre>
In particular, if <font face=Kapl>y</font> is Null the result equals <font face=Kapl>x</font>.  If <font face=Kapl>y</font> is not Null the shape of the result is <font face=Kapl>(Òy),1ÕÒx</font>.<P>
If <font face=Kapl>y</font> is nested, the result is
<pre></font><font face=Kapl>     x[0Øy;1Øy;...;(¢1+#y)Øy]</font></pre>
If <font face=Kapl>iØy</font> is Null then it is treated as if it were <font face=Kapl>É(Òx)[i]</font>.  Bracket Indexing treats any omitted trailing axes in a similar fashion, so the result can also be written as
<pre></font><font face=Kapl>     x[0Øy;...;(¢1+#y)Øy;É(Òx)[#y];...;É(Òx)[¢1+ÒÒx]]</font></pre>
If no element of <font face=Kapl>y</font> is Null, the shape of the result is <font face=Kapl>(ØÒ¡y),(Òy)ÕÒx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a rank error is reported if (1) the left argument is nested and of length greater than the rank of the right argument, or (2) the right argument is a scalar and the left argument is other than a simple Null;
<LI>a type error is reported if the left argument (1) is not a simple array or a nested scalar or vector of enclosed, simple arrays, or (2) contains a simple scalar which is not a restricted whole number;
<LI>a maxrank error is reported if the rank of the result would be greater than nine;
<LI>an index error is reported if an element of the left argument is not an appropriate index for the corresponding axis of the right argument, i.e., it is negative or equal to or greater than the length of that axis.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     2 0 # 3 3Ò'abcdefghi'      ã </font>Row 2 and row 0.<font face=Kapl>
ghi
abc
     (0;0 2) # 3 3Ò'abcdefghi'  ã </font>Row 0, columns 0 2.<font face=Kapl>
ac
     (;0) # 3 3Ò'abcdefghi'     ã </font>All rows, column 0.<font face=Kapl>
adg
     (1;0) # É2 3 4             ã </font>Plane 1, row 0, all columns.<font face=Kapl>
 12 13 14 15</font></pre>
</BLOCKQUOTE><A NAME=HEADING147>
<H2><FONT color="#20B2AA">Count<A NAME=61><font face=Kapl>  #x</font></font></H2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is any array.  The result is a scalar integer.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is the number of items of <font face=Kapl>x</font>.  If <font face=Kapl>x</font> is a scalar the result is 1, while if <font face=Kapl>x</font> is a nonscalar the result is the length of the leading axis, i.e., <font face=Kapl>(Òx)[0]</font> (see "<A HREF="#288">Shape</A>").<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     #É5000
 5000
     #168 3 4Ò0
 168
     #,12
 1
     #12
 1</font></pre>
</BLOCKQUOTE><A NAME=HEADING148>
<H2><FONT color="#20B2AA">Deal<A NAME=66><font face=Kapl>  y?x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
Both <font face=Kapl>x</font> and <font face=Kapl>y</font> are simple one-element numeric arrays of nonnegative restricted whole numbers, with <font face=Kapl>y¤x</font>.  The result is a vector of integers of length <font face=Kapl>y</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
The value of the <A HREF="APlusRefV2_13.html#64">Random Link</A> system variable, <font face=Kapl>`rl</font>, which is changed each time a random integer is chosen.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is a vector of integers of length <font face=Kapl>y</font>, chosen at random from <font face=Kapl>Éx</font> without duplication, or, in mathematical terms, without replacement.  The result is dependent upon the random link, <font face=Kapl>`rl</font>, which is set when the system command <font face=Kapl>$rl</font> is executed and each time a random integer is chosen.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and a domain error report is issued only if a type error report is not:<P>
<UL>
<LI>a type error is reported if an argument is nested or has an element that is not a restricted whole number;
<LI>a domain error is reported if either argument has a negative element or has more than one element, or if the left argument exceeds the right argument.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     10?10
 3 1 5 4 2 0 8 6 9 7
     10?10
 7 6 3 8 9 2 4 5 0 1</font></pre>
</BLOCKQUOTE><A NAME=HEADING149>
<H2><FONT color="#20B2AA">Decode<A NAME=71><font face=Kapl> yÂx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a simple numeric scalar or vector, and <font face=Kapl>x</font> is any simple numeric array.  If <font face=Kapl>y</font> has more than one element, then <font face=Kapl>#y</font> must equal <font face=Kapl>#x</font>.  The result is a simple numeric array whose shape equals <font face=Kapl>1ÕÒx</font> and whose type is integer if the arguments are of type integer and every element of the result can be faithfully represented that way and otherwise floating point.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> and <font face=Kapl>y</font> are vectors with the same number of elements, the result is the evaluation of <font face=Kapl>x</font> in the number base system with radices <font face=Kapl>y[0]</font>,<font face=Kapl>y[1]</font>, ...&nbsp;, <font face=Kapl>y[¢1+#y]</font>.  If <font face=Kapl>y</font> has one element it is treated as if it were <font face=Kapl>(#x)Òy</font>.  If <font face=Kapl>x</font> is a matrix, each element <font face=Kapl>i#r</font> of the result <font face=Kapl>r</font> is the evaluation of the column <font face=Kapl>x[;i]</font> in the number base system represented by <font face=Kapl>y</font>.  More generally, if <font face=Kapl>x</font> has rank greater than 2, each element of the result is the evaluation of the corresponding vector along the first axis of <font face=Kapl>x</font>, in the number system represented by <font face=Kapl>y</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if either argument is not a simple numeric array;
<LI>a rank error is reported if the left argument is not a scalar or vector;
<LI>a length error is reported if <font face=Kapl>#y</font> is not equal to either 1 or <font face=Kapl>#x</font>.
</UL>
</BLOCKQUOTE>
<A NAME=72><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     ã </font>Convert 2 hours, 5 minutes, and 59 seconds to seconds.<font face=Kapl>
     24 60 60Â2 5 59
 7559
     ã </font>Present value (price) from interest rate and cash flows.<font face=Kapl>
     cfû0 100 100 100 100 1000
     7.2î pv û (ß1+i) Â ÷cf Ý iû.05
1138.12
     ã </font>Present value at various interest rates.<font face=Kapl>
     8.2î pv û (ß1.03+.01«É5) Â@0 1 ÷cf
 1234.32 1184.92 1138.12 1093.77 1051.71</font></pre>
</BLOCKQUOTE><A NAME=HEADING150>
<H2><FONT color="#20B2AA">Default <A NAME=78>Format<font face=Kapl>  îx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a simple numeric or a simple character array, a simple symbol scalar, a function scalar, or a simple symbol array.
 The result is a simple character array of rank less than or equal to 2.
<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
For numeric <font face=Kapl>x</font>, the value of <A HREF="APlusRefV2_13.html#56">Printing Precision</A>, <font face=Kapl>`pp</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> is numeric or character, the result is an array containing <font face=Kapl>x</font> in
 default format.  That is, if the expression <font face=Kapl>x</font> is entered in an A+ session, a
 display of the value of <font face=Kapl>x</font> appears; this primitive function captures that display
 in its result.  In particular, if <font face=Kapl>x</font> is a character array of rank less than or
 equal to 2, the result equals <font face=Kapl>x</font>.  If <font face=Kapl>x</font> is numeric, the number of digits
 shown and the format (fixed or exponential) used are dependent on the printing precision system variable <font face=Kapl>`pp</font>.
 A nonscalar symbol array displays the symbols as described in the next paragraph,
 and for arrays of rank 2 or greater, are padded with blanks on the right
 to match the length of the longest (unpadded) symbol involved.
<P>
If x is a scalar symbol, the result is a character vector, giving the
 display of that symbol, with a blank preceding the backquote.
<P>
When <font face=Kapl>x</font> is a function scalar, the result is a character vector.  If <font face=Kapl>x</font> is primitive, the result is its symbol.  If <font face=Kapl>x</font> is a defined function, the result is its definition.  If the definition has more than one line, the lines are separated by newlines in the result.  If the function is derived (e.g., <font face=Kapl>É¡</font>), then the result is the string <font face=Kapl>*derived*</font>.  (Note that Default Format shows that expressions such as <font face=Kapl>+.«</font> are not derived functions strictly speaking.)<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
If there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"),<P>
<UL>
<li>a rank error is reported if the argument is enclosed (nested or function scalar) and
is not a scalar; and otherwise
<LI>a type error is reported if the argument is not a simple character or numeric array, a simple symbol scalar, or a function scalar.
</UL>
</BLOCKQUOTE><A NAME=79><b>&nbsp;&nbsp;&nbsp;Examples</b>
<pre></font><font face=Kapl>     _gsv `pp
 10
     ã </font>The Printing Precision is now 10. Digits after an <font face=Kapl>e</font> don't count. If there would<font face=Kapl>
     ã </font>be too many digits in ordinary notation, e-notation is used in a display.<font face=Kapl>
     '(',(îÏ1),')',î12345.678912e24 1234567891 12345678912
( 3.141592654) 1.234567891e+28 1234567891 1.234567891e+10
     ã </font>A function definition, to be shown by Default Format.<font face=Kapl>
     cube x:x*3
     'cube fn ý ',î&lt;{cube}
cube fn ý cube x:x*3
     ã </font>Indentation of first line of definition is always ignored by Default Format.</pre>
<A NAME=HEADING151>
<H2><FONT color="#20B2AA">Depth<A NAME=83><font face=Kapl>  ½x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is any array; if it is a function expression it must be in braces.  The result is a scalar integer.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is the maximum depth of nesting in the argument.  All simple arrays (and so all empty arrays) are depth 0, except for function expressions, whose depth is -1.  (The Enclose of a function expression, which is called a function scalar, is simple and depth 0.)  The depth of a nested scalar is 1 plus the depth of the disclosed scalar (see Disclose, below).  The depth of a nonscalar nested array is the greatest of the depths of its elements.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     ½'abc'
 0
     ½{+}           ã </font>The parser needs the braces as a hint<font face=Kapl>
 ¢1                 ã </font>when two functions are juxtaposed.<font face=Kapl>
     ½(2;3;&lt;(4;5))  ã </font>Three enclosings: strand, Enclose, strand.<font face=Kapl>
 3</font></pre>
</BLOCKQUOTE><A NAME=HEADING152>
<H2><FONT color="#20B2AA">Disclose<A NAME=88><font face=Kapl>  &gt;x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is a simple array, a nested scalar, or a uniform nested array (see Definition, Case 3, for the meaning of uniform).  Letting <font face=Kapl>s</font> and <font face=Kapl>t</font> be the shape and type of the first element of <font face=Kapl>x</font> with that element's top level of nesting (if any) removed, the shape of the result is <font face=Kapl>(Òx),s</font> and its type is floating point if some element of <font face=Kapl>x</font> is a nonempty floating-point array after its top level of nesting (if any) is removed, else its type is <font face=Kapl>t</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<b>Case 1.  Simple Array </b><font face=Kapl>x</font><P>
If <font face=Kapl>x</font> is a simple array, perhaps a simple scalar, then the result is <font face=Kapl>x</font>.
 Note that function scalars are simple arrays; to turn a function scalar<font face=Kapl> fnsc </font>into
 the corresponding function you can use <font face=Kapl>fnsc¡</font> or<font face=Kapl> %_name{fnsc}</font>.<P>
<b>Case 2.  Nested Scalar </b><font face=Kapl>x</font><P>
If <font face=Kapl>x</font> is a nested scalar, then its depth is at least one.  The result is <font face=Kapl>x</font> with the top level of nesting removed, and it may or may not be a scalar.<P>
<b>Case 3.  Nested Vector </b><font face=Kapl>x</font><P>
The elements of <font face=Kapl>x</font> must all be nested - i.e., each element of <font face=Kapl>x</font> must have a depth of at least one (remember that function scalars have depth zero) -, and the Discloses of all these elements must have the same shape and the same general type.  Arrays with this property are called <i>uniform</i> in this definition.<P>
Disclose of a nested vector <font face=Kapl>x</font> is defined in terms of Disclose of a nested scalar, as follows.  The array <font face=Kapl>&gt;x</font> has depth one less than the depth of <font face=Kapl>x</font>.  The number of items of <font face=Kapl>&gt;x</font> equals the number of elements of <font face=Kapl>x</font>, i.e., <font face=Kapl>#x</font>.  For each index <font face=Kapl>i</font> of <font face=Kapl>x</font>, the <font face=Kapl>i</font>th item of <font face=Kapl>&gt;x</font> equals the Disclose of the nested scalar <font face=Kapl>i#x</font>, i.e., <font face=Kapl>&gt;i#x</font>.<P>
<b>Case 4.  Nested Array </b><font face=Kapl>x</font><P>
Disclose of a nested array <font face=Kapl>x</font> is defined in terms of Disclose of a nested vector, as follows.  As in the vector case, <font face=Kapl>x</font> must be uniform.  Let <font face=Kapl>s</font> denote the common shape of all the Discloses of the scalar elements of <font face=Kapl>x</font>.  Then <font face=Kapl>&gt;x</font> is <font face=Kapl>((Òx),s)Ò&gt;,x</font>.  That is, ravel <font face=Kapl>x</font>, apply Disclose to this vector, and reshape the disclosed vector to have <font face=Kapl>x</font>'s shape for its leading axes and the shape of a disclosed element for its trailing axes.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a maxrank error is reported if the result would have more than nine dimensions;
<LI>a domain error is reported if <font face=Kapl>x</font> contains both nested and nonnested elements other than symbols and function scalars;
<LI>a rank error is reported if the Discloses of the elements of <font face=Kapl>x</font> have different ranks;
<LI>a mismatch error is reported if the Discloses of the elements of <font face=Kapl>x</font> have different shapes;
<LI>a type error is reported if the Discloses of the elements of <font face=Kapl>x</font> have different general types.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     &gt;(É3;10«É3)
 0  1  2
 0 10 20</font></pre>
</BLOCKQUOTE><A NAME=HEADING153>
<H2><FONT color="#20B2AA">Drop<A NAME=92><font face=Kapl>  yÕx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument </b><font face=Kapl>y</font> is a simple one-element array whose value is a restricted whole number, and <font face=Kapl>x</font> is any array.  The shape of the result equals the shape of the right argument <font face=Kapl>x</font> along all but the first axis, while the length of the first axis is the larger of <font face=Kapl>#x</font> minus the absolute value of <font face=Kapl>y</font> and <font face=Kapl>0</font>, i.e., <font face=Kapl>0Ó(#x)-|y</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is <font face=Kapl>x</font> without its first <font face=Kapl>y</font> items if <font face=Kapl>y</font> is nonnegative, or its last <font face=Kapl>-y</font> items if <font face=Kapl>y</font> is negative.  If <font face=Kapl>|y</font> is greater than <font face=Kapl>#x</font> then the number of items in the result is 0.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and nonce only if there is no type error:<P>
<UL>
<LI>a type error is reported if the left argument is not simple or has an element that is not a restricted whole number;
<LI>a nonce error is reported if the left argument has more than one element.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     3ÕÉ5 2
 6 7
 8 9
 ¢4Õ'15 January'
15 Jan</font></pre>
</BLOCKQUOTE><A NAME=HEADING154>
<H2><FONT color="#20B2AA">Enclose<A NAME=97><font face=Kapl>  &lt;x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is any array; if it is a function expression, it must be enclosed in braces, to aid the parser.  The result is a nested scalar unless the argument is a function expression, in which case it is a simple scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is a scalar that contains the argument </b><font face=Kapl>x</font>.  The depth of the result is the depth of the argument plus one. If <font face=Kapl>f</font> is a function expression, <font face=Kapl>&lt;{f}</font> is a function scalar.  Note that strand notation is equivalent to the concatenation of the Enclose of each of its components.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     2Ò&lt;É3
&lt;  0 1 2
&lt;  0 1 2
          ã </font>Functional notation required for + .<font face=Kapl>
     (½`sym),½{+},(½'abc'),(½2 3 4),(½5.5),½()
 0 ¢1 0 0 0 0
          ã </font>Strand encloses each element.<font face=Kapl>
     ½@0(`sym;+;'abc';2 3 4;5.5;)
 1 0 1 1 1 1
          ã </font>Depths increased by Enclose.<font face=Kapl>
     ½@0(&lt;`sym;&lt;{+};&lt;'abc';&lt;2 3 4;&lt;5.5;&lt;())
 2 1 2 2 2 2</font></pre>
</BLOCKQUOTE><A NAME=HEADING155>
<H2><FONT color="#20B2AA">Encode<A NAME=102><font face=Kapl>  yÎx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a simple numeric vector or scalar and <font face=Kapl>x</font> is any simple numeric array.  The result has shape <font face=Kapl>(Òy),Òx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
For positive elements of <font face=Kapl>x</font>, the result is the representation of that element, as far as is possible, in the number base system with radices <font face=Kapl>y[0]</font>,<font face=Kapl>y[1]</font>, ...&nbsp;,<font face=Kapl>y[¢1+#y]</font>.  That is, <font face=Kapl>yÎx</font> contains the <font face=Kapl>#y</font> low-order "digits" of its representation in this number base for each positive element of <font face=Kapl>x</font>.  For a negative element <font face=Kapl>n</font>, the result is the representation, in the same way, of <font face=Kapl>(«/y)|n</font>.  No matter what the signs of the elements of <font face=Kapl>x</font> are, <font face=Kapl>yÂyÎx</font> equals <font face=Kapl>(«/y)|x</font>.  Thus <A HREF="#71">Decode</A> is the left inverse of Encode for any element <font face=Kapl>p</font> for which <font face=Kapl>(«/y)|p</font> is equal to <font face=Kapl>p</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and a rank error report is issued only if a type error report is not:<P>
<UL>
<LI>a type error is reported if either argument is not a simple numeric array;
<LI>a rank error is reported if the left argument is not a vector or scalar.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     24 60 60 Î 7559
 2 5 59
     100 Î 12345
 45</pre>
</BLOCKQUOTE><A NAME=HEADING156>
<H2><FONT color="#20B2AA">Execute<A NAME=105><font face=Kapl>  âx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a character vector or scalar.  The result is the explicit result of the A+ expression in <font face=Kapl>x</font>, except that  it is the Null when the last function executed in <font face=Kapl>x</font> is a Specification (ordinary or selective), and when the argument is a system command or a definition of a function, operator, or dependency.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A NAME=106>This function evaluates <font face=Kapl>x</font> as an A+ expression.  It cannot be used to establish the target of an Assignment.  See also "<A HREF="#111">Execute in Context or Protected Execute</A>", "<A HREF="#331">Value</A>", and "<A HREF="#339">Value in Context</A>".  It can be used to execute a system command.
 It can be traced by <font face=Kapl>$dbg xeq</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the argument is not simple or is not of character type;
<LI>a rank error is reported if the rank of the argument exceeds 1;
<LI>any error from the execution of the argument is reported (and execution is suspended);
 entering <font face=Kapl>ý</font> produces a domain error for Execute and a second
 suspension. See example.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     100«â'1 1.23 4.567'
 100 123 456.7
     â'aû14 23 34'
          ã </font>Result is Null.<font face=Kapl> (â'a')û14 23 34 </font>not allowed.<font face=Kapl>
     a
 14 23 34
     â"(É10)Ò0"
ã[error] Ò: maxrank
*     ý
ã[error] â: domain</font></pre>
</BLOCKQUOTE><A NAME=HEADING157>
<H2><FONT color="#20B2AA">Execute <A NAME=111>in Context or Protected Execute<font face=Kapl>  yâx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a symbol or an integer or Null and <font face=Kapl>x</font> is
 a character vector or scalar.  The result is the explicit result of the A+ expression in
 <font face=Kapl>x</font> under circumstances controlled by <font face=Kapl>y</font>,
 except that it is null when the last function executed is any Specification, and when
 <font face=Kapl>x</font> is a system command or a definition of a function, operator, or
 dependency.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>y</font> is a symbol, then this function is <b>Execute in Context</b>
 and evaluates
 <font face=Kapl>x</font> as an A+ expression in the context <font face=Kapl>y</font>. If
 <font face=Kapl>c</font> is the context when the function is invoked, it is equivalent to
 <font face=Kapl>{_cx y;âx;_cx c}</font>, except that the explicit result is that of
 <font face=Kapl>âx</font> rather than<font face=Kapl> _cx c</font>. Note: an unqualified
 name <font face=Kapl>z</font> in <font face=Kapl>x</font> remains unqualified; it is not
 treated as a qualified name; <font face=Kapl>x</font> is just executed in the context
 <font face=Kapl>y</font>. In particular, the name of a local variable<font face=Kapl> z
 </font>in<font face=Kapl> x </font>remains unqualified. See "<A HREF="#105">Execute</A>",
 "<A HREF="#331">Value</A>", and "<A HREF="#339">Value in Context</A>".<P>
<A NAME=114>Execute in Context is useful when one wants to create multiple instances of a
 dependency or dependencies, distinguished by contexts.  You can create a dependency by,
 for instance,
<pre></font><font face=Kapl>     `cxtâ'a:b+c'</font></pre>
and if you have a list <font face=Kapl>c</font> of contexts, then, for example,
<pre></font><font face=Kapl>     câ¡&lt;'a:b+c'</font></pre>
creates a whole set of dependencies in different contexts.<P>
If the left argument is an integer or Null, the function is <b>Protected Execute</b>, in the
 current context (cf. "<A HREF="APlusRefV2_12.html#7">Do - Monadic (Protected
 Execution)</A>"). If the execution fails, the result is the error code, as listed in the
 table "<A HREF="APlusRefV2_12.html#13">Error codes for Protected Execution</A>", as a
 simple integer. There is no suspension - i.e., execution proceeds as if no error has
 occurred. (Actually, there are a <i>few</i> cases, such as an attempt to give a bound
 variable an impermissible value, that do result in a suspension, with a<font face=Kapl>
 stop </font>error message.)<p>
If the execution is successful, the result is Enclose applied to the result of Execute for
 <font face=Kapl>x</font>, viz., <font face=Kapl>&lt;âx</font>. Enclose is used to enable
 you to distinguish between the two cases.<p>
If the <A HREF="APlusRefV2_13.html#60">Protected Execute Flag</A>,
 <font face=Kapl>`Gf</font>, is 0, however, a suspension will occur if Protected Execute
 encounters an error in its right argument; entering <font face=Kapl>ý</font> clears the
 suspension and produces the error code as the result. (This behavior is different from
 that of an ordinary Execute:  clearing a suspension in the execution of its argument causes
 a second suspension, on the Execute itself, and clearing that yields a null result.) See
 <A HREF="APlusRefV2_13.html#60"><font face=Kapl>`Gf</font></A> and
 <A HREF="APlusRefV2_15.html#120"><font face=Kapl>$Gf</font></A>.
 It can be traced by <font face=Kapl>$dbg xeq</font>.<P>
<A NAME=115>Messages that are not strictly A+ error messages will still appear in the log,
 e.g.<BR><font face=Kapl>filename: No such file or directory<BR>not an `a
 object<BR></font>and many Adap messages.<P>
The treatment of input errors while stopped in protected execution is described under
 <A HREF="APlusRefV2_12.html#7">monadic do</A>.<P>
<a name=116>
<b><font color=#FF0000>Warning!</font></b>&nbsp; Within a Protected Execute - as in a
 protected do - Result exits from Protected Execute only, with a 0 return code
 and the Result argument as result;&nbsp; it does not exit from the function containing the
 Protected Execute.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the left argument is not a simple symbol or integer or Null, or if the right argument is not a simple character array;
<LI>a rank error is reported if the rank of the right argument exceeds one;
<LI>if the left argument is a symbol or if the protected execute flag, <font face=Kapl>`Gf</font>, is zero, any error from the execution of the argument is reported (and execution is suspended).
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     try.xûÉ3
     â'xß10'       ã try.x</font> has a value, but <font face=Kapl>x</font> does not.<font face=Kapl>
 .x: value
*      ý
 â: domain         ã </font>Error gets passed on to Execute.<font face=Kapl>
*      ý
     0â'xß10'      ã </font>Protected execute (<font face=Kapl>`Gf</font> is 1).<font face=Kapl>
 4                 ã </font>Numeric code for the value error.<font face=Kapl>
     `tryâ'xß10'   ã </font>Execute in Context okay; uses <font face=Kapl>try.x</font>.<font face=Kapl>
 0 0.1 0.2
                   ã </font>Protected execute using the var that has a value:<font face=Kapl>
     0â'try.xß10'
&lt;  0 0.1 0.2       ã </font>Success shown by an enclosed result.</pre>
</BLOCKQUOTE><A NAME=HEADING158>
<H2><FONT color="#20B2AA">Expand<A NAME=119><font face=Kapl>  y\x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
</b><font face=Kapl>y</font> is a simple scalar or vector of restricted whole numbers whose elements are all 0 or 1, and <font face=Kapl>x</font> is any array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The number of ones in <font face=Kapl>y</font> equals the number of items in <font face=Kapl>x</font>, i.e., <font face=Kapl>+/y</font> equals <font face=Kapl>#x</font>, or <font face=Kapl>x</font> is a scalar.  If the <font face=Kapl>i</font>th item of <font face=Kapl>y</font> is 1, then the <font face=Kapl>i</font>th item of the result is the <font face=Kapl>(+/(i+1)Ùy)</font>th item of <font face=Kapl>x</font>, or <font face=Kapl>x</font> if it is a scalar.  If the <font face=Kapl>i</font>th item of <font face=Kapl>y</font> is 0, then the <font face=Kapl>i</font>th item of the result is composed entirely of fill scalars.  The table "<A HREF="#310">Fill Elements</A>" shows the fill scalars.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if none of the reports preceding it on this list applies and there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") - except that token precedes value:<P>
<UL>
<LI>a token error (like a parse error) is reported if there is a primitive function or operator symbol to the immediate left of <font face=Kapl>\</font> that is not one of <font face=Kapl>+«ÓÄ^©</font>;
</UL>
and, unless there is one of <font face=Kapl>+«ÓÄ^©</font> to the immediate left of <font face=Kapl>\</font> (that is, unless you are thrown into Scan, a monadic operator):<P>
<UL>
<LI>a valence error is reported if there is no argument to the immediate left of <font face=Kapl>\</font>;
<LI>a type error is reported if the left argument is nested or does not consist of restricted whole numbers;
<LI>a domain error is reported if any element of the left argument is not 0 or 1;
<LI>a rank error is reported if the left argument is not a scalar or vector;
<LI>a length error is reported if the number of ones in the left argument is unequal to the number of items in the right argument, unless the right argument is a one-element array.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     1 0 1 1\É3 4
  0  1  2  3
  0  0  0  0
  4  5  6  7
  8  9 10 11
     1 0 1\'a'
a a</pre>
</BLOCKQUOTE><A NAME=HEADING159>
<H2><FONT color="#20B2AA">Find <A NAME=125><font face=Kapl>  yÉx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The arguments are any arrays (including scalars) of the same general type. The rank of the items of <font face=Kapl>y</font> must not exceed the rank of <font face=Kapl>x</font>, and the <font face=Kapl>¢1+ÒÒy</font> trailing axes of <font face=Kapl>x</font> must have length <font face=Kapl>1ÕÒy</font>.  The result is an array of integers whose shape is defined by the A+ expression <font face=Kapl>(-0Ó(ÒÒy)-1)ÕÒx</font> - i.e., the shape of <font face=Kapl>x</font> with the last <font face=Kapl>s</font> dimensions omitted, where <font face=Kapl>s</font> is the rank of the items of <font face=Kapl>y</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison tolerance, if an argument is in floating point.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Partition <font face=Kapl>x</font> into cells of rank <font face=Kapl>0Ó(ÒÒy)-1</font>.  The result has one element for each such cell.  The value of that element is the index of the first item of <font face=Kapl>y</font> to which the cell is identical - in the sense of Match, i.e., at all levels the cell and the item are the same shape and type (except that integer and floating point match here) and all their simple scalar components, at whatever level, are tolerably equal.  If the cell is not found among the items of <font face=Kapl>y</font>, the resulting element is <font face=Kapl>#y</font>.  A scalar <font face=Kapl>y</font> is treated as a one-element vector.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the arguments are not of the same general type;
<LI>a rank error is reported if the rank of <font face=Kapl>x</font> is less than that of the items of <font face=Kapl>y</font>, so the partitioning fails;
<LI>a length error is reported if the items of <font face=Kapl>y</font> and the cells into which <font face=Kapl>x</font> is partitioned have different shapes.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     (4 3Ò'fatbatcathat')É(2 3Ò'catpat')
 2 4
     (+;-;«;ß)É&lt;{«}
 2   ã </font>Strand makes function expression a function scalar.</pre>
</BLOCKQUOTE><A NAME=HEADING160>
<H2><FONT color="#20B2AA">Format<A NAME=130><font face=Kapl>  yîx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a simple numeric scalar or vector, and <font face=Kapl>x</font> is a simple numeric or symbol array.  If <font face=Kapl>#y</font> is greater than 1 then it must equal <font face=Kapl>¢1ÙÒx</font> - i.e., <font face=Kapl>#x</font> if <font face=Kapl>x</font> is a vector, and the number of columns if the rank of <font face=Kapl>x</font> is greater than 1.  The result is a simple character array of rank less than or equal to 2.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is an array containing <font face=Kapl>x</font> in formatted form, with the format controlled by <font face=Kapl>y</font>.  Negative numbers are formatted with an ordinary minus sign (<font face=Kapl>-</font>).  Elements of <font face=Kapl>y</font> specify the appearance of certain elements in <font face=Kapl>x</font>:<P>
<UL>
<LI>if <font face=Kapl>#y</font> equals 1, then the element of <font face=Kapl>y</font> applies to all elements of <font face=Kapl>x</font>;<P>
<LI>if <font face=Kapl>#y</font> is greater than 1, then element <font face=Kapl>i#y</font> applies to element <font face=Kapl>i#x</font> if <font face=Kapl>x</font> is a vector, to column <font face=Kapl>x[;i]</font> if <font face=Kapl>x</font> is a matrix, and to columns <font face=Kapl>x[...;i]</font> otherwise.
</UL>
The format of every element of <font face=Kapl>x</font> is controlled by an element of <font face=Kapl>y</font>, which is of the form <b>[</b><font face=Kapl>-</font><b>]</b><i>width</i><b>[</b><font face=Kapl>.</font><i>digits</i><b>]</b>, where the <i>digits</i> specification is expected to be a <i>single</i> digit and <i>any digits following it are ignored</i>.  The total number of characters in the format is <i>width</i>.  If <i>digits</i> is present, it specifies the number of digits to appear to the right of the decimal point; if it is 0 or absent, the element is shown as an integer.  If the minus sign is present, the format is in exponential format (e-notation).
<p>
<! ==================================================================================>
<A NAME=133></blockquote><b>&nbsp;&nbsp;&nbsp;Understanding how rounding works</b><blockquote>
<p>
Because Format is often used as a means of rounding numbers to some desired precision
 &#151;and because that rounding often creates questions
 about the accuracy of the rounding&#151;
 this seems to be a good place to discuss how rounding works,
 and why it is that we sometimes see some unexpected results.
<p>
There is nothing within A+ that imposes any special rules on the rounding of numbers.
 Rounding is done entirely using IEEE symmetric rounding rules.
 That is, if a number lies halfway between two other numbers to which it can legitimately be
 <i>equally</i> rounded either way,
 it is rounded to the one ending in an <i>even</i> digit.
 Therefore, a value of 22.5, for instance, could logically be rounded to either 22 or 23;
 the IEEE rules tell us that it should be rounded to 22, because that is the number which
 ends with an <i>even</i> digit.
 As further examples,
 if we are starting with values which are exactly halfway between two integers,
 and rounding them to integers:
<ul compact>
<li>0.5 should round <i>down</i> to an integer value of 0
 (not to 1, because 1 is an odd number);
<li>1.5 should round <i>up</i> to an even integer value of 2;
<li>2.5 should round <i>down</i> to an even integer value of 2;
<li>3.5 should round <i>up</i> to an even integer value of 4; and
<li>4.5 should round <i>down</i> to an even integer value of 4.
</ul>
<p>
In A+ terms, this would be shown as follows:
<font face=Kapl><pre></font>
     4î.5 1.5 2.5 3.5 4.5    ã </font></font>This example shows IEEE rounding.<font face=Kapl>
   0   2   2   4   4</pre></font>
<p>
In actual practice, however, machine approximation of decimal numbers and machine rounding may obscure the regular IEEE rules.
<p>
For example, given the following vector:
<font face=Kapl><pre></font>
     vû1.055 1.155 1.255 1.355 1.455 1.555 1.655 1.755 1.855 1.955
</pre>
</font>
IEEE rules dictate that rounding it to two decimal positions <i>should</i> cause the
 "n.n55" values to round to "n.n6"
 (and if we had "n.n45" values, they should round to "n.n4").
 However, that's not necessarily what happens.
 Let's explore what happens, and why.
<! ----------------------------------------------------------------------->
<table border=1 bgcolor='#ffffdd'>
<tr align=center><th bgcolor='#ffffcbb'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Original&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
Value<th bgcolor='#ffffbb'>IEEE<br>
&nbsp;&nbsp;&nbsp;&nbsp;Rounding&nbsp;&nbsp;&nbsp;&nbsp;<th bgcolor='#ffffbb'><font face=Kapl>6.2îv</font><br>
&nbsp;&nbsp;&nbsp;&nbsp;Rounding&nbsp;&nbsp;&nbsp;&nbsp;<th bgcolor='#ffffbb'>Actual Internal<br>
Value</tr>
</b>
<p>
<tr></tr>
<tr align=center><td>1.055<td>1.06<td>1.05<td>&nbsp;&nbsp;&nbsp;&nbsp;1.05499999999999994...&nbsp;&nbsp;&nbsp;&nbsp;</tr>
<tr align=center><td>1.155<td>1.16<td>1.16<td>1.15500000000000003...</tr>
<tr align=center><td>1.255<td>1.26<td>1.25<td>1.25499999999999989...</tr>
<tr align=center><td>1.355<td>1.36<td>1.35<td>1.35499999999999998...</tr>
<tr align=center><td>1.455<td>1.46<td>1.46<td>1.45500000000000007...</tr>
<tr align=center><td>1.555<td>1.56<td>1.55<td>1.55499999999999994...</tr>
<tr align=center><td>1.655<td>1.66<td>1.66<td>1.65500000000000003...</tr>
<tr align=center><td>1.755<td>1.76<td>1.75<td>1.75499999999999989...</tr>
<tr align=center><td>1.855<td>1.86<td>1.85<td>1.85499999999999998...</tr>
<tr align=center><td>1.955<td>1.96<td>1.96<td>1.95500000000000007...</tr>
</table>
<! ----------------------------------------------------------------------->
<p>
Notice that using <font face=Kapl>6.2îv</font> will round
 the values in <font face=Kapl>v</font> to two decimal places...
 but it doesn't necessarily give us what we expect from the IEEE rounding rules.
 Some of the results look okay, but realize that the internal values are imprecise for
 <i>all</i> of our values,
 and some of them just happen to round the way that we want them to.)
<p>
The reason for this is that we are doing decimal operations on a hexadecimal machine,
 so there will always be some errors in the internal representation of many of the numbers
 that we deal with every day. It is simply not possible to represent these values
 <i>exactly</i> on a digital machine.
<p>
In the same way that we simply cannot represent exactly one-third
 as a decimal number, we also cannot represent many other decimal numbers in hexadecimal
 and be able to convert them back to <i>exactly</i> the number that we started with.
 Therefore, a value of "1.055" actually gets represented within the machine
 as "1.05499999999999994...", so that value is <i>correctly rounded down</i> to "1.05",
 while a value of "1.155" is actually seen by the machine as "1.15500000000000003...",
 so that value is <i>correctly rounded up</i> to "1.16".
 Although the first value is rounded to "1.05" instead of the desired IEEE rounding value
 of "1.06", realize that the rounding is correct based upon the internal value
 that is seen by the hardware.
 These internal values are incorrect, but they are as close an approximation of
 the exact values as we can get on this hardware.
<p>
So why don't we see this imprecision at every step of our calculations? ...Simply because
 the printing precision normally masks this error, and over the course of normal work,
 these errors tend to cancel out.
<p>
Before you get <i>too</i> concerned about this imprecision, realize that the
 Comparison Tolerance in A+
 (the amount by which two values may differ and still be considered to be equal)
 is set to 1e-13 (or 0.0000000000001);
 that is a tolerance of one part
 (of error) in ten trillion. To put this into perspective, if our measurements
 were to represent distance, a measurement of 250,000 miles (approximately the
 distance from the earth to the moon) could be carried out within an error
 of no more than one-third of the thickness of a piece of copier paper.
 For most operations, this is deemed to be "close enough."
<p>
Also realize that rounding of values through the use of the Format function
 is typically done just for display of final output
 (where 16 digits of precision would be inappropriate anyway).
 Calculations prior to that final rounding step are done at full precision.
<p>
Finally, we just want to emphasize again that none of the rounding that you see
 through A+ is any different than it would be in other environments.
 A point that may make it <i>seem</i> different is the ease with which you can
 adjust the precision and look at alternate views of the same values.
 This is a general hardware numeric conversion issue, not an A+ issue.
<! ==================================================================================>
<p>
</blockquote><b>&nbsp;&nbsp;&nbsp;Creating the left argument to Format:</b><blockquote>
<P>
When a number has been formatted in the specified form the result is fitted in the specified width in one of two ways:
<P>
<UL>
<LI>exponential format:
 the result for a positive number is padded on the left
 with two blanks and for a negative with one,
 and this padded result is left justified within the width,
 after being truncated on the right if it is too long;<P>
<LI>otherwise:
 the result is right justified within the width,
 after being truncated on the right if it is too long.
</UL>
Because these rules effectively handle inconsistent left arguments like <font face=Kapl>6.6</font>, no error message is given for them.  It is up to you to see that the widths you specify are sufficient, allowing for the padding in exponential format and for any blanks you want between adjacent numbers not in exponential format.<P>
If the right argument consists of symbols, they are formatted in their displayed form with  backquotes removed.
 Each of them is right justified in the specified
 width, after being truncated if it is too long. Any <i>digits</i> or exponential-format
 specification is ignored.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and a length error is reported only if a type error is not:<P>
<UL>
<LI>a type error is reported if the left argument is not simple and numeric, or if the right argument is not simple and either numeric or symbol;
<LI>a length error is reported if the number of elements in the left argument is neither 1 nor equal to <font face=Kapl>¢1ÙÒx</font>.
</UL>
<A NAME=134><b>&nbsp;&nbsp;&nbsp;Examples</b><P>
<pre></font><font face=Kapl>     2 10.4 ¢12.2î2 3Ò1 ¢3.14159 123456 2 123.7 ¢55
 1   -3.1416  1.23e+05
 2  123.7000 -5.50e+01

     4î.5 1.5 2.5 3.5 4.5   ã </font>This example shows IEEE rounding.<font face=Kapl>
   0   2   2   4   4

     16.12î1.123456789012   ã 16.12</font> on the left is equivalent to<font face=Kapl>
             1.1            ã 16.1</font>: the <font face=Kapl>2</font> is ignored.<font face=Kapl>

     _gsv `pp
 10                         ã </font>Printing Precision is 10<font face=Kapl>

     12345.678912           ã </font>See that ordinary display obeys Printing Precision:<font face=Kapl>
 12345.67891                ã </font>5 digits before the decimal point, so 5 (10-5) digits after.<font face=Kapl>

     14.7 î 12345.678912
 12345.6789120              ã </font>Format ignores Printing Precision and obeys the left argument.
</pre>
</BLOCKQUOTE><A NAME=HEADING161>
<H2><FONT color="#20B2AA">Grade down<A NAME=138><font face=Kapl>  çx</font></font></h2>
</font><b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is either a simple numeric array or a simple character array or a simple symbol array.  The result is a vector of integers of length <font face=Kapl>#x</font>, i.e., of length equal to the number of items in <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result <font face=Kapl>r</font> is a permutation of the vector <font face=Kapl>É#x</font> such that the items of <font face=Kapl>r#x</font> are in nonascending, lexicographic order.  To determine whether or not one item is greater than or equal to another in the lexicographic sense, leading elements in their ravels are compared first, and only in the case of ties are the elements that follow compared.  Alphabetic characters are sorted in accordance with their ASCII codes, which are shown in "<A HREF="APlusRefV2_63.html#10">Graphic Characters for Atomic Vector</A>".  The indices of equal items are in ascending order in <font face=Kapl>r</font>.  That is, if <font face=Kapl>i</font> is less than <font face=Kapl>j</font> and <font face=Kapl>r[i]#x</font> is identical to <font face=Kapl>r[j]#x</font>, then <font face=Kapl>r[i]</font> is less than <font face=Kapl>r[j]</font>.  Comparison tolerance is not used.  If <font face=Kapl>x</font> is a symbol array, the result is the same as it would be for <font face=Kapl>Îx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and a type error is reported only if a valence error is not:<P>
<UL>
<LI>a valence error is reported if there is a left argument;
<LI>a type error is reported if the argument is not a simple numeric or character array.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     ç 10.2 6 999 0 6
 2 0 1 4 3
     (ça)#aûÎ`apl `a `apple
apple
apl
a</font></pre>
</BLOCKQUOTE><A NAME=HEADING162>
<H2><FONT color="#20B2AA">Grade up<A NAME=142><font face=Kapl>  èx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is either a simple numeric array or a simple character array or a simple symbol array.  The result is a vector of integers of length <font face=Kapl>#x</font>, i.e., of length equal to the number of items in <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result <font face=Kapl>r</font> is a permutation of the vector <font face=Kapl>É#x</font> such that the items of <font face=Kapl>r#x</font> are in nondescending, lexicographic order.  To determine whether or not one item is less than or equal to another in the lexicographic sense, leading elements in their ravels are compared first, and only in the case of ties are the elements that follow compared.  Alphabetic characters are sorted in accordance with their ASCII codes, which are shown in "<A HREF="APlusRefV2_63.html#10">Graphic Characters for Atomic Vector</A>".  The indices of equal items are in ascending order in <font face=Kapl>r</font>.  That is, if <font face=Kapl>i</font> is less than <font face=Kapl>j</font> and <font face=Kapl>r[i]#x</font> is identical to <font face=Kapl>r[j]#x</font>, then <font face=Kapl>r[i]</font> is less than <font face=Kapl>r[j]</font>.  Comparison tolerance is not used.  If <font face=Kapl>x</font> is a symbol array, the result is the same as it would be for <font face=Kapl>Îx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
The following report is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>a type error is reported if the argument is not a simple numeric or character array.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     è 10.2 6 999 0 6
 3 1 4 0 2
     (èa)#aûÎ`apl `a `apple
a
apl
apple</font></pre>
</BLOCKQUOTE><A NAME=HEADING163>
<H2><FONT color="#20B2AA">Interval<A NAME=147><font face=Kapl>  Éx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is a simple scalar or vector of nonnegative restricted whole numbers.  The result is an array of integers whose shape is <font face=Kapl>x</font> if <font face=Kapl>x</font> is a vector, or <font face=Kapl>,x</font> if <font face=Kapl>x</font> is a scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If the argument <font face=Kapl>x</font> is a scalar or one-element vector, the result is the vector of integers from <font face=Kapl>0</font> to <font face=Kapl>x-1</font>.  If the argument <font face=Kapl>x</font> is a vector with 2 or more elements, the result is the vector of integers from <font face=Kapl>0</font> to <font face=Kapl>(«/x)-1</font>, reshaped to shape <font face=Kapl>x</font>: viz., <font face=Kapl>xÒÉ«/x</font> (see "<A HREF="#227">Reshape</A>").<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the argument is not simple or an element of it is not a restricted whole number;
<LI>a rank error is reported if the argument is not a scalar or a vector;
<LI>a domain error is reported if the argument has a negative element;
<LI>a maxrank error is reported if the argument has more than nine elements.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     É5
 0 1 2 3 4
     É2 3
 0 1 2
 3 4 5</font></pre>
</BLOCKQUOTE><A NAME=HEADING164>
<H2><FONT color="#20B2AA">Item <A NAME=152>Ravel<font face=Kapl>  !x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is any array of rank at least 2.  The result has shape <font face=Kapl>(«/2ÙÒx),2ÕÒx</font> and the same type as the argument.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is <font face=Kapl>((«/2ÙÒx),2ÕÒx)Òx</font>, i.e., the ravel of the first two axes of <font face=Kapl>x</font> becomes the first axis of the result.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
The following report is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>a rank error is reported if the argument is a scalar or vector.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     !É2 2 4
  0  1  2  3
  4  5  6  7
  8  9 10 11
 12 13 14 15</font></pre>
</BLOCKQUOTE><A NAME=HEADING165>
<H2><FONT color="#20B2AA">Laminate<A NAME=156><font face=Kapl>  y~x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
Either <font face=Kapl>x</font> and <font face=Kapl>y</font> have equal shapes, or one is a scalar.  They also must have the same general type.  If <font face=Kapl>x</font> is nonscalar, the shape of the result is <font face=Kapl>2,Òx</font>; otherwise, the shape of the result is <font face=Kapl>2,Òy</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result <font face=Kapl>r</font> always has two items.  If <font face=Kapl>x</font> and <font face=Kapl>y</font> have equal shapes then item <font face=Kapl>r[0]</font> equals <font face=Kapl>y</font> and item <font face=Kapl>r[1]</font> equals <font face=Kapl>x</font>.  If <font face=Kapl>x</font> is nonscalar and <font face=Kapl>y</font> is a scalar then item <font face=Kapl>r[0]</font> equals <font face=Kapl>(Òx)Òy</font> and item <font face=Kapl>r[1]</font> equals <font face=Kapl>x</font>.  If <font face=Kapl>x</font> is scalar and <font face=Kapl>y</font> is a nonscalar then item <font face=Kapl>r[0]</font> equals <font face=Kapl>y</font> and item <font face=Kapl>r[1]</font> equals <font face=Kapl>(Òy)Òx</font>.<P>
The result has the same type as:<P>
<UL>
<LI>the floating-point argument, if the other one is integer; else
<LI>the left argument, if neither argument is empty; else
<LI>the nonempty argument, if exactly one argument is empty; else
<LI>the right argument.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the arguments are not of the same general type;
<LI>a rank error is reported if neither argument is a scalar and their ranks differ;
<LI>a length error is reported if neither argument is a scalar and their shapes differ;
<LI>a maxrank error is reported if the rank of either argument is 9.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     1 2 3~10 20 30
  1  2  3
 10 20 30</font></pre>
</BLOCKQUOTE><A NAME=HEADING166>
<H2><FONT color="#20B2AA">Left<A NAME=160><font face=Kapl>  yÝx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> and <font face=Kapl>x</font> are any arrays.  The result is the same shape and type as <font face=Kapl>y</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is identical to the left argument.  Left can be used to execute two expressions when you would only discard the explicit result of the first one anyway.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     2 3Ý'abc'
 2 3
ã </font>Evaluate a dependency to keep its last value, then remove its definition:<font face=Kapl>
     _undef{`x} Ý %`x
     a[èa] Ý aû0 2 4 5 1 3 7 6
 0 1 2 3 4 5 6 7
     ((aÉa)=ÉÒa)/a Ý aû'keep only the unique characters'
keponlythuiqcars</font></pre>
</BLOCKQUOTE><A NAME=HEADING167>
<H2><FONT color="#20B2AA">Match<A NAME=165><font face=Kapl>  y½x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The arguments can be any arrays, including function arrays.  The result is an integer, either 1 or 0.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison tolerance, if an argument is in floating point.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is 1 if at all levels <font face=Kapl>y</font> and <font face=Kapl>x</font> are the same shape and type (except that integer and floating point match here), and all their simple scalar components, at whatever level, are tolerably equal.  The result is 0 otherwise.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     'abc'½'a','b','c'
 1
     ''½É0
 0
     (É2 4)½'no match'
 0              ã </font>Unlike Equal to, never an error; always 0 or 1.</pre>
</BLOCKQUOTE><A NAME=HEADING168>
<H2><FONT color="#20B2AA">Matrix Inverse<A NAME=171><font face=Kapl>  ­x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a simple numeric array of rank less than or equal to 2 - if 2,
 then at least as many rows as columns. The result has shape <font face=Kapl>÷Òx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> is a nonsingular matrix with the same number of rows as columns, then the result is its matrix inverse.  If <font face=Kapl>x</font> is a matrix with more rows than columns, and if the columns are linearly independent, the result is the unique left matrix inverse of <font face=Kapl>x</font>.  That is, <font face=Kapl>(­x)+.«x</font> equals an identity matrix, but <font face=Kapl>x+.«­x</font> may not.  If <font face=Kapl>x</font> is a vector the result is <font face=Kapl>,­((Òx),1)Òx</font>.  If <font face=Kapl>x</font> is a scalar the result is <font face=Kapl>ßx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>a rank error is reported if the rank of the argument exceeds 2;
<LI>a domain error is reported if (1) the argument is not a simple numeric array, (2) the argument is a matrix with more columns than rows, or (3) the argument is singular or very ill-conditioned.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     ­ 2 2Ò 1 2 3 4
 ¢2    1
  1.5 ¢0.5</font></pre>
</BLOCKQUOTE><A NAME=HEADING169>
<H2><FONT color="#20B2AA">Member<A NAME=176><font face=Kapl>  yÅx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The arguments are any arrays of the same general type.  The rank of the items of <font face=Kapl>x</font> must not exceed the rank of <font face=Kapl>y</font>, and the trailing <font face=Kapl>¢1+ÒÒx</font> trailing axes of <font face=Kapl>y</font> must have length <font face=Kapl>1ÕÒx</font>.  The result is an array of integers whose shape is defined by the A+ expression <font face=Kapl>(-0Ó(ÒÒx)-1)ÕÒy</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison tolerance, if an argument is in floating point.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Partition <font face=Kapl>y</font> into cells of rank <font face=Kapl>0Ó(ÒÒx)-1</font>.  The result has one element for each such cell.  The value of that element is 1 if at all levels the cell and at least one of the items of <font face=Kapl>x</font> are the same shape and type (except that integer and floating point match here) and all their simple scalar components, at whatever level, are tolerably equal - i.e., if Match yields 1 for the cell and some item of <font face=Kapl>x</font>.  The result is 0 otherwise.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the arguments are not of the same general type;
<LI>a rank error is reported if the rank of <font face=Kapl>y</font> is less than that of the items of <font face=Kapl>x</font>, so the partitioning fails;
<LI>a length error is reported if the items of <font face=Kapl>x</font> and the cells into which <font face=Kapl>y</font> is partitioned have different shapes.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b>
<pre></font><font face=Kapl>     (123+1e-10 1e-11)Å123,1950+É50
 0 1
     1992 1991 1870 1992 2001Å123,1950+É50
 1 1 0 1 0
     (2 3Ò'catpat')Å(4 3Ò'fatbatcathat')
 1 0</font></pre>
<A NAME=HEADING170>
<H2><FONT color="#20B2AA">Null<A NAME=180><font face=Kapl>  Ýx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is Null, i.e., <font face=Kapl>()</font>, the empty symbol vector, whose type
 is <font face=Kapl>`null</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     Ý'junk'
     ()½Ý9 10
 1</font></pre>
</BLOCKQUOTE><A NAME=HEADING171>
<H2><FONT color="#20B2AA">Pack<A NAME=185><font face=Kapl>  Âx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a simple character array.  The result is an array of symbols with shape <font face=Kapl>¢1ÕÒx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>i#r</font> is an element of the result <font face=Kapl>r</font> then <font face=Kapl>i#x</font> is a character vector along the last axis of <font face=Kapl>x</font>.  Item <font face=Kapl>i#r</font> is the symbol that, when displayed, looks exactly like the character vector <font face=Kapl>i#x</font> except for the leading <font face=Kapl>`</font>.  Trailing blanks in <font face=Kapl>i#x</font> are ignored, but included blanks are allowed. The null character, <font face=Kapl>`char©0</font>, is used by the interpreter to delimit symbols, so never try to include it in a symbol: it will exclude any characters following it from the symbol.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
The following report is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>a type error is reported if the argument is not a simple character array.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     Â2 3Ò'a  abc'
 `a `abc</font></pre>
</BLOCKQUOTE><A NAME=HEADING172>
<H2><FONT color="#20B2AA">Partition<font face=Kapl>  <A NAME=188>yÚx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a simple array of restricted whole numbers, and <font face=Kapl>x</font> is any array.  The result is a nested vector whose length is <font face=Kapl>Ó(#x)ßy</font> if <font face=Kapl>y</font> consists of one element and that element is not zero, and otherwise a nested array of the same shape as <font face=Kapl>y</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The elements of <font face=Kapl>y</font> are nonnegative.  If <font face=Kapl>y</font> has one element and that element is not zero, then the first element of the result is Enclose of the first <font face=Kapl>y</font> items of <font face=Kapl>x</font>, the second element is Enclose of the next <font face=Kapl>y</font> items of <font face=Kapl>x</font>, and so on, until there are fewer than <font face=Kapl>y</font> items of <font face=Kapl>x</font> remaining.  If there are no remaining elements, then the result is complete, and otherwise the last element of the result is Enclose of the remaining items of <font face=Kapl>x</font>.<P>
If <font face=Kapl>y</font> has more than one element or is 0, then the result has the same shape as <font face=Kapl>y</font>, and the first element of the ravel of the result is Enclose of the first <font face=Kapl>(,y)[0]</font> items of <font face=Kapl>x</font>, the second element is Enclose of the next <font face=Kapl>(,y)[1]</font> items of <font face=Kapl>x</font>, and so on until <font face=Kapl>y</font> is exhausted.  If for some element of the result there are fewer items remaining in <font face=Kapl>x</font> than <font face=Kapl>y</font> specifies for that element, then those remaining items of <font face=Kapl>x</font> are enclosed to form that element, and any remaining elements of the result are empty.  On the other hand, not all items of <font face=Kapl>x</font> need appear in the result.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and a domain error is reported only if a type error is not:<P>
<UL>
<LI>a type error is reported if the left argument is nested or does not consist of restricted whole numbers;
<LI>a domain error is reported if the left argument contains a negative number.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     3 2 2 1ÚÉ6 3
&lt;  0 1 2
   3 4 5
   6 7 8
&lt;   9 10 11
   12 13 14
&lt;  15 16 17
&lt;
     3ÚÉ5
&lt;  0 1 2
&lt;  3 4
     (Ú' '=x)Úxû' this is'     ã </font>See Partition Count.<font face=Kapl>
&lt;  this
&lt;  is</font></pre>
</BLOCKQUOTE><A NAME=HEADING173>
<H2><FONT color="#20B2AA">Partition Count<A NAME=191><font face=Kapl>  Úx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a simple vector or scalar of restricted whole numbers.  The result is a numeric vector of integers.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
In general, <font face=Kapl>x</font> is a vector or scalar of restricted whole numbers, but in the usual case it is a vector composed of zeros and ones. All nonzero numbers are treated alike, and the description assumes ones for simplicity.<P>
The first element of <font face=Kapl>x</font> must be 1.  The length of the result is the number of ones in <font face=Kapl>x</font>, i.e., <font face=Kapl>+/x</font>, and each element of the result corresponds to a 1 in <font face=Kapl>x</font>.  The value of an element is the length of the subvector consisting of the 1 it corresponds to and all the zeros preceding the next 1.  Put another way, the elements of the result are the lengths of the contiguous sequences of zeros starting at each 1 in <font face=Kapl>x</font>, plus 1.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the argument is nested or does not consist of restricted whole numbers;
<LI>a rank error is reported if the argument is not a scalar or vector;
<LI>a domain error is reported if the argument begins with a zero.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     Ú1 0 0 0 1 0
 4 2
     Ú1 0 0 0 1 1 0 1
 4 1 2 1</font></pre>
</BLOCKQUOTE><A NAME=HEADING174>
<H2><FONT color="#20B2AA">Pick<font face=Kapl><A NAME=195>  yØx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>y</font> is the Null, or a simple scalar or vector of integers or symbols, or a nested scalar or vector whose items are simple scalars or vectors of integers.  The right argument <font face=Kapl>x</font> is any array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
All permitted combinations of arguments are considered by turns.<P>
<b>Any valid right argument and empty left argument (<font face=Kapl>É0</font> or the
 Null)</b>
<p>
An empty vector <font face=Kapl>y</font> picks all of <font face=Kapl>x</font>.
 (<b>Warning!</b> A possible point of confusion: although Pick acts like Choose and Bracket
 Indexing for the Null, selecting all, for <font face=Kapl>É0</font> it differs from those
 two functions, picking all whereas they select none.)
<p>
<a name="195A"><b>Scalar right argument</b></a><p>
The result is the same as if the right argument
 were a one-element vector; if the left argument is not empty, it must be 0.<p>
<b>Slotfiller right argument and simple symbol left argument</b><P>
A symbol is used to pick from a slotfiller, an array of the form <font face=Kapl>(s;v)</font>, where <font face=Kapl>s</font> is a scalar or vector of symbols and <font face=Kapl>v</font> is any nested scalar or vector of the same length as <font face=Kapl>s</font> (see "<A HREF="APlusRefV2_4.html#75">Subtypes and Supertypes</A>").  If <font face=Kapl>y</font> has one element and is identical to the <font face=Kapl>i</font>th element of <font face=Kapl>s</font>, i.e., <font face=Kapl>i#s</font>, (and not to any previous element - Pick does not check that the elements of <font face=Kapl>s</font> are distinct) then <font face=Kapl>yØ(s;v)</font> is defined and equals <font face=Kapl>&gt;i#v</font>.  If <font face=Kapl>x</font> is a slotfiller composed of a pair of scalars, <font face=Kapl>(`sym;&lt;array)</font> for example, and <font face=Kapl>y</font> equals <font face=Kapl>0Øx</font>, then <font face=Kapl>yØx</font> is defined and equals <font face=Kapl>&gt;1Øx</font>.
<P>
If <font face=Kapl>x</font> is a nested slotfiller and <font face=Kapl>y</font> a simple vector of symbols (a <i>path vector</i>), the result is <font face=Kapl>y[¢1+#y]Ø...Øy[1]Øy[0]Øx</font> where the scalar Picks are as just defined.  Note that the order of the elements in the left argument corresponds to the depth of the selection from the right argument: element 0 in the left argument refers to the top level, element 1 refers to the second level, and so on.<P>
<b>Simple right argument and simple numeric left argument of length 1</b><P>
A simple array can be picked from only when <font face=Kapl>y</font> is <font face=Kapl>É0</font> or Null or a scalar or one-element vector.  That is, there must be only one step to the Pick, and either a single item or all of <font face=Kapl>x</font> must be picked.  An empty vector picks all of <font face=Kapl>x</font>, as stated above, and for a scalar or one-element vector and a simple right argument, Pick is the same as Choose:
<pre></font><font face=Kapl>     yØx ûý y#x.</pre>
If </font><font face=Kapl>y</font> is a scalar or one-element vector, then the rank of <font face=Kapl>x</font> must not exceed 1. For example,<br><font face=Kapl>
&nbsp;&nbsp;()Ø1 &nbsp;&nbsp; ûý 1<BR>
&nbsp;&nbsp;()Ø1 2 &nbsp;ûý (É0)Ø1 2 ûý 1 2<BR>
&nbsp;&nbsp;1Ø1 2 3 ûý 2<BR>
&nbsp;&nbsp;0ØÉ2 3 </font>is a rank error.<P>
<b>Nested vector right argument and simple left argument</b><P>
If <font face=Kapl>y</font> has a single element, <font face=Kapl>x</font> is a vector and the result is the Disclose of the (scalar) <font face=Kapl>y</font>th element of <font face=Kapl>x</font>, i.e.,
<pre></font><font face=Kapl>     &gt;y#x.</font></pre>
A vector <font face=Kapl>y</font> is called a <i>path vector</i>, and <font face=Kapl>yØx</font> (for a simple <font face=Kapl>y</font>) reaches into <font face=Kapl>x</font> with a series of Picks that select scalars and Disclose them, using one element of <font face=Kapl>y</font> at each step:
<pre></font><font face=Kapl>     y[¢1+#y]Ø...Øy[1]Øy[0]Øx.</font></pre>
The order of the elements in the left argument corresponds to the depth of the selection from
 the right argument: element 0 in the left argument refers to the top level, element 1 refers
 to the second level, and so on.  The argument <font face=Kapl>x</font> and the result of
 each but the last scalar Pick must be a vector, since the left argument of each step of Pick
 is a scalar.  Picking from a simple array is not allowed as a continuation step: a simple
 array can be produced only as the final step;<font face=Kapl> 1&nbsp;0Ø(1;2&nbsp;3;4)
 </font>is an error.<P>
<b>Nested right argument and nested left argument</b><P>
If <font face=Kapl>y</font> is nested, its items are used in a way similar to the previous case and must each select a scalar, but the rank of <font face=Kapl>x</font> and any of its components can exceed 1.  If <font face=Kapl>y</font> is scalar and <font face=Kapl>x</font> is of rank 2 or greater (to distinguish this case from the previous one), <font face=Kapl>y</font> must contain a full set of indices for <font face=Kapl>x</font>, as an enclosed simple vector.  The result is the Disclose of a single element chosen from <font face=Kapl>x</font>, viz.,
<pre></font><font face=Kapl>     &gt;(&lt;@0&gt;y)#x</font></pre>
(A small complexity in this expression arises from the fact that Pick, in general picking a single element during each of several steps, requires all its indices for each depth to be in one box, whereas Choose, in general choosing several elements or cross sections but only at the top level, requires the indices for each axis to be in one box.)  If <font face=Kapl>y</font> is a vector, then <font face=Kapl>yØx</font> reaches into <font face=Kapl>x</font> with a series of scalar Picks of the same form as just shown for the simple case, but now each element of <font face=Kapl>y</font> is an enclosed simple vector and the corresponding component of <font face=Kapl>x</font>, from which <font face=Kapl>y</font> selects, need not be a vector.<P>
Picking from a simple array is not allowed as a continuation step: a simple array can be produced only as the final step;<font face=Kapl> (1;0)Ø(1;2&nbsp;3;4) </font>is an error.<P>
By the way, <font face=Kapl>((j;i)Øa)ûb</font> is a valid Selective Assignment, although <font face=Kapl>(iØjØa)ûb</font> is not.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>a type error is reported if <font face=Kapl>y</font> is not composed of symbols or integers (not just restricted whole numbers);
<LI>a rank error is reported if (1) <font face=Kapl>y</font> or anything it contains is not a vector or a scalar, or (2) one of its items has a length unequal to the rank of the array to which it is applied;
<LI>a domain error is reported if (1) <font face=Kapl>y</font> is symbolic and <font face=Kapl>x</font> is not (more or less) a slotfiller array, or (2) during the execution of Pick and not as its last step, an array is picked that is not nested;
<LI>an index error is reported if an element of <font face=Kapl>y</font> is not in the range 0 to n-1, where n is the length of the axis it is applied to, or if <font face=Kapl>y</font> is a symbol and is not a member of the vector of symbols <font face=Kapl>s</font> in <font face=Kapl>x</font>.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     1Ø('ab';(2 2Ò'cdef';10 20))
&lt; cd
  ef
&lt;  10 20
     0Ø1Ø('ab';(2 2Ò'cdef';10 20))
cd
ef
     1 0Ø('ab';(2 2Ò'cdef';10 20))
cd
ef
     (1;0;0 1)Ø('ab';(2 2Ò('c';'d';'e';'f');10 20))
d
     `wasØ(`this `was `that;(10;20;30))
 20
     `this `was `that É`was
 1
     1Ø(10;20;30)
 20
     `isØ(`this `was `that;(10;20;30))
 Ø: index
*    ý
     `aØ(`a;&lt;10)
 10</font></pre>
</BLOCKQUOTE><A NAME=HEADING175>
<H2><FONT color="#20B2AA">Print<A NAME=200><font face=Kapl>  Õx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array and its value is also the result.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is <font face=Kapl>x</font>, but additionally the value of <font face=Kapl>x</font> is displayed in the A+ session.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     2+Õ3
 3
 5</font></pre>
</BLOCKQUOTE><A NAME=HEADING176>
<H2><FONT color="#20B2AA">Rake<A NAME=204><font face=Kapl>  Åx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array.  The result is a nested vector whose depth is one, or a function scalar or the Null.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> is the Null, so is the result.  If <font face=Kapl>x</font> is simple and not the Null, the result is <font face=Kapl>,&lt;x</font>.  Otherwise, the result is a vector composed of the simple components of <font face=Kapl>x</font>, except that Nulls are discarded.  The simple components of <font face=Kapl>x</font> are all those simple objects obtainable by repeated selection and disclosure.  Each of these components is enclosed in the result, except that scalars of type symbol and function that were at depth zero remain so.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     Å`a `b
&lt;  `a `b   ã </font>A vector whose only element is of<font face=Kapl>
           ã </font>depth 1 and, when disclosed, length 2.<font face=Kapl>
     Å`a`b,(+;'ac';1 2;(3 4;(5;&lt;(););6);7 8)
&lt;  `a
&lt;  `b      ã Despite the display,
&lt;  +       ã </font>the first three elements are simple:<font face=Kapl> `a `b &lt;{+}
&lt;  ac      ã </font>This and all the rest of the elements are each at depth 1.<font face=Kapl>
&lt;  1 2
&lt;  3 4
&lt;  5       ã </font>Notice that two Nulls were discarded following this element.<font face=Kapl>
&lt;  6
&lt;  7 8</font></pre>
</BLOCKQUOTE><A NAME=HEADING177>
<H2><FONT color="#20B2AA">Ravel<A NAME=209><font face=Kapl>  ,x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>x</font> is any array.  The result is a vector of shape <font face=Kapl>«/Òx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is the vector of the elements in <font face=Kapl>x</font>, taken in row-major, or odometer, order. For a scalar, it is a one element vector.
<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     a
 101   2
   3 ¢45
  34  21.5
     ,a
 101 2 3 ¢45 34 21.5</font></pre>
</BLOCKQUOTE><A NAME=HEADING178>
<H2><FONT color="#20B2AA">Raze<A NAME=213><font face=Kapl>  Øx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is either a simple array or a nested scalar or vector.  If it is a nested vector, then the Discloses of its elements must all be conformable: they must be of the same general type and, treating scalars as one-element vectors, their ranks and the shapes of their items must be same.<P>
The type of the result depends upon the Discloses of the elements of <font face=Kapl>x</font>.  If one of them is a nonempty floating-point array, the result type is floating point.  Otherwise, if any of them are nonempty, the result type is that of the first nonempty one; else it is the type of the first one.<P>
The result shape is <font face=Kapl>Òx</font> if <font face=Kapl>x</font> is simple, <font face=Kapl>Ò&gt;x</font> if <font face=Kapl>x</font> is a nested scalar, <font face=Kapl>Ò&gt;''Òx</font> if <font face=Kapl>x</font> is a nested one-element vector, and otherwise <font face=Kapl>(+/&gt;@0#¡x),s</font>, where <font face=Kapl>s</font> is the common shape of the items of the disclosed elements of <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
If <font face=Kapl>x</font> is simple, then the result equals <font face=Kapl>x</font>.  If <font face=Kapl>x</font> is a nested scalar, the result is <font face=Kapl>&gt;x</font>.  If <font face=Kapl>x</font> is a one-element nested vector, then if that one element is an enclosed scalar, the result is <font face=Kapl>,&gt;x</font>, and otherwise the result is <font face=Kapl>&gt;x</font>.  If <font face=Kapl>x</font> is a nested vector with more than one element, the result is the catenation of the Discloses of all elements of <font face=Kapl>x</font>, i.e.,
<pre></font><font face=Kapl>(&gt;0#x),(&gt;1#x),...,&gt;(¢1+#x)#x</font></pre>
Note in the latter case that <font face=Kapl>x</font> is in the domain of Raze only if (1) this series of catenations can be formed and (2) the Discloses of all the elements are either all the same rank or a mixture of scalars and vectors.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a domain error is reported if some elements of <font face=Kapl>x</font> are simple and some elements are nested;
<LI>a rank error is reported if the Discloses of the elements of <font face=Kapl>x</font> have different ranks, unless they are all either vectors or scalars;
<LI>a mismatch error is reported if the items of the Discloses of the elements of <font face=Kapl>x</font> have different shapes;
<LI>a type error is reported if the Discloses of the elements of <font face=Kapl>x</font> have different general types.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     Ø('ab';'cde';'f')
 abcdef
     Ø(É2 3;10«É2 3)
  0  1  2
  3  4  5
 10 11 12
 13 14 15</font></pre>
</BLOCKQUOTE><A NAME=HEADING179>
<H2><FONT color="#20B2AA">Replicate<A NAME=222><font face=Kapl>  y/x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>y</font> is a simple vector or one-element array of nonnegative restricted whole numbers, and <font face=Kapl>x</font> is any array.  If <font face=Kapl>y</font> is a vector of length unequal to one, then its length equals the number of items of <font face=Kapl>x</font>, i.e., <font face=Kapl>#x</font>,
 or <font face=Kapl>x</font> can be a scalar.
 The items of the result are items of <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The items of the result are taken from the items of <font face=Kapl>x</font>.  Each item <font face=Kapl>i#x</font> (or <font face=Kapl>x</font> itself if it is a scalar)
 is replicated <font face=Kapl>y[i]</font> times in the result.  A scalar or other one-element array <font face=Kapl>y</font> is treated like <font face=Kapl>(#x)Òy</font>, i.e., each item of <font face=Kapl>x</font> is replicated <font face=Kapl>y</font> times in the result.  The number of items in the result is <font face=Kapl>+/(#x)Òy</font>.  When every element of <font face=Kapl>y</font> is 0 or 1, this function is called Compress.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), except token precedes value, and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a token error (like a parse error) is reported if there is a primitive function or operator symbol to the immediate left of <font face=Kapl>/</font> that is not one of <font face=Kapl>+«ÓÄ^©</font>;
</UL>
and, unless one of <font face=Kapl>+«ÓÄ^©</font> is to the immediate left of <font face=Kapl>/</font>, throwing you into Reduce, a monadic operator:<P>
<UL>
<LI>a valence error is reported if there is no left argument to the immediate left of <font face=Kapl>/</font>;
<LI>a type error is reported if the left argument is nested or does not consist of restricted whole numbers;
<LI>a domain error is reported if the left argument contains a negative number;
<LI>a rank error is reported if the left argument is not a vector or a one-element array;
<LI>a length error is reported if the number of elements in the left argument equals neither one nor the number of items in the right argument, unless the right argument
 is a scalar.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     3 0 1/3 2Ò'abcdef'
ab
ab
ab
ef
     (a¦0)/aû4 ¢1 3 0 8 ¢5     ã </font>Compress.<font face=Kapl>
 4 3 0 8
     2 0 3 0/'a'
aaaaa</pre>
</BLOCKQUOTE><A NAME=HEADING180>
<H2><FONT color="#20B2AA">Reshape<A NAME=227><font face=Kapl>  yÒx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is any simple array of nonnegative restricted whole numbers, and <font face=Kapl>x</font> is any array.  The result is an array whose shape is <font face=Kapl>,y</font> and whose type is that of <font face=Kapl>x</font> except in certain cases when the result is empty (see the definition, below).<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The value is an array whose elements come from <font face=Kapl>,x</font> (see "<A HREF="#209">Ravel</A>") in ascending index order.  The number of elements of <font face=Kapl>x</font> needed for the result is <font face=Kapl>«/,y</font>.  If <font face=Kapl>x</font> has at least <font face=Kapl>«/,y</font> elements, any excess is ignored.  If <font face=Kapl>x</font> is nonempty but has fewer than <font face=Kapl>«/,y</font> elements, the elements of <font face=Kapl>x</font> are used cyclically.  If <font face=Kapl>x</font> is empty, the resultant array is filled with zeros if <font face=Kapl>x</font> is numeric, blanks if <font face=Kapl>x</font> is character, or enclosed Nulls if <font face=Kapl>x</font> is nested, as shown in the table "<A HREF="#310">Fill Elements</A>".<P>
If <font face=Kapl>y</font> is all zeros, the result is of course empty, and its type is the type of <font face=Kapl>x</font> if <font face=Kapl>x</font> is character, integer, floating point, or null, but its type is null if <font face=Kapl>x</font> is box, symbol, or function.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if <font face=Kapl>y</font> is not simple or has an element that is not a restricted whole number;
<LI>a domain error is reported if <font face=Kapl>y</font> has a negative element, or if <font face=Kapl>«/,y</font> is too large to be represented as an integer - i.e., is not a restricted whole number;
<LI>a maxrank error is reported if <font face=Kapl>y</font> has more than nine elements.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     2 3Ò'abcdefgh'
abc
def
     10Ò'abcdefgh'
abcdefghab</font></pre>
</BLOCKQUOTE><A NAME=HEADING181>
<H2><FONT color="#20B2AA">Restructure<A NAME=232><font face=Kapl>  y!x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The left argument <font face=Kapl>y</font> is a simple one-element array whose value is a restricted whole number, and the right argument <font face=Kapl>x</font> is any array, except that it must be nonscalar unless <font face=Kapl>y</font> is 1.  The result has rank 1 greater than the rank of <font face=Kapl>x</font>.  Except for the first two axes of the result and the first axis of <font face=Kapl>x</font>, the shapes of the result and <font face=Kapl>x</font> are equal.  There are two quite different cases.<P>
<UL>
<LI>If <font face=Kapl>y</font> is positive, it must evenly divide <font face=Kapl>#x</font>, and the result has shape <font face=Kapl>((#x)ß,y),(,y),1ÕÒx</font>.<p>
<LI>If <font face=Kapl>y</font> is negative or zero, the result has shape <font face=Kapl>((,y)+1+#x),(-,y),1ÕÒx</font>.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
In both cases of this function the result is obtained by arranging the items of <font face=Kapl>x</font> in ways that replace the first axis of <font face=Kapl>x</font> with two new axes.  In the case where <font face=Kapl>y</font> is positive it must evenly divide <font face=Kapl>#x</font>, and then the result is simply a reshape of the leading axis of the <font face=Kapl>x</font> into two axes, the first of length <font face=Kapl>(#x)ßy</font>, and the second of length <font face=Kapl>y</font>.  See the first example.<P>
In the case where <font face=Kapl>y</font> is negative or zero, the elements of <font face=Kapl>x</font> are used repeatedly.  The result <font face=Kapl>r</font> can be thought of in terms of clipping sections of the first axis of <font face=Kapl>x</font> using a window of length <font face=Kapl>-y</font>.  That is, if <font face=Kapl>wûÉ-,y</font> then <font face=Kapl>0#r</font> is <font face=Kapl>w#x</font>, <font face=Kapl>1#r</font> is <font face=Kapl>(w+1)#x</font>, and <A NAME=233>in general <font face=Kapl>i#r</font> is <font face=Kapl>(w+i)#x</font>.  See the second example.  This form of the function is useful for producing moving averages.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the left argument is not simple or has an element that is not a restricted whole number;
<LI>a nonce error is reported if the left argument has more than one element;
<LI>a rank error is reported if the right argument is scalar and the left argument is not 1;
<LI>a maxrank error is reported if the right argument is of rank 9;
<LI>a length error is reported if the left argument is positive and does not evenly divide the number of items in the right argument, or if it is negative and more than one greater in absolute value than the number of items in the right argument (for negative <font face=Kapl>y</font>, if <font face=Kapl>|y</font> equals <font face=Kapl>#x</font> the result has one item, and if it equals <font face=Kapl>1+#x</font> the result has zero items).
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     3!'abcABC'
abc
ABC
     ¢3!0 1 2 3 4 5 6
 0 1 2
 1 2 3
 2 3 4
 3 4 5
 4 5 6
     +/@1Û¢3!0 1 2 3 4 5 6
 3 6 9 12 15
     (+/@1Û¢3!0 1 2 3 4 5 6)ß3 ã </font>Moving average of length 3<font face=Kapl>
 1 2 3 4 5</font></pre>
</BLOCKQUOTE><A NAME=HEADING182>
<H2><FONT color="#20B2AA">Result<font face=Kapl> <A NAME=239> ûx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array and its value is also the result.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The effect of Result is to exit from the current function or immediate execution code and
 return <font face=Kapl>x</font> as the result. (In immediate execution, this value will
 not be displayed
 if what the A+ display mechanism believes was the last function executed is thought by it
 to be an Assignment - i.e., the display mechanism may not recognize the exit or it may take
 the Result arrow to be an Assignment arrow.) The niladic use of this symbol, a bare left
 arrow (<font face=Kapl>û</font>), is meaningful only outside function definitions, where
 its effect is to
 cause resumption of the most recently suspended function execution, with the workspace size
 increased if necessary; within a function
 definition it is ignored.  Thus, within a function, <font face=Kapl>û()</font> causes an
 exit and the
 return of a Null result, whereas <font face=Kapl>û</font> alone has no effect at all.<P>
<b><font color=#FF0000>Warning!</font></b>&nbsp; Within protected execution, whether do or
 Execute, Result exits from that function only, with a 0 return code and the
 Result argument as result;&nbsp; it does not exit from the function containing the
 protected execution text.
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     fact n: {if (n=0) û1; n«fact n-1}
     fact 5
 120
     fact 0
 1</font></pre>
</BLOCKQUOTE><A NAME=HEADING183>
<H2><FONT color="#20B2AA">Reverse<A NAME=243><font face=Kapl>  ÷x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array.  The shape of the result equals the shape of <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is <font face=Kapl>x</font> with the items reversed.  <font face=Kapl>(÷x)[i]</font> is <font face=Kapl>x[(¢1+#x)-i]</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     ÷É5
 4 3 2 1 0
     ÷É2 5
 5 6 7 8 9
 0 1 2 3 4</font></pre>
</BLOCKQUOTE><A NAME=HEADING184>
<H2><FONT color="#20B2AA">Right <A NAME=246><font face=Kapl> Ûx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array.  The result is the same shape and type as <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is the value of the argument.  This primitive is useful in separating the right operand from the right argument in an expression, and also in getting just the value of a mapped file.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
If there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"),<P>
<UL>
<LI>a valence error is reported if there is a left argument.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>
     ÛaûÉ3    ã </font>Continuation beyond Assignment, so the result is displayed.<font face=Kapl>
 0 1 2
              ã </font>Separate right argument from data operand using <font face=Kapl>Û</font> :<font face=Kapl>
     2 4 8,@0Û.5 .25 .125
 2 0.5        ã </font>Items of the result are the scalar cells<font face=Kapl>
 4 0.25       ã </font>of the arguments joined by Catenate.<font face=Kapl>
 8 0.125</font></pre>
</BLOCKQUOTE><A NAME=HEADING185>
<H2><FONT color="#20B2AA">Rotate <A NAME=250><font face=Kapl> y÷x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array.  <font face=Kapl>y</font> is a simple array of restricted whole numbers whose shape equals <font face=Kapl>1ÕÒx</font> unless <font face=Kapl>y</font> consists of a single element (and is then of any rank).  The shape and, for simple <font face=Kapl>x</font>, the type of the result equal the shape and type of <font face=Kapl>x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Suppose <font face=Kapl>x</font> is a matrix and <font face=Kapl>y</font> is a vector with <font face=Kapl>Òy</font> equal to <font face=Kapl>1ÕÒx</font>.  Then the result is <font face=Kapl>x</font> with each column vector <font face=Kapl>x[;i]</font> rotated by the number of elements indicated in <font face=Kapl>y[i]</font>.  If <font face=Kapl>y[i]</font> is positive, then <font face=Kapl>x[;i]</font> is rotated towards the origin, while if <font face=Kapl>y[i]</font> is negative, <font face=Kapl>x[;i]</font> is rotated away from the origin.  If <font face=Kapl>y[i]</font> equals 0, there is no rotation.<P>
If <font face=Kapl>x</font> is a vector and <font face=Kapl>y</font> is a scalar (or other one-element array), then the result is <font face=Kapl>x</font> rotated by the amount <font face=Kapl>y</font>, as described above.  If <font face=Kapl>x</font> is a matrix and <font face=Kapl>y</font> has one element, then the result is <font face=Kapl>x</font> with each column vector <font face=Kapl>x[;i]</font> rotated by <font face=Kapl>y</font>.  The case for <font face=Kapl>x</font> of higher rank is defined by reshaping <font face=Kapl>x</font> into a matrix with all but the first axis combined into one.  Formally, the result is:
<pre></font><font face=Kapl>     (Òx)Ò(,y)÷((1ÙÒx),«/1ÕÒx)Òx</font></pre>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if <font face=Kapl>y</font> is nested or does not consist of restricted whole numbers;
<LI>a rank error is reported if <font face=Kapl>y</font> has more than one element and its rank is not 1 less than that of <font face=Kapl>x</font>;
<LI>a length error is reported if <font face=Kapl>y</font> has more than one element and <font face=Kapl>Òy</font> is unequal to <font face=Kapl>1ÕÒx</font>.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     0 ¢2 1÷É5 3
  0 10  5
  3 13  8
  6  1 11
  9  4 14
 12  7  2</font></pre>
</BLOCKQUOTE><A NAME=HEADING186>
<H2><FONT color="#20B2AA">Selective Assignment <A NAME=257><font face=Kapl> targetûa</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The right argument <font face=Kapl>a</font> is any array.  The left argument is the <i>target</i> of the assignment, and takes one of the forms in the table "<A HREF="#267">Targets of Selective Assignment</A>".  The compatibility requirements for the two arguments are discussed in the definition.  The explicit result is <font face=Kapl>a</font>, except that its type will be that of the selected subarray (see Definition) if they are both numeric but one is integer and the other floating point.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
See also Assignment.  Like it, Selective Assignment, in any form, cannot be the operand of an operator.<P>
Each of the various forms of the left argument (see the table "<A HREF="#267">Targets of Selective Assignment</A>"), if executed separately from Selective Assignment, produces a subarray of some target array that appears in the left argument.  Executed in Selective Assignment, it selects a subarray of locations in the target array.  The effect of Selective Assignment is to replace the values of the target array at the locations specified in the selected subarray by the values in <font face=Kapl>a</font>.<P>
The conformability rule for Selective Assignment is that the shape of the selected subarray must be identical to the shape of the right argument <font face=Kapl>a</font> unless <font face=Kapl>a</font> has only one element.<P>
The type rule is that the selected subarray and <font face=Kapl>a</font> must be of the same general type, with one additional requirement: if the type of the selected subarray is integer and <font face=Kapl>a</font> is floating point, then <font face=Kapl>a</font> must consist entirely of restricted whole numbers, so that it can be coerced to integers before insertion in the selected subarray.<P>
If the same location appears repeatedly in the selected subarray, then in general several distinct values in <font face=Kapl>a</font> will thereby be specified for that one location.  The element of <font face=Kapl>a</font> that is  actually chosen as the new value for that location is the one with the highest index in <font face=Kapl>,a</font>.  See the examples.<P>
A description of each basic form of Selective Assignment follows.<P>
<H2><FONT color="#20B2AA"><a name="inplace">Performance Note: <i>Assignment In Place</i></a></FONT></H2>
Choose Assignment,<font face=Kapl> (...#x)ûy</font>,<font face=Kapl> </font>and the
 corresponding Bracket Assignments,<font face=Kapl> x[...]ûy</font>,<font face=Kapl>
 </font>are the only assignments guaranteed to be done in place - i.e., without copying
 <font face=Kapl>x</font> to a new location while revising it. Append
 Assignment,<font face=Kapl> x[,]ûy</font>,<font face=Kapl> </font>is performed in place if
 there is enough space. All other Selective Assignments, like ordinary Assignment to an
 existing variable, involve copying the target variable while revising it.
</BLOCKQUOTE>
<A NAME=HEADING187>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Bracket Indexing <A NAME=258>Selective Assignment</FONT></H3>
<BLOCKQUOTE>
<A HREF="#38">Bracket Indexing</A> can be used to select subarrays as values. It can also be
 used, in the same form, on the left side of the Assignment arrow to select subarrays of
 locations for assignment of new values.
</BLOCKQUOTE>
<A NAME=HEADING188>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Replace <A NAME=261>All (<font face=Kapl>x[]ûa</font>)</FONT></H3>
<BLOCKQUOTE>
This is a special form of Bracket Indexing Selective Assignment; it would be just a particular case except that it applies to scalars also.  It replaces all the elements in the variable named on the left of the assignment arrow.  It is the most efficient way to replace all elements of a mapped file;  see "<A HREF="APlusRefV2_19.html#4">Mapped Files</A>".
</BLOCKQUOTE>
<A NAME=HEADING189>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Append <A NAME=264> (<font face=Kapl>x[,]ûa</font>)</FONT></H3>
<BLOCKQUOTE>
This is a special form of Bracket Indexing Selective Assignment for appending items to an
 array. <font face=Kapl>x</font> must not be a scalar, else a rank error is
 reported. The conformability rule is that the shape of the items of
 <font face=Kapl>x</font> must be identical to the shape of either <font face=Kapl>a</font>
 or its items, except that <font face=Kapl>a</font> can be a scalar for any
 <font face=Kapl>x</font> (and, as with any scalar extension, a scalar
 <font face=Kapl>a</font> can "disappear" - be extended to empty - if the items of
 <font face=Kapl>x</font> are empty).<P>
Execution of<font face=Kapl> x[,]ûa </font>can be more efficient than<font face=Kapl> xûx,a </font>because if there is enough unused space following <font face=Kapl>x</font> in the storage area allocated to <font face=Kapl>x</font>, the result is formed simply by copying <font face=Kapl>a</font> into that space.  Because storage is allocated roughly in powers of two, an array has between exactly and twice the space it needs.  In particular, this form of assignment is the only efficient way to extend a mapped file;  see "<A HREF="APlusRefV2_19.html#4">Mapped Files</A>".<P>
Append can cause an itemwise invalidation of an itemwise dependency.
 See "<a href="APlusRefV2_17.html#HEADING379">Recognition of Itemwise Changes</A>".<p>
<b>Additional Error Report for Append</b><BLOCKQUOTE>
<UL>
<LI>A length error is reported if there is a preset callback on an Append Assignment and the callback function changes the shape of the data to be appended, so that it no longer agrees with the indices that were passed to the callback function as an argument.
</UL>
</BLOCKQUOTE></BLOCKQUOTE><A NAME=HEADING190>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Targets<A NAME=267> of Selective Assignment</B></FONT></caption>
<tr>
<th>Target Type</th>
<th colspan=4>Target Form (see <A HREF="#271">below</A> regarding <font face=Kapl>f</font> and see
 <A HREF="#268">below</A> regarding <font face=Kapl>,</font> (Ravel))</th></tr>
<tr>
<td>monadic</td><td><font face=Kapl>(f x)</font></td><td><font face=Kapl>(,x)</font></td>
<td><font face=Kapl>(f pØx)</font></td><td><font face=Kapl>(,pØx)</font></td></tr>
<tr>
<td>dyadic</td><td><font face=Kapl>(y f x)</font></td><td><font face=Kapl>(y#,x)</font></td>
<td><font face=Kapl>(y f pØx)</font></td><td><font face=Kapl>(y#,pØx)</font></td></tr>
<tr>
<td>general</td><td><font face=Kapl>f{...;x}</font></td><td><font face=Kapl>#{y;,x}</font></td>
<td><font face=Kapl>f{...;pØx}</font></td><td><font face=Kapl>#{y;,pØx}</font></td></tr>
<tr>
<td>index expression</td><td><font face=Kapl>x[a;...;c]</font></td><td><font face=Kapl>(,x)[a]</font></td>
<td><font face=Kapl>(pØx)[a;...;d]</font></td><td><font face=Kapl>(,pØx)[a]</font></td></tr>
<tr>
<td>choose</td><td><font face=Kapl>((a;...;c)#x)</font></td><td><font face=Kapl>(a#,x)</font></td>
<td><font face=Kapl>((a;...;d)#pØx)</font></td><td><font face=Kapl>(a#,pØx)</font></td></tr>
<tr>
<td>append </td><td><font face=Kapl>x[,]</font></td>
<td colspan=3 rowspan=2><br></td></tr>
<tr>
<td>replace all</td><td><font face=Kapl>x[]</font></td></tr>
</table><P><BLOCKQUOTE>
<b><A NAME=268>Warning!</b> The forms <font face=Kapl>(f,x)</font>, <font face=Kapl>(f,pØx)</font>, <font face=Kapl>(y f,x)</font>, <font face=Kapl>(y f,pØx)</font>, <font face=Kapl>f{...;,x}</font>, and <font face=Kapl>f{...;,pØx}</font> are accepted, but unless <font face=Kapl>f</font> is Choose (<font face=Kapl>#</font>) the Ravel (<font face=Kapl>,</font>) is ignored!<P>
<A NAME=271>In this <A HREF="#267">table</A>, <font face=Kapl>f</font> denotes either a primitive or a defined function, appropriate to the particular form - or <font face=Kapl>f</font> can be omitted.  <font face=Kapl>x</font>, the <i>target array</i>, denotes a variable name or <font face=Kapl>%y</font> or <font face=Kapl>c%y</font>, where <font face=Kapl>c</font> and <font face=Kapl>y</font> are any expressions producing simple scalar symbols, but <font face=Kapl>x</font><i> cannot </i>denote  <font face=Kapl>%¡v</font> or <font face=Kapl>c%¡v</font>.  The variable named by x is the one that is modified.
</BLOCKQUOTE>
<A NAME=HEADING191>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Primitive Functions in <A NAME=273>Selective Assignment Expressions</FONT></H3>
<BLOCKQUOTE>
Some A+ primitive functions can be used in expressions on the left of the assignment arrow.
 They are:<BR>Take, Drop,<BR>Replicate, Expand,<BR>Ravel, Item Ravel, Reshape,<BR>Rotate,
 Reverse,<BR>Transpose, Transpose Axes.<BR>
(By the way, <font face=Kapl>((j;i)Øa)ûb</font> is a valid Selective Assignment, although
 <font face=Kapl>(iØjØa)ûb</font> is not.)<P>
For a monadic primitive function <font face=Kapl>f</font> in the above list, the form of the specification is, in the simplest case:
<pre></font><font face=Kapl>     (f x)ûa</font></pre>
The definition is as follows: first evaluate
<pre></font><font face=Kapl>      iûf ÉÒx</font></pre>
where <font face=Kapl>x</font> represents a variable name, and then do the Bracket Indexing Selective Assignment:
<pre></font><font face=Kapl>     (,x)[i]ûa</font></pre>
This definition is based on the following facts:<P>
<UL>
<LI>the elements of <font face=Kapl>ÉÒx</font> are exactly all the indices of <font face=Kapl>,x</font>;
<LI>for each monadic primitive <font face=Kapl>f</font> listed above, <font face=Kapl>^/(,f ÉÒx)Å,ÉÒx</font> has the value 1.  That is, all elements of <font face=Kapl>f ÉÒx</font> are valid indices of <font face=Kapl>,x</font>.
</UL>
The definition for a dyadic primitive function is similar.  In this case the right argument <font face=Kapl>x</font> of the primitive function, which must represent a variable name, is the target of the assignment and the left argument <font face=Kapl>y</font> is any array for which <font face=Kapl>y f x</font> is valid.  Then
<pre></font><font face=Kapl>     (y  f  x)ûa</font></pre>
is defined by
<pre></font><font face=Kapl>     iûy f ÉÒx
     (,x)[i]ûa</font></pre>
</BLOCKQUOTE>
<A NAME=HEADING192>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Defined Functions in <A NAME=275>Selective Assignment Expressions</FONT></H3>
<BLOCKQUOTE>
Defined functions can also be used on the left side of the assignment arrow.  The definition is the same as the one above for primitive functions, only now it is up to the programmer to see that the function, when applied to arrays whose values are in <font face=Kapl>Én</font>, produces results whose elements are all members of <font face=Kapl>Én</font>.
</BLOCKQUOTE>
<A NAME=HEADING193>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Brace <A NAME=277>Assignment (<font face=Kapl>{w;y;...;z;x}ûa</font>)</FONT></H3>
<BLOCKQUOTE>
The general form <font face=Kapl>f{w;y;...;z;x}ûa</font> has a syntactic special case, where the function name is not present:
<pre></font><font face=Kapl>{w;y;...;z;x}ûa</font></pre>
is permitted and is equivalent to <font face=Kapl>x[]ûa</font>.  In particular, <font face=Kapl>{x}ûa</font> is equivalent to <font face=Kapl>x[]ûa</font>.
</BLOCKQUOTE>
<A NAME=HEADING194>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Selective Assignment of Objects Bound to Display Classes</FONT></H3>
<BLOCKQUOTE>
See "<A HREF="#26">Assignment of Objects Bound to Display Classes</A>".<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>an error is reported if one of the functions selecting the subarray encounters an error; this includes any defined function, so the report may come from a primitive function within a defined function;
<LI>a type error is reported if the general type of the target differs from the general type of <font face=Kapl>a</font> or if the target is integer but <font face=Kapl>a</font> is floating point and not composed entirely of restricted whole numbers;
<LI>a rank error is reported if the rank of the selected subarray differs from the rank of <font face=Kapl>a</font> and <font face=Kapl>a</font> is not a one-element array;
<LI>a length error is reported if corresponding dimensions of <font face=Kapl>a</font> and the selected subarray differ and <font face=Kapl>a</font> is not a one-element array;
<LI>a maxitems error is reported if an attempt is made to append an item to a mapped file beyond its maximum size as specified by _items (see "<A HREF="APlusRefV2_14.html#108">Items of a Mapped File</A>");
<LI>an invalid error is reported if the target array is bound to a display class and the value it is to be given is not a valid value for (the selected part of) objects bound to that display class;
<LI>an index error is reported if an index not in <font face=Kapl>ÉÒx</font> is generated; the error may not be detected before partial replacement of values has occurred - see the examples.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     vûÉ10
     v[2 2 2]û5 9 ¢1  ã </font>Repeated indices<font face=Kapl>
     v
 0 1 ¢1 3 4 5 6 7 8 9

     mûÉ4 4
     0 0ôm            ã </font>Diagonal<font face=Kapl>
 0 5 10 15


     (0 0ôm)û1 2 3 4  ã </font>Primitive function selection: diagonal.<font face=Kapl>
     m
  1  1  2  3
  4  2  6  7
  8  9  3 11
 12 13 14  4


          ã </font>Display argument, then return last element (to show how<font face=Kapl>
          ã </font>defined functions are called during Selective Assignment):<font face=Kapl>
     last x: ¢1Ù,Õx
     aû3 2Ò'abcdef'
     last a
ab
cd
ef
f


     (last a)û'F'  ã </font>User-defined function selection.<font face=Kapl>
 0 1               ã </font> Argument it was given:<font face=Kapl> ÉÒa</font>,<font face=Kapl> </font>i.e.,<font face=Kapl> É3 2
 2 3
 4 5               ã </font>It returns 5.<font face=Kapl>


     a
ab
cd
eF                 ã </font>The new value <font face=Kapl>'F'</font> was placed at<font face=Kapl> (,a)[5]</font>.<font face=Kapl>


     xû(10;20;(É2 3;'abc'))
     (1;1)#2 0Øx   ã </font>Pick-Choose selection<font face=Kapl>
 4                 ã </font>Present value of selected component<font face=Kapl>


     ((1;1)#2 0Øx)û99   ã </font>Pick-Choose selection for<font face=Kapl>
     x                  ã </font>Selective Assignment, new value 99<font face=Kapl>
 &lt;  10
 &lt;  20
 &lt; &lt;  0  1  2
      3 99  5      ã </font>New value is at the selected location.<font face=Kapl>
   &lt; abc


     f x:x+5       ã </font>User function to manipulate indices<font face=Kapl>
     vûÉ10         ã </font>Variable for Selective Assignment<font face=Kapl>
     (f v)û100+É10 ã </font>Make erroneous Selective Assignment:<font face=Kapl>
 û: index          ã </font>error detected.<font face=Kapl>
*       ý
      v            ã </font>In time?<font face=Kapl>
 0 1 2 3 4 100 101 102 103 104
ã </font>Not quite. Indices up to first incorrect one were used.</pre>
</BLOCKQUOTE><A NAME=HEADING195>
<H2><FONT color="#20B2AA">Separate <A NAME=283>Symbols<font face=Kapl>  Öx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument and result are simple arrays of symbols.  The shape of the result is the same as that of the argument except that a last axis of length 2 has been added; i.e., the result shape is <font face=Kapl>(Òx),2</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Each element of the argument is separated into two symbols, the first coming from whatever precedes the rightmost dot, and the second from whatever follows it; if there is no dot, a leading one is assumed.  Unqualified names and root-context names cannot be distinguished in the result of this function.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     Ö`x `.y `c.z `a.b.d</font></pre>
yields
<pre></font><font face=Kapl> `    `x
 `    `y
 `c   `z
 `a.b `d</font></pre>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
If there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"),<P>
<UL>
<LI>a maxrank error is reported if the rank of the argument is nine.
</UL>
</BLOCKQUOTE><A NAME=HEADING196>
<H2><FONT color="#20B2AA">Shape<font face=Kapl> <A NAME=288> Òx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is any array.  The result is a vector of integers with an element for each axis of the argument.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The shape of a scalar is <font face=Kapl>É0</font> because a scalar has no axes.  For a nonscalar the <font face=Kapl>i</font>th element of the result is the <font face=Kapl>i</font>th dimension of the argument.  That is, if the result is <font face=Kapl>r</font> then <font face=Kapl>r[i]-1</font> is a valid index of the <font face=Kapl>i</font>th axis of <font face=Kapl>x</font>, but <font face=Kapl>r[i]</font> is not.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     Ò 3 4Ò0
 3 4
     Ò 10 20 30 40
 4
     Ò 'The Cat in the Hat'
 18
     Ò 42
              ã </font>This is the display of the empty integer vector.<font face=Kapl>
     Ò É5
 5</font></pre>
</BLOCKQUOTE><A NAME=HEADING197>
<H2><FONT color="#20B2AA">Signal <A NAME=293><font face=Kapl> Ùx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a simple symbol or character array.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The effect during function execution is to signal an error in the current function, display
 the text of the first symbol of <font face=Kapl>x</font> or the ravel of the character array <font face=Kapl>x</font> as
 an error message, and cause a suspension at the statement where the current function was
 called. In protected execution, it returns error code -1. Outside function execution and
 protected execution, it simply aborts execution of the expression, without any message.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Report</b><BLOCKQUOTE>
The following report is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>a domain error is reported if the argument is not a simple symbol or character array.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     f1 a:1+f2{a}
     f2 x:if (x=0) Ù`zero else 2«x
     f1 2
 5
     f1 0
 f2: zero
*     $si
f1 0
.f1: 1+f2{a}
*     a
 0
*     ý</font></pre>
</BLOCKQUOTE><A NAME=HEADING198>
<H2><FONT color="#20B2AA">Solve <A NAME=298><font face=Kapl> y­x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> and <font face=Kapl>y</font> are numeric arrays whose ranks are less than or equal to 2, with <font face=Kapl>#y</font> equal to <font face=Kapl>#x</font>.  The result has shape <font face=Kapl>(1ÕÒx),1ÕÒy</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>y­x</font> equals <font face=Kapl>(­x)+.«y</font>.  If <font face=Kapl>x</font> is a nonsingular matrix with the same number or rows as columns, the result is the solution <font face=Kapl>a</font> to the linear system of equations <font face=Kapl>y</font> equals <font face=Kapl>x+.«a</font>.  If <font face=Kapl>x</font> is a matrix with more rows than columns, and if the columns are linearly independent, the result is the least squares solution <font face=Kapl>a</font> to that linear system of equations.  That is, <font face=Kapl>a</font> is the array for which <font face=Kapl>+/(y-x+.«a)*2</font> has the smallest possible value for each element.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>a rank error is reported if the rank of either argument exceeds 2;
<LI>a domain error is reported if (1) an argument is not a simple numeric array, or (2) an argument is a matrix with more columns than rows, or (3) the right argument is singular or very ill-conditioned.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
Given the following linear system of equations:
<pre></font><font face=Courier>  10 = 3x + 5y -  z
  -3 = 7x - 2y + 4z
   5 =  x +  y + 2z</font></pre>
the solution vector (<font face=Courier>x,y,z</font>) can be determined as follows:
<pre></font><font face=Kapl>     10 ¢3 5 ­ 3 3Ò3 5 ¢1 7 ¢2 4 1 1 2
 ¢.5180722892 2.602409639 1.457831325</font></pre>
</BLOCKQUOTE><A NAME=HEADING199>
<H2><FONT color="#20B2AA">Stop <A NAME=303><font face=Kapl> ^x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array, and its value is the explicit result.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
The value of the system variable <A HREF="APlusRefV2_13.html#76"><font face=Kapl>`stop</font></A>, which is set by the <A HREF="APlusRefV2_15.html#136">Stop</A> command (<font face=Kapl>$stop</font>) and the <A HREF="APlusRefV2_14.html#191">Set System Variable</A> function (<font face=Kapl>_ssv</font>).<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The effect of this function depends on the setting of <font face=Kapl>`stop</font>.  Either the function has no effect (when <font face=Kapl>`stop</font> is <font face=Kapl>0</font>), or it causes execution to halt (when <font face=Kapl>`stop</font> is <font face=Kapl>1</font>), or it causes <font face=Kapl>x</font> to be displayed (when <font face=Kapl>`stop</font> is <font face=Kapl>2</font>). A Stop halt is the same as an error halt, except that it can occur within protected
 execution (<font face=Kapl>â</font> or do).<P>
See "<A HREF="APlusRefV2_63.html#HEADING988">Example of a Defined Function</A>" and,
 immediately following it, "<A HREF="APlusRefV2_63.html#HEADING989">Errors and Stops</A>" in
 the appendix.<p>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     sum{x}:{
      zû0;
      (iûx) do ^zûz+i+1  ã </font>Call Stop function after each "<font face=Kapl>zû</font>".<font face=Kapl>
      z }
     $stop 0             ã </font>No effect.<font face=Kapl>
     sum 3
 6
     $stop 1             ã </font>Actual stop each iteration.<font face=Kapl>
     sum 3
: stop
*     i,z                ã </font>Check <font face=Kapl>i</font> and <font face=Kapl>z.
 0 1
*     û
: stop
*     zûz+10             ã </font>Give <font face=Kapl>z</font> a little boost.<font face=Kapl>
*     û
: stop
*     &amp;0                 ã </font>Check the top of the stack.<font face=Kapl>
 16
*     û
 16                      ã </font>The doctored result.<font face=Kapl>
     $stop 2             ã </font>Display the value each iteration.<font face=Kapl>
     sum 3
 1
 3
 6
 6                       ã </font>The result of<font face=Kapl> sum 3</font>.</pre>
</BLOCKQUOTE><A NAME=HEADING200>
<H2><FONT color="#20B2AA">Take <A NAME=307><font face=Kapl>  yÙx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The argument <font face=Kapl>y</font> is a simple one-element array whose value is a restricted whole number, and <font face=Kapl>x</font> is any array.  A scalar <font face=Kapl>x</font> is treated as a one-element vector.  The shape of the result equals the shape of the right argument <font face=Kapl>x</font> for all but the first axis, while the first dimension is the absolute value of <font face=Kapl>y</font>.  <P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
There are four cases for Take, depending on whether or not <font face=Kapl>y</font> is nonnegative, and whether or not <font face=Kapl>|y</font> is less than or equal to <font face=Kapl>#x</font>.  The result always has <font face=Kapl>|y</font> items.  The two cases when <font face=Kapl>|y</font> is less than or equal to <font face=Kapl>#x</font> are the most straightforward: the result consists of the first <font face=Kapl>y</font> items of <font face=Kapl>x</font> if <font face=Kapl>y</font> is nonnegative, and the last <font face=Kapl>-y</font> items if <font face=Kapl>y</font> is negative.  See the first two examples.<P>
In the two cases where <font face=Kapl>|y</font> is greater than <font face=Kapl>#x,</font> the difference <font face=Kapl>(|y)-#x</font> represents the number of excess items in the result .  These excess items consist entirely of <i>fill elements</i> (see the "<A HREF="#310">Fill Elements</A>" table).  Let <font face=Kapl>F</font> be the array of excess items.  The shape of <font face=Kapl>F</font> equals the shape of <font face=Kapl>x</font> along all but the first axis, while the length of the first axis is <font face=Kapl>(|y)-#x</font>.  The result is the catenation <font face=Kapl>x,F</font> if <font face=Kapl>y</font> is nonnegative, and <font face=Kapl>F,x</font> if <font face=Kapl>y</font> is negative.  See the last two examples.<P>
<A NAME=HEADING201>
<table border=1 cellspacing=0 cellpadding=8>
<caption><FONT color="#20B2AA" size=+2><B>
Fill<A NAME=310> Elements</B></FONT></caption>
<tr>
<th>General type of right argument</th><th>Fill element</th></tr>
<tr>
<td>numeric</td><td><font face=Kapl>0</font></td></tr>
<tr>
<td>character</td><td>blank</td></tr>
<tr>
<td>symbol</td><td>the empty symbol</td></tr>
<tr>
<td>nested</td><td>enclosed Null</td></tr>
</table><P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"), and nonce only if there is no type error:<P>
<UL>
<LI>a type error is reported if the left argument is nested or is not all restricted whole numbers;
<LI>a nonce error is reported if the left argument has more than one element.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     3ÙÉ5 2
 0 1
 2 3
 4 5
     ¢3ÙÉ5 2
 4 5
 6 7
 8 9
     5Ù10 20 30
 10 20 30 0 0
     ¢5Ù10 20 30
 0 0 10 20 30
     5Ù`a`b`c
 `a `b `c ` `</font></pre>
</BLOCKQUOTE><A NAME=HEADING202>
<H2><FONT color="#20B2AA">Transpose <A NAME=313><font face=Kapl>  ôx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array.  The shape of the result is the reverse of the shape of <font face=Kapl>x</font>, i.e., <font face=Kapl>÷Òx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is <font face=Kapl>x</font> with its axes reversed.  In particular, if <font face=Kapl>x</font> is a matrix then its rows become the columns of the result, and its columns become the rows.  More generally, for any <font face=Kapl>x</font> and any nested vector of simple vectors <font face=Kapl>y</font> for which <font face=Kapl>y#x</font> is valid
<pre></font><font face=Kapl>y#x ûý ô(÷y)#ôx</font></pre>
If <font face=Kapl>y</font> selects a scalar, then the equivalence is simply<font face=Kapl> y#x ûý (÷y)#ôx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     ôÉ2 3
 0 3
 1 4
 2 5</font></pre>
</BLOCKQUOTE><A NAME=HEADING203>
<H2><FONT color="#20B2AA">Transpose Axes<A NAME=317><font face=Kapl>  yôx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is any array.<font face=Kapl> y </font>is a simple vector of restricted whole numbers whose
 length equals the rank of<font face=Kapl> x</font>, i.e.,<font face=Kapl> Òy </font>equals<font face=Kapl> ÒÒx </font> (unless<font face=Kapl>
 y </font>is a scalar, which is treated as a one-element vector, yielding the uninteresting
 case<font face=Kapl> 0ôx ûý x </font>for vector<font face=Kapl> x</font>).  The rank of the result is equal to the
 number of distinct elements in<font face=Kapl> y</font>, so it is equal to or less than the rank of<font face=Kapl>
 x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is <font face=Kapl>x</font> with its axes permuted and coalesced according to<font face=Kapl> y</font>.
 The elements of<font face=Kapl> y </font>must all be in<font face=Kapl> ÉÒÒr</font>, where<font face=Kapl> r </font>denotes the
 result, and no element of<font face=Kapl> ÉÒÒr </font>can be missing from<font face=Kapl> y</font>.  The elements of<font face=Kapl>
 y </font>specify where in the result the corresponding axes of<font face=Kapl> x </font>appear. For
 instance, if<font face=Kapl> x </font>has three axes and<font face=Kapl> y[1] </font>equals 2, then axis 1 of <font face=Kapl>x</font>
 becomes axis 2 in the result.  See the first example. If<font face=Kapl> y </font>contains duplicates,
 then, for each set of duplicates, the corresponding axes in<font face=Kapl> x </font>are coalesced into
 one axis in the result, and the length of the resulting axis is the least of the lengths of
 the coalesced axes.  In particular, if<font face=Kapl> x </font> is a matrix then<font face=Kapl> 0 0ôx </font>is the
 diagonal of<font face=Kapl> x</font>.  See the second and third examples.<P>
In terms of indices, if <font face=Kapl>i</font> is a vector of indices which selects an element of <font face=Kapl>x</font>, then there are two possibilities.  (1) For some set of coalesced axes, the corresponding elements of <font face=Kapl>i</font> are different.  Then the indexed element of <font face=Kapl>x</font> is not in <font face=Kapl>yôx</font>.  (2) The element is in <font face=Kapl>yôx</font> and its indices there are <font face=Kapl>i[yÉÉÒÒyôx]</font> (using, for each set of coalesced axes, the index for the first axis in the set, as an arbitrary choice).<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
Each of the following reports is issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>") and none of the reports preceding it on this list applies:<P>
<UL>
<LI>a type error is reported if the left argument is nested or does not consist of restricted whole numbers;
<LI>a rank error is reported if the left argument is not a scalar or vector, or if its length is unequal to the rank of the right argument;
<LI>a domain error is reported if the left argument contains a negative number or does not contain <i>all</i> the restricted whole numbers between zero and its largest element, inclusive, possibly with duplications.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     0 2 1ôÉ2 3 4
  0  4  8
  1  5  9
  2  6 10
  3  7 11

 12 16 20
 13 17 21
 14 18 22
 15 19 23
     0 0ôÉ2 3
 0 4
     1 0 0ôÉ2 3 4
  0 12
  5 17
 10 22</font></pre>
</BLOCKQUOTE><A NAME=HEADING204>
<H2><FONT color="#20B2AA">Type <A NAME=322><font face=Kapl> ©x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
The argument is any array; if the argument is a function expression it must be in braces.  The result is a symbol scalar.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is the type of the first item of the argument, represented as a symbol.  The types are:<P>
character, integer, floating point, null, symbol, function, and box<BR>(<font face=Kapl>`char</font>,<font face=Kapl> `int</font>,<font face=Kapl> `float</font>,<font face=Kapl> `null</font>,<font face=Kapl> `sym</font>,<font face=Kapl> `func</font>, and <font face=Kapl>`box</font>, respectively).<P>
Symbol, function, and box items can be mixed in a single array.  See the last three examples in the set that follows.  There is also a type included to provide for possible weird cases; its symbol is <font face=Kapl>`unknown</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     ©'a'
 `char
     ©42
 `int
     ©4.2
 `float
     ©`a
 `sym
     ©{+} ã </font>The parser needs the braces as a hint when a <i>function</i> is an argument.<font face=Kapl>
 `func
     ©&lt;{+}
 `func    ã </font>Function scalar and function expression are both type <font face=Kapl>`func</font>.<font face=Kapl>
     ©()
 `null
     ©&lt;'a'
 `box
     ©`a,(&lt;1251),&lt;{+}
 `sym
     ©(&lt;1251),(&lt;{+}),`a
 `box
     (&lt;{+}),`a,&lt;1251
 `func</font></pre>
</BLOCKQUOTE><A NAME=HEADING205>
<H2><FONT color="#20B2AA">Unpack <A NAME=327><font face=Kapl> Îx</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a simple array composed entirely of symbols.  The result <font face=Kapl>r</font> is a simple character array whose shape along all axes except the last is <font face=Kapl>Òx</font>.  I.e., <font face=Kapl>¢1ÕÒr</font> is <font face=Kapl>Òx</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A HREF="#185">Pack</A> is the left inverse of Unpack.  That is, for any array <font face=Kapl>x</font> composed entirely of symbols, <font face=Kapl>ÂÎx</font> equals <font face=Kapl>x</font>.  The result has one more axis than <font face=Kapl>x</font>, the last.  Each character vector along the last axis of the result consists of the characters - except for the leading backquote - in the display of the corresponding symbol of <font face=Kapl>x</font>, perhaps padded with blanks on the end.  The last dimension of the result is the largest number of characters in any of these vectors, before padding.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse or value error (see "<A HREF="#4">Common Error Reports</A>"):<P>
<UL>
<LI>a maxrank error is reported if the rank of the result would be greater than nine;
<LI>a type error is reported if the argument is not a simple array of symbols.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Example</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     Î`a `abc
a
abc</font></pre>
</BLOCKQUOTE><A NAME=HEADING206>
<H2><FONT color="#20B2AA">Value <A NAME=331><font face=Kapl> %x</FONT></FONT></H2>
</font><b>&nbsp;&nbsp;&nbsp;Argument and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> is a scalar symbol that contains a user global name (see "<A HREF="APlusRefV2_5.html#9">User Names</A>" and "<A HREF="APlusRefV2_5.html#49">Symbols and Symbol Constants</A>").  The result is an array or a function.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<A NAME=333>If the name in the symbol <font face=Kapl>x</font> is not qualified by a context name, then the current context is assumed.  If it is so qualified, the designated context is assumed.  For example, <font face=Kapl>`v.a</font> refers to <font face=Kapl>a</font> in the context <font face=Kapl>v</font>, <font face=Kapl>`.a</font> refers to <font face=Kapl>a</font> in the root context, and <font face=Kapl>`a</font> refers to <font face=Kapl>a</font> in the current context.  See the example with the function <font face=Kapl>f</font> below.<P>
There are two cases.  If the thing named by the symbol <font face=Kapl>x</font> is a <i>global variable</i>, the result is the value of that variable.  If the thing is a <i>defined function</i> (not a primitive function, because a primitive function does not have a user name), then the result is that function: if <font face=Kapl>%x</font> occurs bare, the function definition will be displayed; if it occurs with argument(s) the function will be executed, <i>provided general function form is used</i>, with those arguments in braces.<P>
<A NAME=335>Unlike <A HREF="#105">Execute</A>, Value can be used on the left of Assignment to set the value of a global variable.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse error (see "<A HREF="#4">Common Error Reports</A>").  A value error report (another of the common error reports) can happen here because either <font face=Kapl>Îx</font> is not a user name or it lacks a <i>global</i> value.  A value error will be reported only if there is no type or rank error.<P>
<UL>
<LI>A type error is reported if the type of <font face=Kapl>x</font> is not symbol.
<LI>A rank error is reported if <font face=Kapl>x</font> is not a scalar.
<LI>If <font face=Kapl>x</font> names a defined function, any further errors will be reported for that function.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl>     sq x:x*2
     fû`sq
     xû11 12 13
     aû`x
     %f
sq x:x*2
     (%f){%a}
 121 144 169
     aûÉ4
     %`a
 0 1 2 3
     (%`a)û'new'   ã </font>Value can be used on the left of Assignment.<font face=Kapl>
     a
new
     %`q           ã q</font> has no value.<font face=Kapl>
 .q: value
*      ý
     f x:{
       aûx;        ã </font>Set local <font face=Kapl>a
       Õa;         ã </font>Display local <font face=Kapl>a
       Õ%`a;       ã </font>Display global <font face=Kapl>a</font>, current context.<font face=Kapl>
       Õ%`.a; }    ã </font>Display global <font face=Kapl>a</font>, root context.<font face=Kapl>
     aû1 2 3
     f 5
 5
 1 2 3             ã </font>The current context is the root context.<font face=Kapl>
 1 2 3
     $cx cc        ã </font>Set a new context.<font face=Kapl>
     aû4 5 6       ã </font>Set <font face=Kapl>a</font> in the new context, <font face=Kapl>cc.a
     f 5
 5                 ã </font>The local <font face=Kapl>a
 4 5 6             ã </font>The value in the current context, <font face=Kapl>cc
 1 2 3             ã </font>The value in the root context.</pre>
</BLOCKQUOTE><A NAME=HEADING207>
<H2><FONT color="#20B2AA">Value <A NAME=339>in Context<font face=Kapl>  y%x</font></font></h2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
<font face=Kapl>x</font> and <font face=Kapl>y</font> are scalar symbols such that <font face=Kapl>yÖx</font> is a symbol containing a user global name (see "<A HREF="APlusRefV2_5.html#9">User Names</A>" and "<A HREF="APlusRefV2_5.html#49">Symbols and Symbol Constants</A>").  The result is an array or a function.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
Value in Context generates the name it uses in one of two ways:<P>
<UL>
<LI><A NAME=340>if the name represented by the symbol <font face=Kapl>x</font> does not specify a context, then <font face=Kapl>y%x</font> qualifies it by the context named by the symbol <font face=Kapl>y</font>.  For example, <font face=Kapl>`ctx%`a</font> uses the name <font face=Kapl>ctx.a</font>;
<LI>otherwise, the name represented by <font face=Kapl>x</font> specifies a context, as in <font face=Kapl>`ctx.a</font>, and <font face=Kapl>y%x</font> uses that name, and ignores the value of the symbol <font face=Kapl>y</font>. For example, <font face=Kapl>`any%`ctx.a</font> uses <font face=Kapl>ctx.a</font>.
</UL>
The root context is represented by <font face=Kapl>`</font> (the blank or empty symbol: just backquote alone).<P>
There are two cases.  If the thing named by <font face=Kapl>y</font> and <font face=Kapl>x</font> is a <i>global variable</i>, the result is the value of that variable.  If the thing is a <i>defined function</i> (not a primitive function, because a primitive function does not have a user name), then the result is that function: if <font face=Kapl>y%x</font> occurs bare, the function definition will be displayed; if it occurs with argument(s) the function will be executed, <i>provided general function form is used</i>, with those arguments in braces.<P>
<A NAME=342>Unlike <A HREF="#105">Execute</A>, Value in Context can be used on the left of assignment to specify the value of a global variable in a context.  And unlike Execute in Context, Value in Context in effect constructs a qualified name and then evaluates it.  Within a defined function or operator, <font face=Kapl>`cxt%`x</font> always refers to the global variable <font face=Kapl>cxt.x</font>, whereas <font face=Kapl>`cxtâ'x'</font> refers to the local variable <font face=Kapl>x</font> if there is one, and only if there is no such local variable does it refer to <font face=Kapl>cxt.x</font>.<P>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Additional Error Reports</b><BLOCKQUOTE>
The following reports are issued only if there is no parse error (see "<A HREF="#4">Common Error Reports</A>").  A value error report (another of the common error reports) can happen here because either <font face=Kapl>x</font> and <font face=Kapl>y</font> do not define a user name or the name they produce lacks a <i>global</i> value.  A value error will be reported only if there is no type or rank error.  An error report for <font face=Kapl>x</font> is preferred to an error report for <font face=Kapl>y</font>.<P>
<UL>
<LI>A type error report indicates that the type of <font face=Kapl>x</font> or <font face=Kapl>y</font> is not symbol.
<LI>A rank error report indicates that <font face=Kapl>x</font> or <font face=Kapl>y</font> is not a scalar.
<LI>If a defined function is named by <font face=Kapl>y</font> and <font face=Kapl>x</font>, any further errors will be reported for that function.
</UL>
</BLOCKQUOTE><b>&nbsp;&nbsp;&nbsp;Examples</b><BLOCKQUOTE>
<pre></font><font face=Kapl><A NAME=343>     my.aûÉ4
     cxû`my
     vû`a
     cx%v                 ã </font>Value of <font face=Kapl>a</font> in the context <font face=Kapl>my
 0 1 2 3
     `anything%`my.a      ã `anything</font> is ignored.<font face=Kapl>
 0 1 2 3
     xû30 40
     $cx your
     `%`x                 ã </font>Value of <font face=Kapl>x</font> in the context.<font face=Kapl>
 30 40
     cx%`x                ã </font>The value of <font face=Kapl>cx</font> is <font face=Kapl>my
 my.x: value
*     ý
     my.aûÉ4
     (cx%v)û'new'
     my.a
new</font></pre>
</BLOCKQUOTE>
<P>
<HR>
<ADDRESS><table width="100%"><tr><td><font size=2><i><a href="mailto:doc@aplusdev.org">doc@aplusdev.org</a></i></font></td><td align=right><font size=2><i>&#169; Copyright 1995&#150;2008 Morgan Stanley Dean Witter &amp; Co.  All rights reserved.</i></font></td></tr></table></ADDRESS>
</BODY>
</HTML>
