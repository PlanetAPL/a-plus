<HTML>
<HEAD>
<TITLE>A+ Reference: The b Context</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME=HEADING656>
<H1><FONT color="#FF0000"><A NAME=0>The b Context</FONT></H1>
<a name="CONTENTS54">
<UL>
<A HREF="#HEADING657"> Sorted Arguments to the b-Context Functions</A><BR>
<A HREF="#HEADING658"> Uniform Frames and Comparable Cells</A><BR>
<A HREF="#HEADING659"> Definitions of b-Context Functions</A><BR>
<UL>
<A HREF="#HEADING660"> Binary End</A><font face=Kapl> b.e{y;x}</font><BR>
<A HREF="#HEADING661"> Binary End, with Permutation</A><font face=Kapl> b.pe{y;p;x}</font><BR>
<A HREF="#HEADING662"> Binary Greater than or Equal to</A><font face=Kapl> b.ge{y;x}</font><BR>
<A HREF="#HEADING663"> Binary Greater than or Equal to, with Permutation</A><font face=Kapl> b.pge{y;p;x}</font><BR>
<A HREF="#HEADING664"> Binary Iota</A><font face=Kapl> b.i{y;x}</font><BR>
<A HREF="#HEADING665"> Binary Iota, with Permutation</A><font face=Kapl> b.p{y;p;x}</font><BR>
<A HREF="#HEADING666"> Binary Less than or Equal to</A><font face=Kapl> b.le{y;x}</font><BR>
<A HREF="#HEADING667"> Binary Less than or Equal to, with Permutation</A><font face=Kapl> b.ple{y;p;x}</font><BR>
<A HREF="#HEADING668"> Binary Range</A><font face=Kapl> b.r{y;x}</font><BR>
<A HREF="#HEADING669"> Binary Range, with Permutation</A><font face=Kapl> b.pr{y;p;x}</font><BR>
<A HREF="#HEADING670"> Binary Unique</A><font face=Kapl> b.u{y;x}</font><BR>
</UL>
</UL>
<HR>
<blockquote>
The b context is native to A+.  It is not to be loaded.
</blockquote>
<A NAME=HEADING657>
<H1><FONT color="#20B2AA">Sorted <A NAME=1>Arguments to the b-Context Functions</FONT></H1>
<blockquote>
<A NAME=2>The definitions of the b context functions refer to sorted arrays, or to permutation vectors that will reorder arrays in sorted order.  If the array is simple, i.e., of depth 0, then sorted order means that the items are in nondescending, lexicographic order, which is described in the definition of <A HREF="APlusRefV2_8.html#142">Grade up</A>.  A permutation vector that puts a simple array in sorted order is therefore one that rearranges the items into nondescending, lexicographic order.<P>
Nested scalars and vectors of depth 1 can also be in sorted order.  In the case of a scalar <font face=Kapl>a</font>, this means that <font face=Kapl>&gt;a</font> is in sorted order, while for a one-element vector <font face=Kapl>a</font>, it means that <font face=Kapl>0Øa</font> is in sorted order.  A nested vector <font face=Kapl>a</font> with two or more elements is said to be in sorted order if it is ordered like a dictionary with the items of <font face=Kapl>0Øa</font> corresponding to the first letter of words, the items of <font face=Kapl>1Øa</font> corresponding to the second letter, and so on.  That is, the items of <font face=Kapl>0Øa</font> are in sorted order; if <font face=Kapl>i</font> is any simple integer vector in increasing order for which the items of <font face=Kapl>i#0Øa</font> are identical, then <font face=Kapl>i#1Øa</font> is in sorted order; and so on.<P>
For example, if
<pre><font face=Kapl>     cû3 5Ò'blue blue green'
     nû10 20 5</font></pre>
then <font face=Kapl>c</font> is sorted, <font face=Kapl>n</font> is not sorted, but the nested pair <font face=Kapl>(c;n)</font> is sorted.
</blockquote>
<A NAME=HEADING658>
<H1><FONT color="#20B2AA">Uniform Frames and <A NAME=5>Comparable Cells</FONT></H1>
<blockquote>
Two simple arrays <font face=Kapl>a</font> and <font face=Kapl>b</font> are said to have <i>comparable </i><font face=Kapl>n</font><i>-cells</i> if their <font face=Kapl>n</font>-cells have the same shape, i.e., <BR><font face=Kapl>(-n)ÙÒa</font> equals <font face=Kapl>(-n)ÙÒb</font>.  If <font face=Kapl>a</font> has rank k then the items of <font face=Kapl>a</font> are (k-1)-cells.  The array <font face=Kapl>b</font> is said to have <i>cells comparable to the items of</i> <font face=Kapl>a</font> if <font face=Kapl>a</font> and <font face=Kapl>b</font> have comparable (k-1) cells.  For example, the right argument of the primitive function Find has cells comparable to the items of the left argument.<P>
If <font face=Kapl>a</font> and <font face=Kapl>b</font> are nested scalars of depth 1 then they are said to have comparable n-cells if <font face=Kapl>&gt;a</font> and <font face=Kapl>&gt;b</font> have comparable n-cells, and analogously, <font face=Kapl>b</font> is said to have cells comparable to the items of <font face=Kapl>a</font> if this is true of <font face=Kapl>&gt;a</font> and <font face=Kapl>&gt;b</font>.  If <font face=Kapl>a</font> and <font face=Kapl>b</font> are nested vectors of depth 1, then they are said to have comparable n-cells if for every valid scalar index <font face=Kapl>i</font> of both <font face=Kapl>a</font> and <font face=Kapl>b</font>, the simple arrays <font face=Kapl>iØa</font> and <font face=Kapl>iØb</font> have comparable n-cells, and analogously for <font face=Kapl>b</font> having cells comparable to the items of <font face=Kapl>a</font>.  In particular, <font face=Kapl>a</font> and <font face=Kapl>b</font> do not have to be of the same length.<P>
<A NAME=7>Suppose <font face=Kapl>a</font> and <font face=Kapl>b</font> are nested vectors and <font face=Kapl>b</font> has cells comparable to the items of <font face=Kapl>a</font>.  Then for every valid scalar index <font face=Kapl>i</font>, if <font face=Kapl>r</font> is the rank of <font face=Kapl>iØa</font>, then the (<font face=Kapl>r-1</font>)-cells of <font face=Kapl>iØb</font> have the same shape as the items of <font face=Kapl>iØa</font>.  Note that <font face=Kapl>r</font> may vary with <font face=Kapl>i</font>.  The complementary frame of <font face=Kapl>b</font> has shape <font face=Kapl>(-r-1)ÕÒb</font>.  If all the complementary frames for all <font face=Kapl>i</font> are equal, <font face=Kapl>b</font> is said to have <i>uniform complementary frames</i>.  Similarly, if all the counts <font face=Kapl>#iØa</font> are the same for all <font face=Kapl>i</font>, then <font face=Kapl>a</font> is said to have <i>uniform counts</i>.<P>
For example, if
<pre><font face=Kapl>     cû3 5Ò'blue greengreen'
     nû10 20 15
     dû2 2 5Ò'greenblue red  green'
     mû2 2Ò5 10 25 15</font></pre>
then the nested pair <font face=Kapl>(d;m)</font> has cells comparable to the items of the nested pair <font face=Kapl>(c;n)</font> and uniform complementary frames (the 2-frames of <font face=Kapl>d</font> and <font face=Kapl>m</font>), while <font face=Kapl>(c;n)</font> has uniform counts.
</blockquote>
<A NAME=HEADING659>
<H1><FONT color="#20B2AA">Definitions of b-Context Functions</FONT></H1>
<A NAME=HEADING660>
<H2><FONT color="#20B2AA">Binary <A NAME=11>End<font face=Kapl>  b.e{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
See <A HREF="#19">Binary Iota</A>, <font face=Kapl>b.i{y;x}</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>b.e</font> differs from <font face=Kapl>b.i</font> in only one way: the elements of the result are last occurrences instead of first.  That is, each element <font face=Kapl>n</font> in the result corresponds to a cell or cross section of <font face=Kapl>x</font>, and the value <font face=Kapl>n</font> is the largest index for which the <font face=Kapl>n</font>th item or cross section of <font face=Kapl>y</font> is identical to the corresponding cell or cross section of <font face=Kapl>x</font>.  If there is no such item or cross section of <font face=Kapl>y</font>, then <font face=Kapl>n</font> is the number of items (<font face=Kapl>#y</font>) or cross sections (<font face=Kapl>#0Ø,y</font>) of <font face=Kapl>y</font>.</BLOCKQUOTE><P>
<A NAME=HEADING661>
<H2><FONT color="#20B2AA">Binary <A NAME=13>End, with Permutation<font face=Kapl>  b.pe{y;p;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
See <A HREF="#21">Binary Iota, with Permutation</A>, <font face=Kapl>b.p{y;p;x}</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>b.pe{y;p;x</font>} is to <font face=Kapl>b.e{y;x}</font> as <font face=Kapl>b.p{y;p;x}</font> is to <font face=Kapl>b.i{y;x}</font>.  See <A HREF="#11">Binary End</A>; <A HREF="#21">Binary Iota, with Permutation</A>; and <A HREF="#19">Binary Iota</A>.</BLOCKQUOTE><P>
<A NAME=HEADING662>
<H2><FONT color="#20B2AA">Binary <A NAME=15>Greater than or Equal to<font face=Kapl>  b.ge{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
See <A HREF="#19">Binary Iota</A>, <font face=Kapl>b.i{y;x}</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The definition of <font face=Kapl>b.i{y;x}</font> is based on comparing whether or not subarrays or cross sections of <font face=Kapl>x</font> and <font face=Kapl>y</font> are identical, depending on whether <font face=Kapl>x</font> and <font face=Kapl>y</font> are simple or nested arrays.  The definition of <font face=Kapl>b.ge{y;x}</font> is exactly the same, except that the comparison function is not "identical to", but "greater than or equal to".  That is, in comparing two simple subarrays <font face=Kapl>b</font> and <font face=Kapl>a</font> of <font face=Kapl>y</font> and <font face=Kapl>x</font>, respectively, <font face=Kapl>a</font> is said to be greater than or equal to <font face=Kapl>b</font> if <font face=Kapl>a</font> does not come before <font face=Kapl>b</font> in lexicographic order.  In the case where <font face=Kapl>a</font> and <font face=Kapl>b</font> are cross sections of the nested arrays <font face=Kapl>x</font> and <font face=Kapl>y</font>, respectively, <font face=Kapl>a</font> is said to be greater than or equal to <font face=Kapl>b</font> if for every valid scalar index <font face=Kapl>j</font>, the simple array <font face=Kapl>jØ,a</font> is greater than or equal to the simple array <font face=Kapl>jØ,b</font> (the ravels of <font face=Kapl>a</font> and <font face=Kapl>b </font>are used to include the case where they are scalars).<P>
Note that when <font face=Kapl>x</font> and <font face=Kapl>y</font> are simple, the definition of <font face=Kapl>b.ge{y;x}</font> is identical to the definition of the primitive Bins function, <font face=Kapl>yèx</font>, except that for <font face=Kapl>b.ge</font>, comparison tolerance is used when <font face=Kapl>x</font> and <font face=Kapl>y</font> are floating-point arrays.</BLOCKQUOTE><P>
<A NAME=HEADING663>
<H2><FONT color="#20B2AA">Binary <A NAME=17>Greater than or Equal to, with Permutation<font face=Kapl>  b.pge{y;p;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
See <A HREF="#21">Binary Iota, with Permutation</A>, <font face=Kapl>b.p{y;p;x}</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>b.pge{y;p;x</font>} is to <font face=Kapl>b.ge{y;x}</font> as <font face=Kapl>b.p{y;p;x}</font> is to <font face=Kapl>b.i{y;x}</font>.  See <A HREF="#15">Binary Greater than or Equal to</A>; <A HREF="#21">Binary Iota, with Permutation</A>; and <A HREF="#19">Binary Iota</A>.</BLOCKQUOTE><P>
<A NAME=HEADING664>
<H2><FONT color="#20B2AA">Binary <A NAME=19>Iota<font face=Kapl>  b.i{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
Both arguments <font face=Kapl>x</font> and <font face=Kapl>y</font> must be of the same type, one of character, integer, floating point, and boxed.  The result is an integer array.  If both are nested, then they must be scalars or vectors of depth 1.<P>
In addition, <font face=Kapl>x</font> must have cells comparable to the items of <font face=Kapl>y</font>.  If <font face=Kapl>x</font> and <font face=Kapl>y</font> are nested then <font face=Kapl>x</font> must have uniform complementary frames, <font face=Kapl>y</font> must be of uniform count (see "<A HREF="#5">Uniform Frames and Comparable Cells</A>"), and <font face=Kapl>y</font> must be sorted (see "<A HREF="#1">Sorted Arguments to the b-Context Functions</A>").  The shape of the result is the common value of the shapes of the complementary frames of <font face=Kapl>x</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
When <font face=Kapl>x</font> and <font face=Kapl>y</font> are simple arrays, the definition of <font face=Kapl>b.i{y;x}</font> is identical to the definition of <A HREF="APlusRefV2_8.html#125">Find</A>, <font face=Kapl>yÉx</font>, except that in the case of <font face=Kapl>b.i</font>, the items of the left argument <font face=Kapl>y</font> must be in nondescending lexicographic order.<P>
When <font face=Kapl>y</font> is a nested array, its contents are best viewed as fields in a database.  Let <font face=Kapl>j</font> be any valid index of both <font face=Kapl>,x</font> and <font face=Kapl>,y</font>.  From the database viewpoint, the disclosed element <font face=Kapl>jØ,y</font> is a field and its items <font face=Kapl>(jØ,y)[k]</font> are records in that field.  Cross sections of records <font face=Kapl>k#¡,y</font> can be formed for scalar indices <font face=Kapl>k</font>.  Since all fields <font face=Kapl>jØ,y</font> have the same number of items, every record is in some cross section.<P>
According to the requirements on nested <font face=Kapl>x</font> and <font face=Kapl>y</font>, the cells in <font face=Kapl>jØ,x</font> of rank <font face=Kapl>0Ó(ÒÒjØ,y)-1</font> can also be viewed as records in the field <font face=Kapl>jØ,y</font>.  The corresponding frames for all <font face=Kapl>jØ,x</font> have the same shape, and so cross sections of records <font face=Kapl>(&lt;l)#¡,x</font> can also be formed for <font face=Kapl>x</font>.  <P>
For every cross section <font face=Kapl>(&lt;l)#¡,x</font> there is a corresponding element <font face=Kapl>n</font> of the result, which is the smallest index for which that cross section is identical to the cross section <font face=Kapl>(#x)Ùn#¡,y</font>.  If there is no such index, then <font face=Kapl>n</font> is the number of cross sections in <font face=Kapl>y</font>, i.e., <font face=Kapl>0Ø,y</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Example</b>
<BLOCKQUOTE>
<pre><font face=Kapl>     cû3 5Ò'blue greengreen'
     nû15 10 20
     yû(c;n)
     dû2 2 5Ò'greenblue red  green'
     mû2 2Ò5 10 25 15
     xû(d;m)
     b.i{c;d}
 1 0
 3 1
     b.i{n;m}
 3 3
 2 1</font></pre>
In the last evaluation the left argument <font face=Kapl>n</font> is not sorted, and the result is not what we expect.  The permutation<font face=Kapl> 1 0 2 </font>will put <font face=Kapl>n</font> in sort order.  We can evaluate<font face=Kapl> b.i{1 0 2#n;m}</font>, or equivalently<font face=Kapl> b.p{n;1 0 2;m}</font>:
<pre><font face=Kapl>     b.p{n;1 0 2;m}
 3 1
 2 0</font></pre>
Even though <font face=Kapl>n</font> is not sorted, <font face=Kapl>(c;n)</font> is:
<pre><font face=Kapl>     b.i{y;x}
 3 0
 3 1</font></pre>
</BLOCKQUOTE>
<A NAME=HEADING665>
<H2><FONT color="#20B2AA">Binary <A NAME=21>Iota, with Permutation<font face=Kapl>  b.p{y;p;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b>
<BLOCKQUOTE>
The arguments <font face=Kapl>y</font> and <font face=Kapl>x</font>, and the result, are as described for Binary Iota, <font face=Kapl>b.i</font>.  The argument <font face=Kapl>p</font> is a vector of nonnegative, nonrepeating integers.
</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The purpose of this function is to provide the advantages of <font face=Kapl>b.i</font> in the cases when a potential left argument to <font face=Kapl>b.i</font> is too large to reorder into nondescending order, as is the case with many mapped files.<P>
If <font face=Kapl>x</font> and <font face=Kapl>y</font> are simple arrays, then the argument <font face=Kapl>p</font> is a vector of indices of the items of <font face=Kapl>y</font> such that the elements of <font face=Kapl>p#y</font> are in nondecreasing, lexicographic order.  The number of elements in <font face=Kapl>p</font> is not necessarily equal to the number of items of <font face=Kapl>y</font>.  The expression <font face=Kapl>b.p{y;p;x</font>} is formally equivalent to <font face=Kapl>b.i{p#y;x</font>}, but the permuted array <font face=Kapl>p#y</font> is never actually formed.<P>
If <font face=Kapl>x</font> and <font face=Kapl>y</font> are nested arrays then for every valid index <font face=Kapl>j</font> of <font face=Kapl>,x</font> and <font face=Kapl>,y</font>, the argument <font face=Kapl>w</font> is a vector of indices of the items of <font face=Kapl>jØ,y</font> such that the elements of <font face=Kapl>w#jØ,y</font> are in nondecreasing, lexicographic order.  <font face=Kapl>b.p{y;p;x;</font>} is formally equivalent to <font face=Kapl>b.i{z;x</font>}, where
<pre><font face=Kapl>     zûy
     z[É#x]û(&lt;p)#¡z[É#x]</font></pre>
but <font face=Kapl>z</font> is never actually formed.</BLOCKQUOTE><P>
<A NAME=HEADING666>
<H2><FONT color="#20B2AA">Binary <A NAME=23>Less than or Equal to<font face=Kapl>  b.le{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
See <A HREF="#19">Binary Iota</A>, <font face=Kapl>b.i{y;x}</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.
</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b>
<BLOCKQUOTE>
<font face=Kapl>b.le</font> differs from <font face=Kapl>b.ge</font> in only two ways: the comparisons are made with "less than or equal to" instead of "greater than or equal to", and the elements of the result are last occurrences instead of first.<P>
That is, in comparing two simple subarrays <font face=Kapl>b</font> and <font face=Kapl>a</font> of <font face=Kapl>y</font> and <font face=Kapl>x</font>, respectively, <font face=Kapl>a</font> is said to be less than or equal to <font face=Kapl>b</font> if <font face=Kapl>a</font> does not come after <font face=Kapl>b</font> in lexicographic order.  In the case where <font face=Kapl>a</font> and <font face=Kapl>b</font> are cross sections of the nested arrays <font face=Kapl>x</font> and <font face=Kapl>y</font>, respectively, <font face=Kapl>a</font> is said to be less than or equal to <font face=Kapl>b</font> if for each valid index <font face=Kapl>j</font>, the simple array <font face=Kapl>jØ,a</font> is less than or equal to the simple array <font face=Kapl>jØ,b</font> (the ravels of <font face=Kapl>a</font> and <font face=Kapl>b </font>are used to include the case where they are scalars).<P>
Secondly, each element <font face=Kapl>n</font> in the result is the largest index for which the <font face=Kapl>n</font>th item or cross section of <font face=Kapl>y</font> is less than or equal to the corresponding cell or cross section of <font face=Kapl>x</font>.  If there is no such item or cross section of <font face=Kapl>y</font>, then <font face=Kapl>n</font> is the number of items (i.e., <font face=Kapl>#y</font>) or cross sections of <font face=Kapl>y</font>.
</BLOCKQUOTE>
<A NAME=HEADING667>
<H2><FONT color="#20B2AA">Binary <A NAME=25>Less than or Equal to, with Permutation<font face=Kapl>  b.ple{y;p;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
See <A HREF="#21">Binary Iota, with Permutation</A>, <font face=Kapl>b.p{y;p;x}</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>b.ple{y;p;x</font>} is to <font face=Kapl>b.p{y;p;x}</font> as <font face=Kapl>b.le{y;x}</font> is to <font face=Kapl>b.i{y;x}</font>.  See <A HREF="#21">Binary Iota, with Permutation</A>; <A HREF="#23">Binary Less than or Equal to</A>; and <A HREF="#19">Binary Iota</A>.</BLOCKQUOTE><P>
<A NAME=HEADING668>
<H2><FONT color="#20B2AA">Binary <A NAME=28>Range<font face=Kapl>  b.r{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
See <A HREF="#19">Binary Iota</A>, <font face=Kapl>b.i{y;x}</font>.  The result is an integer array whose shape is <font face=Kapl>2,Òb.i{y;x}</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>0#b.r{y;x}</font> is identical to <font face=Kapl>b.i{y;x}</font>, and the elements of <font face=Kapl>1#b.r{y;x}</font> are the number of occurrences of the cells or cross sections of <font face=Kapl>x</font> in <font face=Kapl>y</font>.  </BLOCKQUOTE><P>
<A NAME=HEADING669>
<H2><FONT color="#20B2AA">Binary <A NAME=30>Range, with Permutation<font face=Kapl>  b.pr{y;p;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
See <A HREF="#21">Binary Iota, with Permutation</A>, <font face=Kapl>b.p{y;p;x}</font>.  The result is an integer array whose shape is <font face=Kapl>2,Òb.p{y;x}</font>.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
<font face=Kapl>b.pr{y;p;x</font>} is to <font face=Kapl>b.p{y;p;x}</font> as <font face=Kapl>b.r{y;x}</font> is to <font face=Kapl>b.i{y;x}</font>.  See <A HREF="#21">Binary Iota, with Permutation</A>; <A HREF="#28">Binary Range</A>; and <A HREF="#19">Binary Iota</A>.</BLOCKQUOTE><P>
<A NAME=HEADING670>
<H2><FONT color="#20B2AA">Binary <A NAME=32>Unique<font face=Kapl>  b.u{y;x}</font></FONT></H2>
<b>&nbsp;&nbsp;&nbsp;Arguments and Result</b><BLOCKQUOTE>
The arguments are simple and the items of <font face=Kapl>y</font> are assumed to be unique.  Otherwise, the arguments and result follow the rules for <font face=Kapl>b.i{y;x}</font> in the simple case.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Dependency</b><BLOCKQUOTE>
Comparison Tolerance.</BLOCKQUOTE>
<b>&nbsp;&nbsp;&nbsp;Definition</b><BLOCKQUOTE>
The result is identical to <A HREF="#19">Binary Iota</A>, <font face=Kapl>b.i{y;x}</font>.  Since, however, unique items in <font face=Kapl>y</font> are assumed, the algorithm is slightly faster.  The use of this function is discouraged, as it may be removed.</BLOCKQUOTE><P>
<HR>
<ADDRESS><table width="100%"><tr><td><font size=2><i><a href="mailto:doc@aplusdev.org">doc@aplusdev.org</a></i></font></td><td align=right><font size=2><i>&#169; Copyright 1995&#150;2008 Morgan Stanley Dean Witter &amp; Co.  All rights reserved.</i></font></td></tr></table></ADDRESS>
</BODY>
</HTML>

