<HTML>
<HEAD>
<TITLE>A+ Reference: Introduction to Screen Management</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<A NAME=HEADING405>
<H1><FONT color="#FF0000"><A NAME=0>Introduction to Screen Management</FONT></H1>
<a name="CONTENTS20">
<UL>
<A HREF="#33AA">  Getting Started</A><BR>
<A HREF="#33A">  Controlling Which Screen the Windows Are Displayed On</A><BR>
<A HREF="#34">  Default Behavior</A><BR>
<UL>
<A HREF="#HEADING407">  Example 1. Manipulating Layouts</A><BR>
<A HREF="#HEADING408">  Example 2. A Text-Graph Dependency</A><BR>
<A HREF="#HEADING409">  Default Class Binding</A><BR>
</UL>
<A HREF="#HEADING410">  Display Classes</A><BR>
<A HREF="#HEADING411">  Entering and Editing Information on the Screen</A><BR>
<UL>
<A HREF="#HEADING412">  Traversal: Activating the Area for Input or Editing</A><BR>
<A HREF="#HEADING413">  Input and Editing</A><BR>
</UL>
<A HREF="#HEADING414">  Windows</A><BR>
<UL>
<A HREF="#HEADING415">  Toplevels and Popups</A><BR>
<A HREF="#HEADING416">  There Is Normally at Most One Toplevel</A><BR>
<A HREF="#HEADING417">  The Workspace  </A><BR>
<A HREF="#HEADING418">  The Workspace Variable <font face=Kapl>s.WS</font></A><BR>
<A HREF="#HEADING420">  The Screen Management Function </font><font face=Kapl>hide{}</font></A><BR>
<A HREF="#HEADING421">  The <font face=Kapl>`exit</font> Callback</A><BR>
<A HREF="#HEADING422">  Leaders and Followers</A><BR>
<A HREF="#HEADING423">  Follower Trees</A><BR>
<A HREF="#HEADING424">  The <font face=Kapl>`iconic</font> Attribute</A><BR>
<A HREF="#HEADING425">  <font face=Kapl>s.WSNAME</font> Contains the Workspace Shelltitle</A><BR>
<A HREF="#HEADING426">  </font><font face=Kapl>s.SHELL</font> Determines whether Windows are Top-level or
 Popup.</A><BR>
<A HREF="#HEADING427">  The <font face=Kapl>s.wstree{sym}</font> Function</A><BR>
</UL>
<A HREF="#HEADING428">  Layouts, Geometry, Constraints</A><BR>
<UL>
<A HREF="#HEADING429">  Containers</A><BR>
<A HREF="#HEADING430">  Layouts</A><BR>
<A HREF="#HEADING431">  The Natural Size of Objects</A><BR>
<A HREF="#HEADING432">  The Structure of a Layout</A><BR>
<UL>
<A HREF="#HEADING433">  The Simple Symbolic Vector Form</A><BR>
<A HREF="#HEADING434">  The Nested Vector Form</A><BR>
<A HREF="#HEADING435">  The Simple Matrix, or Canonical Form</A><BR>
<A HREF="#HEADING436">  The Nested Matrix Form</A><BR>
</UL>
<A HREF="#HEADING437">  Constraints on Resizing Objects</A><BR>
<A HREF="#HEADING438">  Constraints on Resizing Layout Structures</A><BR>
<A HREF="#HEADING439">  Constraining Layout Structure by Way of the Objects</A><BR>
<UL>
<A HREF="#HEADING440">  Repositioning Objects in a Layout</A><BR>
<A HREF="#HEADING441">  Default Constraints</A><BR>
<A HREF="#HEADING442">  The resize Attribute</A><BR>
</UL>
<A HREF="#HEADING443">  The Geometry of Slotfiller Objects</A><BR>
<UL>
<A HREF="#HEADING444">  Partition Vector Form</A><BR>
<A HREF="#HEADING445">  Index Matrix, or Canonical Form</A><BR>
</UL>
<A HREF="#HEADING446">  Making Objects Equal Sizes</A><BR>
<A HREF="#HEADING447">  Locking and Zooming</A><BR>
<A HREF="#HEADING448">  Natural Size Action</A><BR>
</UL>
</UL>
<HR>
<H1><FONT color="#20B2AA"><A NAME=33AA>Getting Started</FONT></H1>
<blockquote>
<A NAME=2>A+ provides a straightforward, easy to understand scheme for visually
 representing variables in a variety of ways, including graphs. Compound representations
 can be formed for collections of variables and used as screen interfaces for applications.
 The connection between the values of A+ variables and their visual representations is
 maintained by A+ so that the two are always in agreement: a change to the value of a
 variable will be immediately visible on the screen, and a change to the screen will be
 immediately reflected in the value of the appropriate variable. (If, however, a mapped
 file is displayed in one process and a change to that file is made in another process, the
 change will not be reflected automatically in the display, since the displaying process is
 not notified of changes made to the file in other processes.)  As a simple example,
 consider:
<pre></font><font face=Kapl>     $load s   ã </font>All the screen management functions are in s;<font face=Kapl>
     bûÉ2 3    ã </font>the principal six are loaded into the root context also.<font face=Kapl>
     `b is `array
     show `b</font></pre>
Run this example and you will see a display of the array <font face=Kapl>b</font> on the
 screen. Change a number on the screen and then examine the value of
 <font face=Kapl>b</font> in the A+ session; it has changed accordingly. Change an element
 of <font face=Kapl>b</font> and note the corresponding change to the screen display. And
 the same consistency between the view of <font face=Kapl>b</font> on the screen and value
 of <font face=Kapl>b</font> in the A+ session is maintained for any visual representation
 of <font face=Kapl>b</font>, even a graph. Not only are changes to values reflected in
 changes to graphs, but when points on a graph are dragged to new positions, values change
 accordingly.<P>
(At various points throughout this chapter examples of visual displays will be discussed,
 and it is assumed that the reader is actually running these examples and has the displays
 available for reference. There are tutorial scripts available
 under the "Tutorials" item on
 the "<a href="Documentation/index.html">On-Line Documents</a>" section of the home page.
<A NAME=8>They are ASCII text files; use Emacs to
 access them and the <b>F2</b> key to execute the lines of code in them.)<P>
The phrase <font face=Kapl>`b is `array</font> in the above example specifies the way in
 which the variable <font face=Kapl>b</font> will be visually represented, in the display
 format called <i>array</i>. Array is said to be the name of a <i>class</i> of A+ objects.
 It is also said that:
<UL>
<LI><A NAME=9>the phrase <BR><font face=Kapl>`b is `array<BR></font><i>binds</i> the
 variable <font face=Kapl>b</font> to the array class;<P>
<LI><font face=Kapl>b</font> is <i>bound to the class array</i> when the phrase<BR>
<font face=Kapl>`b is `array<BR></font>is executed.
</UL>
<A NAME=13>The term <i>object </i>b refers to a variable b which has been bound to a class.
 The terms <i>visual class</i> and <i>display class</i> will be used for <i>class</i> when
 the emphasis is useful.<P>
<A NAME=14>Not all variables can be bound to the array class, and usually there is more
 than one class to which a variable can be bound (but it can be bound to only one class at
 a time). Each class has it own visual appearance. For example, a character vector can be
 in the array class:
<pre><font face=Kapl>     cû"Visual Displays"
     `c is `array
     show `c</font></pre>
<A NAME=15> or in the label class:
<pre><font face=Kapl>     dû"Visual Displays"
     `d is `label
     show `d</font></pre>
A numeric matrix, however, which can be bound to the array class, cannot be bound to the
 label class.
<pre><font face=Kapl>     mûÉ2 3
     `m is `label
ã     !!  .m: variable cannot be bound to label</font></pre>
<A NAME=17>There are several display classes of compound, or <i>container</i>, objects, by
 which complex displays can be created by arranging collections of objects of simpler
 classes. The layout display class is one of these.
<pre></font><font face=Kapl>     wû()        ã </font>Initialize a layout.<font face=Kapl>
     `w is `layout
 `.w
     xû"Array Format"
     `x is `label
 `.x
     wûw,`x      ã </font>Add label to layout; context assumed same as container's.<font face=Kapl>
     yûÉ2 4
     `y is `array
 `.y
     wûw,`y       ã </font>Add an array to the layout.<font face=Kapl>
     show `w</font></pre>
<A NAME=19>The display of <font face=Kapl>w</font> should suggest the potential power of
 the layout class, but it also reveals some characteristics of displays that one might like
 to modify. For instance, in this example the values of <font face=Kapl>x</font> and
 <font face=Kapl>y</font> may convey all the information needed, and so it is preferable
 to remove the variable names <font face=Kapl>y</font> and <font face=Kapl>w</font> from
 the display. The characteristics that can be modified are called the <i>attributes</i> of
 the display class. Each class has its own set of attributes; some are shared with other
 classes, while others are specific to that class.<P>
<A NAME=21>Continuing with the above example, the variable names, <font face=Kapl>y</font>
 and <font face=Kapl>w</font>, are the default values of the attribute called <i>title</i>,
 which is an attribute of both the array and layout classes. A new title can be specified
 by modifying this attribute:
<pre><font face=Kapl>     `w <A NAME=22>has (`title;"New Title")</font></pre>
Or the title can be <A NAME=23>removed by specifying it to be empty:
<pre><font face=Kapl>     `w has (`title;"")</font></pre>
Similarly, the title can be removed from the object <font face=Kapl>y</font>:
<pre><font face=Kapl>     `y has (`title;"")</font></pre>
<A NAME=25>Just as attributes can be altered, their current values can be determined. For
 instance, to find out what background color is used for the label in the above example:
<pre><font face=Kapl>     <A NAME=27>`bg of `x
&lt;  `grey</font></pre>
And to change it:
<pre><font face=Kapl>     `x has (`bg;`yellow)</font></pre>
Another way to alter the behavior of the screen management system is to redefine various
 global variables in the s context. These variables are discussed at the appropriate places
 throughout the chapters that follow; in particular, see
 "<A HREF="APlusRefV2_57.html#0">The s Context</A>".<P>
<A NAME=28>There are now several displays on the screen, and in an application one might
 want to control potential screen clutter by specifying what is seen and unseen. A+
 provides two functions for doing that. It is possible to hide one or more of the displays,
 perhaps replacing them with icons:
<pre><font face=Kapl>     hide `w</font></pre>
<A NAME=31>The hide function is an inverse of <font face=Kapl>show</font>. There is also
 an inverse to the class-binding function<font face=Kapl> is</font>,<font face=Kapl>
 </font>called <font face=Kapl>free</font>,<font face=Kapl> </font>that releases an object
 from its specified class and has the side effect of removing its display from the screen:
<pre><font face=Kapl>     free `d</font></pre>
<A NAME=33>Note that in the case of<font face=Kapl> hide&nbsp;`w</font>,<font face=Kapl>
 </font>the variable <font face=Kapl>w</font> is still bound to the display class layout;
 it is simply not visible. Showing <font face=Kapl>w</font> again and getting back the
 original display verifies this:
<pre><font face=Kapl>     show `w</font></pre>
However, in the case of<font face=Kapl> free&nbsp;`d </font>the variable
 <font face=Kapl>d</font> is no longer in the label display class; if the variable
 <font face=Kapl>d</font> is shown again it will be bound to the array class by default,
 and its display will look different from before:
<pre><font face=Kapl>     show `d
ã    .d: variable bound to `array</font></pre>
All the basic primitive functions for visual representation, namely<font face=Kapl>
 is</font>,<font face=Kapl> free</font>,<font face=Kapl> show</font>,<font face=Kapl>
 hide</font>,<font face=Kapl> of</font>, and<font face=Kapl> has</font>,<font face=Kapl>
 </font>have now been shown. (These functions are put in both the root and the
 s contexts by <font face=Kapl>$load s</font>.)   Examples have been shown of several
 display classes, namely array, label, and layout, and two attributes, title and bg
 (background color). Complete definitions are given in "<A HREF="#45">Display Classes</A>",
 and in the chapters that follow.
</blockquote>
<H1><FONT color="#20B2AA"><A NAME=33A>Controlling Which Screen the Windows Are
 Displayed On</FONT></H1>
<blockquote>
A+ does not (yet, at least) provide a means to let a single process write to several X displays.
 You can, however, choose which display your s windows appear on. If, for example, your
 machine, "mymachine", say, has two displays and you want to show your s windows on the
 second of them, you can execute
<pre><font face=Kapl>     sys.setenv{"DISPLAY=mymachine:0.1"}
     $load s</font></pre>
Note that you must set DISPLAY before you load s.
</blockquote>

<H1><FONT color="#20B2AA">Default <A NAME=34>Behavior</FONT></H1>
<blockquote>
The primitives for visual display often report information in the A+ session
 when executed, such as binding class assumptions. This information has been mostly left
 out of the simulated terminal sessions shown here. Whether or not messages appear is
 controlled by the s context variable <font face=Kapl>s.QUIET</font>. The default value is
 0, which causes all messages to be printed. The value 1 causes only error messages to be
 printed, suppressing any warning or informational messages, and 2 only messages for severe
 errors. No messages are printed if the value is -1. In addition, the behavior of s context
 functions when errors occur is controlled by the s context variable
 <font face=Kapl>s.ABORT</font>, whose default value is 1, meaning that error messages will
 be displayed (if <font face=Kapl>s.QUIET</font> allows) and function execution will simply
 end when error conditions arise. The value 0 means that errors will be signalled and
 execution suspended (see "<A HREF="APlusRefV2_8.html#293">Signal</A>").
</blockquote>
<A NAME=HEADING407>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Example 1. <A NAME=35>Manipulating
 Layouts</FONT></H2>
<blockquote>
 If you are executing the above layout example, at this point you should have on the screen
 a label object <font face=Kapl>x</font> and an array object <font face=Kapl>y</font>
 inside a layout object <font face=Kapl>w</font>.
 Now append a view object to <font face=Kapl>w</font>. (A view is simply a character matrix.)
<pre><font face=Kapl>     sûÎ`name `address `phone
     `s is `view
     wûw,`s
     show `s</font></pre>
<A NAME=38>It is worthwhile to experiment with respecifying <font face=Kapl>w</font> as
 <font face=Kapl>`s `y</font>, then as <font face=Kapl>`y `s `x</font>, and so on, watching
 the changes on the screen. In particular, you will note that as objects are removed from
 <font face=Kapl>w</font> they remain on the screen. This behavior, which is the same for
 tables, graphs, and windows, is controlled by two s context variables,
 <font face=Kapl>s.AUTOREPARENT</font> and <font face=Kapl>s.AUTORESHOW</font>, both with
 default value 1. For example, if
<pre><font face=Kapl>     wû1Õw</font></pre>
the object that was named in <font face=Kapl>w[0]</font>, say <font face=Kapl>x</font>, is
 redisplayed outside the layout. However, if <font face=Kapl>s.AUTORESHOW</font> had been
 0 then <font face=Kapl>x</font> would not have been redisplayed. It would, however, have
 remained bound to the label class. If <font face=Kapl>s.AUTOREPARENT</font> had been 0,
 then x would have been freed from the label class (and consequently not displayed).<P>
<A NAME=39>As you proceed with the experiment you may notice that the relative positions of
 <font face=Kapl>x</font>, <font face=Kapl>y</font>, and <font face=Kapl>s</font> on the
 screen are not necessarily related to the arrangement of these names in the variable
 <font face=Kapl>w</font>. The geometry of the layout can be controlled by specifying
 <font face=Kapl>w</font> as a matrix or a nested array. For example, to put
 <font face=Kapl>x</font> on the left, <font face=Kapl>y</font> in the middle, and
 <font face=Kapl>s</font> on the right, set
<pre><font face=Kapl>     wû1 3Ò`x `y `s</font></pre>
Or, to put <font face=Kapl>`y</font> above <font face=Kapl>`x</font> and <font face=Kapl>`x</font> above <font face=Kapl>`s</font>, set
<pre><font face=Kapl>     wû3 1Ò`y `x `s</font></pre>
Or, to put <font face=Kapl>y</font> to the left of <font face=Kapl>s</font> and <font face=Kapl>x</font> above them both, set
<pre><font face=Kapl>     wû`x,1 2Ò`y `s</font></pre>
or
<pre><font face=Kapl>     wû(`x;`y `s)</font></pre>
A layout can also be composed on the screen. Set <font face=Kapl>w</font> to Null, so that all the objects
 that were contained in it will be shown on the screen as independent displays:
<pre><font face=Kapl>     wû()</font></pre>
Reset <font face=Kapl>x</font>, <font face=Kapl>y</font>, and <font face=Kapl>s</font> to their original display classes if necessary.
 Move the displays around so you can see them all, and then move them into an agreeable
 arrangement. For example, make <font face=Kapl>s</font> larger and <font face=Kapl>x</font>  smaller, put <font face=Kapl>x</font>
 next to <font face=Kapl>y</font>, and <font face=Kapl>s</font> on top of them both. Now set
<pre></font><font face=Kapl>     `w has (`build;1)     ã </font>Or<font face=Kapl> s.AUTOBUILDû1
     wû`x `y `s</font></pre>
The independent objects have now been captured in a layout reflecting their independent
 arrangement on the screen, and their displays have been replaced with the layout display.<P>
<A NAME=41>Once a display has been arranged to your liking, it can be saved and redisplayed
 later using the s context functions <font face=Kapl>s.save</font> and <font face=Kapl>s.load</font>. For example,
<pre><font face=Kapl>     s.save 'testfile.+'</font></pre>
will save all objects created in this session, including the layout <font face=Kapl>w</font>, in the file
 <font face=Kapl>testfile</font>. Then if the arrays <font face=Kapl>x</font>, <font face=Kapl>y</font>, and <font face=Kapl>s</font> are recreated
 in some future session, the layout can be recreated and redisplayed as follows:
<pre><font face=Kapl>     s.load 'testfile'</font></pre>
More details can be found in "<A HREF="#59">Layouts, Geometry, Constraints</A>".
</blockquote>
<A NAME=HEADING408>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Example 2. A Text-Graph
 Dependency</FONT></H2>
<blockquote>
As a second example, consider devising a display with a text input area and a graph area, so
 that when an expression for a scalar function is entered in the text area, its graph
 appears. Set
<pre><font face=Kapl>     xcû0.1«É1000</font></pre>
Functional expressions can be captured on the screen by a scalar object. For example:
<pre><font face=Kapl>     fnû20Ò' '
     show `fn is `scalar</font></pre>
The value area of a scalar can be edited. Move the mouse onto the blank area to the right of
 the text <font face=Kapl>fn</font>, enter <font face=Kapl>1Ïxc</font> (i.e., sine of <font face=Kapl>xc</font>), and press the
 <B>Enter</B> key. Now examine <font face=Kapl>fn</font> and you will see that this expression has been
 captured.<P>
A <i>trace</i> for a graph of this expression is a two-column matrix, with the domain to the
 left of the range. To make the trace a dependency on <font face=Kapl>xc</font> and <font face=Kapl>fn</font> (or rather
 the expression in it):
<pre><font face=Kapl>     tr:xc(,@0)âfn
     Òtr
 1000 2</font></pre>
Now put the graph on the screen:
<pre><font face=Kapl>     gû`tr
     show `g is <A NAME=42>`graph</font></pre>
Quite possibly the graph display has covered the scalar display. Move it so that you can
 see both. Now enter another expression in the slot. The graph will change automatically
 and immediately because it displays the value of the dependency <font face=Kapl>tr</font> on the screen.
 Finally, these two independent displays can be put in a layout:
<pre><font face=Kapl>     lû(`fn;`g)
     show `l is `layout</font></pre>
</blockquote>
<A NAME=HEADING409>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Default <A NAME=43>Class
 Binding</FONT></H2>
<blockquote>
<A NAME=44>If a global variable or dependency is not bound to a display class and its name
 is used as the argument to <font face=Kapl>show</font> or as the left argument to the
 screen management primitive function <font face=Kapl>has</font> when the right argument
 contains a nonpersistent attribute (see "<A HREF="APlusRefV2_23.html#10">Persistent
 Attributes (key = p)</A>"<font face=Kapl>)</font>, it will be bound to its <i>default
 display
 class</i><A NAME=APlusRefV2_FootNote_956 HREF=APlusRefV2_FootNote_956.html><b><sup>1</sup></b></A>.<P>
The default display class of an object is determined according to the following rules,
 which are applied in order:
<OL>
<LI><font face=Kapl>É0</font> is bound to class array and the Null to class scalar;<P>
<LI>if the variable is of type box, attempt to bind it to class radio, and if that fails
 try class check, and so on through the list of slot, layout, array, scalar (any object can
 be bound to class scalar);<P>
<LI>if it is of type function, bind it to class button;<P>
<LI>if it is a matrix, attempt to bind it, in order, to class layout, array, scalar;<P>
<LI>if it is a vector, attempt to bind it, in order, to class table, graph, layout, array,
 scalar;<P>
<LI>bind it to class scalar.
</OL>
Children (see next section) of a table object are always bound to the tableField class and
 children of a graph are always bound to the graphTrace class.
</blockquote>
<A NAME=HEADING410>
<H1><FONT color="#20B2AA">Display <A NAME=45>Classes</FONT></H1>
<blockquote>
<A NAME=46>The descriptions in the following chapters assume default values for the
 attributes of the display classes. In particular, whenever a display class has a title
 area, the name of the variable bound to the class is displayed there. Settings other than
 defaults are controlled by the attributes of the various classes, which are described in
 the several chapters on attributes as well as in the chapters on the various classes. The
 classes can be grouped in seven categories:
<UL>
<LI>simple classes for displaying individual global variables:  array, hgauge,
 label, matrix, page, scalar, vgauge, and view;<P>
<LI>classes for entry: command, hscale, password, text, and vscale;<P>
<LI>the class for functions:  button;<P>
<LI>classes for slotfillers:  action, check, choice, hmenu, radio, slot, tree, and
 vmenu;<P>
<LI>general container classes, which consist of objects made up of other objects:
 hgrid, hpane, layout, notebook, vgrid, vpane, and window;<P>
<LI>special container classes:  table and graph, and their special contained classes,
 tableField and graphTrace;<P>
<LI>the class for printing reports: report, which cannot actually be displayed.
</UL>
<A NAME=48>The objects that can be bound to container classes are variables whose values
 consist of collections of other objects. For example, in this chapter the value of the
 layout object <font face=Kapl>w</font> ended up as<font face=Kapl> `x</font> <font face=Kapl>`y</font>,<font face=Kapl> </font>where <font face=Kapl>x</font> is
 a label object and <font face=Kapl>y</font> is an array object. An object bound to a container class is
 said to be a <i>parent</i> of the objects named in its value, and these objects are said to
 be <i>children</i> of the parent. The children of a child are also children of its parent.
 In A+, no object can be a child (or parent) of itself.<P>
When a child is bound to a container class, its context need not be given if it is the same
 as the parent's, because the same context is assumed. Different contexts are accommodated
 by qualifying the child's name.
</blockquote>
<A NAME=HEADING411>
<H1><FONT color="#20B2AA">Entering and Editing Information on the Screen</FONT></H1>
<blockquote>
<A NAME=50>A+ provides a very simple scheme for entering and editing on the screen. Not all
 display classes are designed for entering and editing, but those that are all use this same
 scheme. The way the area to be edited is identified does vary, however, and so this point is
 discussed first. (A more detailed account can be found in
 "<A HREF="APlusRefV2_50.html#0">User Interactions with Displays</A>".)
</blockquote>
<A NAME=HEADING412>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Traversal: <A NAME=51>Activating the Area
 for Input or Editing</FONT></H2>
<blockquote>
<A NAME=52>The screen is composed of a series of windows, and to enable keyboard entry the
 one that holds the area for input or editing must be selected. The usual way to do this is
 simply to move the mouse pointer onto that window. The appearance of the window will change
 to indicate that it now has <i>keyboard focus</i>, such as by a change in the background of
 the title area at the very top of the window.<P>
Assuming that this is a window created by the screen management system, it must have been the
 result of executing<font face=Kapl> show `a </font>for some object <font face=Kapl>`a</font>. Depending upon the display
 class of <font face=Kapl>`a</font>, the editing state will be different:
<UL>
<LI>If <font face=Kapl>`a</font> is bound to the <font face=Kapl>`scalar</font> display class, a highlight band will be
 displayed around it and you can begin entry or editing.<P>
<LI>If <font face=Kapl>`a</font> is bound to the <font face=Kapl>`slot</font> display class, it will look like a
 collection of scalars, and one of the scalar lookalikes will have a highlight band around.
 If you want to work in some other area in the slot, use the <B>Tab</B> key or <B>arrow</B>
 keys to move to it.<P>
<LI>If <font face=Kapl>`a</font> is bound to the <font face=Kapl>`array</font>, <font face=Kapl>`table</font>, or <font face=Kapl>`matrix</font>
 display class, a highlight band will appear around the object, not around an individual row
 or cell. Press the left mouse button when the mouse pointer is in one its rows or cells, and
 that row or cell will then appear raised. It is called the <i>selected</i> row or cell. If
 you want to enter or edit some other row or cell, use the <B>Tab</B> key or <B>arrow</B>
 keys to move to it.<P>
<LI>If <font face=Kapl>`a</font> is bound to the <font face=Kapl>`layout</font> display class, one of the objects in it
 will have keyboard focus, as indicated in the previous descriptions. Use <B>Meta-Tab</B> on
 Sun keyboards and <B>Alt-Tab</B> on IBM keyboards to move around the layout until the object
 you want has keyboard focus. You can also move the pointer onto the area you want and press
 the left mouse button to get keyboard focus on that area.
</UL>
</blockquote>
<A NAME=HEADING413>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Input <A NAME=53>and Editing</FONT></H2>
<blockquote>
Once the row or cell you want has been selected, you can simply start typing to enter input;
 input mode begins automatically on the first key stroke. Edit mode is ended for that row or
 cell and the input is sent to the appropriate A+ variable when the <B>Enter</B> key
 is pressed, or the <B>Tab</B> key, <B>Meta-Tab</B> on a Sun keyboard or <B>Alt-Tab</B> on
 an IBM keyboard, or an <B>arrow</B> key is used to move to another row or cell.<P>
There are actually three input modes: complete replacement, overwriting, and insertion. When
 input mode is entered by starting to type, anything previously displayed in the input area
 is lost; it is completely replaced. If the mouse pointer is on a character in the area to be
 edited and the middle or right mouse button is pressed, the area takes on the appearance of
 edit mode and the keyboard focus is on that character. If it is the middle button that is
 pressed, anything entered overwrites the existing text, starting at that character. If it is
 the right button that is pressed, anything entered is inserted just to the left of that
 character.
</blockquote>
<A NAME=HEADING414>
<H1><FONT color="#20B2AA"><A NAME=55>Windows </FONT></H1>
<blockquote>
A+ windows are tree structures of bound variables. A bound variable is often referred to as
 an <i>object</i>. For example, in the window consisting of a layout <font face=Kapl>m</font> containing a
 scalar <font face=Kapl>s</font>, a table <font face=Kapl>t</font> of fields <font face=Kapl>a</font>, <font face=Kapl>b</font>, and <font face=Kapl>c</font>, and
 a button <font face=Kapl>f</font>:
<pre><font face=Kapl>     aûbûcûÉ10
     tû`a`b`c
     sû101
     foo{s;c;v}:Õ'pressed'
     fû&lt;{foo}
     `t is `table
     `s is `scalar
     `f is `button
     mû(`s;`f;`t)
     `m is `layout
     show `m</font></pre>
there are seven objects:
<pre><font face=Kapl>       m           `layout
           s           `scalar
           f           `button
           t           `table
               a           `tableField
               b           `tableField
               c           `tableField

     `descendents of `m
&lt;  `.t `.s `.f `.a `.b `.c</font></pre>
</blockquote>
<A NAME=HEADING415>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Toplevels and Popups</FONT></H2>
<blockquote>
An A+ process will usually contain several windows. The windows in a process also form a
 tree. For example, continue the example above by creating three more arrays:
<pre><font face=Kapl>     v1ûv2ûv3ûÉ10
     `v1 `v2 `v3 is¡ `array
     show¡ `v1 `v2 `v3</font></pre>
The first thing to note is that the control borders of <font face=Kapl>m</font> and the <font face=Kapl>v</font>-arrays
 are different. <font face=Kapl>m</font> is a top-level window and the <font face=Kapl>v</font>-arrays are popup
 windows. The default shelltitle of <font face=Kapl>m</font> is the value of <font face=Kapl>_argv</font>, if it is
 nonnull, or "A+", and those of the <font face=Kapl>v</font>-arrays are "v1", "v2", and "v3".
</blockquote>
<A NAME=HEADING416>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;There Is Normally at Most One
 Toplevel</FONT></H2>
<blockquote>
An A+ process normally has at most one top-level window. By default, this property - top-level
 windowhood - is given to the first object bound. In the above example, it is <font face=Kapl>t</font>:
<pre></font><font face=Kapl>     `t is `table          ã </font>First object bound.</pre>
Subsequently bound objects which do not contain t are created as popups. Finally,
 when a container for t is bound:
<pre></font><font face=Kapl>     `m is `layout         ã </font>Layout containing <font face=Kapl>t</font></pre>
the property of top-level windowhood is passed to <font face=Kapl>m</font>.<P>
This can be demonstrated by creating a new layout <font face=Kapl>n</font> containing <font face=Kapl>m</font>.
<pre><font face=Kapl>     nû`m `v1
     `n is `layout
     show `n</font></pre>
Top-level windowhood is given to <font face=Kapl>n</font>, since <font face=Kapl>n</font> contains <font face=Kapl>m</font>.<P>
Note that this property can be lost:
<pre></font><font face=Kapl>     nû()                  ã m</font> reparented to popup.<font face=Kapl>
     free `n               ã </font>Toplevel freed.</pre>
All windows are now popups.
</blockquote>
<A NAME=HEADING417>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The Workspace</FONT></H2>
<blockquote>
When the A+ process has a top-level window <font face=Kapl>x</font>, that top-level window
 is called the <i>workspace</i> of that process. It usually has the shelltitle "A+".
</blockquote>
<A NAME=HEADING418>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The Workspace Variable
 <font face=Kapl>s.WS</font></FONT></H3>
<blockquote>
The variable <font face=Kapl>s.WS</font> is either <font face=Kapl>()</font> (there is no
 workspace for the process) or <font face=Kapl>`cx&nbsp;`var</font>, where
 <font face=Kapl>cx.var</font> is the top-level window. <font face=Kapl>s.WS</font>
 can be assigned the symbol of any popup window in the process, and no matter what the form
 in the assignment, fully qualified name, context and unqualified name, or (for the root
 context) just unqualified name, the value of s.WS will be a two-element symbol vector.
 Continuing the above example, we can restore the property of top-level windowhood to
 <font face=Kapl>m</font>:
<pre><font face=Kapl>     s.WSû`m
     s.WS
 ` `m</font></pre>
</blockquote>


<A NAME=HEADING420>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The Screen Management Function
 <font face=Kapl>hide{}</font></FONT></H2>
<blockquote>
The function <font face=Kapl>hide{}</font> dismisses a popup window if its pin is in the 0 state. That is,
 <font face=Kapl>hide{}</font> will not dismiss a pinned window.
</blockquote>
<A NAME=HEADING421>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The <font face=Kapl>`exit</font>
 <A NAME=57>Callback</FONT></H2>
<blockquote>
Quitting from a top-level window causes a quit event; dismissing a popup window
 causes a dismiss event:  generically, an <font face=Kapl>`exit</font> event. The default
 <font face=Kapl>`exit</font> callback function frees a toplevel and hides an unpinned
 popup. This callback can be reset:
<pre><font face=Kapl>     `popup has (`exit;my.dismiss)
     `top has (`exit;my.quit)</font></pre>
</blockquote>
<A NAME=HEADING422>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Leaders <A NAME=58>and
 Followers</FONT></H2>
<blockquote>
Construct a set of windows:
<pre><font face=Kapl>     aûbûcûdûeûÉ3
     show¡`a`b`c`d`e</font></pre>
The workspace is <font face=Kapl>a</font>:
<pre><font face=Kapl>     s.WS
 ` `a</font></pre>
<font face=Kapl>b</font>, <font face=Kapl>c</font>, <font face=Kapl>d</font>, and <font face=Kapl>e</font> are popup windows.<P>
Now hide the workspace:
<pre><font face=Kapl>     hide `a</font></pre>
Notice that if they are unpinned the popups "follow" <font face=Kapl>a</font> into hiding.<P>
Now, show the workspace:
<pre><font face=Kapl>     show `a</font></pre>
The popups follow <font face=Kapl>a</font> back into visibility.<P>
Now pin one of the windows, say <font face=Kapl>b</font>, and hide the workspace again. This time,
 <font face=Kapl>b</font> remains visible.<P>
By default, all popups follow the workspace:
<pre><font face=Kapl>     `followers of `a
&lt; `.b `.c `.d `.e
     `leader of `b
&lt; `.a
     `leader of `c
&lt; `.a</font></pre>
Note that
<pre><font face=Kapl>     `x has `leader `x</font></pre>
is equivalent to
<pre><font face=Kapl>     s.WSû`x</font></pre>
I.e., only the workspace follows itself.<P>
Also note that
<pre><font face=Kapl>     `x has (`leader;)</font></pre>
causes <font face=Kapl>x</font> to follow the workspace if there is one. Otherwise, it has the same effect
 as
<pre><font face=Kapl>     `x has `leader `x</font></pre>
</blockquote>
<A NAME=HEADING423>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Follower Trees</FONT></H3>
<blockquote>
More complex hierarchies are possible:
<pre><font face=Kapl>     `c has `leader `b
     `followers of `a
&lt; `.b `.d `.e
     `followers of `b
&lt; `.c</font></pre>
A convenient form for describing the whole leader-follower tree of a process is a nested
 slotfiller:
<pre><font face=Kapl>     Õkû0Ø    `followertree of `a
&lt;  `.a
&lt; &lt; &lt;  `.e `.d `.b
  &lt; &lt;
    &lt;
    &lt; &lt;  `.c
    &lt; &lt;
     `.a `.bØk
&lt;  `.c
&lt; &lt;</font></pre>
</blockquote>
<A NAME=HEADING424>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The <font face=Kapl>`iconic</font> Attribute</FONT></H2>
<blockquote>
Any popup window can be converted to a toplevel, and vice versa. For example:
<pre></font><font face=Kapl>     aûbûÉ10
     show `a is `array    ã </font>First object is toplevel.<font face=Kapl>
     show `b is `array    ã </font>Subsequent objects are popups.<font face=Kapl>
     `b has (`iconic;1)   ã </font>Convert to toplevel.<font face=Kapl>
     `b has (`iconic;0)   ã </font>Convert back to popup.</pre>
</blockquote>
<A NAME=HEADING425>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;<font face=Kapl>s.WSNAME</font> Contains the Workspace
 Shelltitle</FONT></H3>
<blockquote>
By default, the shelltitle on the workspace is either <font face=Kapl>0Ø1Ù_argv</font>, or <font face=Kapl>"A+"</font> if
 <font face=Kapl>_argv</font> is Null. The default workspace shelltitle can be set to an arbitrary string:
<pre><font face=Kapl>     s.WSNAMEû"y Application"</font></pre>
</blockquote>
<A NAME=HEADING426>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;<font face=Kapl>s.SHELL</font> Determines whether Windows
 are Top-level or Popup.</FONT></H3>
<blockquote>
The first object bound is a toplevel, the workspace; subsequent objects are popup windows.
 This behavior can be altered at any point by changing the value of the global variable
 <font face=Kapl>s.SHELL</font>:
<pre></font><font face=Kapl>     s.SHELL
 ¢1                  ã ¢1</font> means popup window.<font face=Kapl>
     show É10        ã </font>First object bound is a toplevel.<font face=Kapl>
     show É10        ã </font>Subsequent objects depend on <font face=Kapl>s.SHELL
     s.SHELLû0       ã </font>0 means top-level window.<font face=Kapl>
     show É10        ã </font>This is a top-level window.</pre>
</blockquote>
<A NAME=HEADING427>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The <font face=Kapl>s.wstree{sym}</font>
 Function</FONT></H3>
<blockquote>
This function creates a nested slotfiller dependency which represents the window hierarchy:
<pre><font face=Kapl>     s.wstree{`my.var}
     show `my.var is `tree</font></pre>
The default assignment callback function on <font face=Kapl>my.var</font> shows and raises the selected
 window. (When a window is raised, wherever it overlaps another window it is shown and the
 other window is obscured.)
</blockquote>
<A NAME=HEADING428>
<H1><FONT color="#20B2AA">Layouts, <A NAME=59>Geometry, Constraints</FONT></H1>
<A NAME=HEADING429>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;<A NAME=60>Containers </FONT></H2>
<blockquote>
A+ windows are trees of screen objects. An A+ screen object is an A+ variable bound to a
 display class. E.g.,
<pre></font><font face=Kapl>     aûÉ10              ã </font>A variable<font face=Kapl>
     `a is `array       ã </font>bound to array display class.</pre>
The A+ display classes are of two kinds:  data and container. Typically, an A+ window will
 consist of a container with children, some of which may in turn be containers. All objects
 at the leaves are data objects, which are childless.<P>
There are eight container classes in A+: table, graph, window, layout, hpane, vpane,
 hgrid, and vgrid.
 The following sections explain how to use layouts to
 create geometry - pictorial structure - in a window tree.

</blockquote>
<A NAME=HEADING430>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Layouts</FONT></H2>
<blockquote>
A layout <font face=Kapl>m</font> is a structure of virtual rows and columns. The position
 of an object <font face=Kapl>p</font> in a layout can be specified by four numbers, called
 the <font face=Kapl>at</font> of <font face=Kapl>p</font> (in <font face=Kapl>m</font>):
<UL>virtual row<BR>virtual column<BR>number of virtual rows spanned<BR>number of virtual
 columns spanned.</UL>
E.g.,
<pre><font face=Kapl>     `at of `p
&lt; 1 2 1 4</font></pre>
indicates that <font face=Kapl>p</font> is at row 1, column 2, and spans one row and four
 columns.<P>
Ultimately, all methods of positioning objects in layouts reduce to that of specifying the
 <font face=Kapl>at</font> of the object.
</blockquote>
<A NAME=HEADING431>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The <A NAME=61>Natural Size of
 Objects</FONT></H2>
<blockquote>
Every A+ screen object has a natural size. The natural size of an object is a function of
 its data, font, and other attributes, which might be specific to the object. For example,
 the natural size of an array class object is a function of the shape of the data, the
 width of the formatted data, the font, and the settings of the rows and columns attributes
 for the object. The natural size of a container is a function of the natural sizes of its
 children and their arrangement within the container. Natural size can always be expressed
 in pixels (xs and ys).
</blockquote>
<A NAME=HEADING432>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The <A NAME=62>Structure of a
 Layout</FONT></H2>
<blockquote>
<A NAME=HEADING433>
<H3><FONT color="#20B2AA">The Simple Symbolic Vector Form</FONT></H3>
<blockquote>
The structure of an A+ layout, as it is manifested on the screen, is a function of the
 array which is bound to that layout. That is, a layout <font face=Kapl>m</font> containing
 children <font face=Kapl>a</font>, <font face=Kapl>b</font>, and <font face=Kapl>c</font>
 is a variable <font face=Kapl>m</font> containing the symbols <font face=Kapl>`a</font>,
 <font face=Kapl>`b</font>, and <font face=Kapl>`c</font>. In the simplest case,
 <font face=Kapl>m</font> is just:<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-1a.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>


<td valign=top>
<pre><font face=Kapl>
     mû`a `b `c</font></pre>
which represents vertical stacking of <font face=Kapl>a</font>, <font face=Kapl>b</font>, and <font face=Kapl>c</font>, with
 <font face=Kapl>at</font> of:
<pre><font face=Kapl>     &gt;0Ø¡`at of¡Øm
 0 0 1 1
 1 0 1 1
 2 0 1 1</font></pre>
</td>
</row></table><P>
Simple symbolic vectors are ambiguous representations. Two attributes control the
 interpretation of a simple symbolic vector:
<UL>
<LI>build:<BR>
if 1, approximate the current arrangement of <font face=Kapl>a</font>,
 <font face=Kapl>b</font>, and <font face=Kapl>c</font> on the screen;<BR>
if 0, use the default arrangement for
 <font face=Kapl>`a`b`c</font>, taking the position attribute into account;<P>
<LI>position (effective when build is 0):<BR>
if 1, place <font face=Kapl>`a`b`c</font> in a vertical column (equivalent
 to <font face=Kapl>(`a;`b;`c)</font>);<BR>
if 0, position each of them at 0&nbsp;0 for 1&nbsp;1 (stacked one atop another).
</UL>
That is, if build is set to 0, then <font face=Kapl>m</font> (i.e.,
 <font face=Kapl>`a`b`c</font>) is taken to represent the geometry of the layout, with the
 orientation depending on the position attribute. To be effective, position must be set
 before the layout is built, when <font face=Kapl>m</font> is <font face=Kapl>()</font>,
 say.<p>
If build is set to 1, <font face=Kapl>a</font>, <font face=Kapl>b</font>,  and
 <font face=Kapl>c</font> retain the same relative positions and sizes when they are
 orphaned ("zero parented").
<pre><font face=Kapl>     `m has (`build;0; `position;0) Ý mû()
     `m is `layout Ý mû`a`b`c
     &gt;0Ø¡`at of¡Øm
 0 0 1 1
 0 0 1 1
 0 0 1 1</font></pre>
</blockquote>
<A NAME=HEADING434>
<H3><FONT color="#20B2AA">The Nested Vector Form</FONT></H3>
<blockquote>
The simplest method of representing geometry is confined to depth 1 vectors of symbolic
 vectors. Each symbolic vector in a variable of this form represents a new virtual row of
 the layout. E.g.,<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-1b.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>

<td valign=top><pre><font face=Kapl>     mû(`a `b;`c `d;`e `f)
     `m is `layout
     &gt;0Ø¡`at of¡Øm
 0 0 1 1
 0 1 1 1
 1 0 1 1
 1 1 1 1
 2 0 1 1
 2 1 1 1</font></pre>
giving the representation shown. Each object spans exactly one row and column; each vector
 in m represents one virtual row of the layout. (Hence, the "<font face=Kapl>;</font>" in the expression
 above can be read as a sort of virtual "new line" character.)</td></row></table><P>
</blockquote>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Span of Objects</b>
<blockquote>
This nested vector form works fine in the case where the same number of objects is found on
 each virtual row of the layout, but what about the case where each row contains a different
 number of objects?  For example,<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-1c.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>

<td valign=top>
<pre><font face=Kapl>     mû(`a `b;`c;`d `e `f)</font></pre>
In this case, <font face=Kapl>c</font> is meant to span the entire width of the structure, <font face=Kapl>a</font> and
 <font face=Kapl>b</font> half each, and <font face=Kapl>d</font>, <font face=Kapl>e</font>, and<font face=Kapl> f</font> a third each, as shown,
 with<font face=Kapl> at </font>of:
<pre><font face=Kapl>     &gt;0Ø¡`at of¡Øm
 0 0 1 3
 0 3 1 3
 1 0 1 6
 2 0 1 2
 2 2 1 2
 2 4 1 2</font></pre>
The total number of virtual columns is the least common multiple of the number of objects in
 each row.<P>
Note that symbols can appear exactly once in a form of this type, and that depth and rank
 must be less than or equal to 1, and that the simple symbolic vector <font face=Kapl>v</font> is treated
 as <font face=Kapl>Û¡v</font>.</td></row></table>
</blockquote>
<A NAME=HEADING435>
<H3><FONT color="#20B2AA">The Simple Matrix, or Canonical Form</FONT></H3>
<blockquote>
Only certain geometries can be represented using vectors of vectors, namely, those in which
 row-span is one for all objects. Consider the case in which buttons <font face=Kapl>a</font> and
 <font face=Kapl>b</font> and table <font face=Kapl>t</font> have the following spatial arrangement:
<pre><font face=Kapl>          a  t
          b  t</font></pre>
<font face=Kapl>a</font> and <font face=Kapl>b</font> are located on successive rows, and <font face=Kapl>t</font> spans both rows. In
 order to describe this arrangement, we use the canonical A+ notation for layout geometry:
<pre><font face=Kapl>     mû2 2Ò`a `t `b `t</font></pre>
which precisely pictures the arrangement described above:
<pre><font face=Kapl>     !@¢1 Îm
 at
 bt</font></pre>
The rules of canonical representation are more intuitive than accurate formalization would
 suggest: where <font face=Kapl>uûunique{,m}</font> is the vector of unique symbols in <font face=Kapl>m</font>, there
 must be a rank 2 subarray <font face=Kapl>miûm[j;k]</font> for each <font face=Kapl>u[i]</font> in which all occurrences
 of <font face=Kapl>u[i]</font> in <font face=Kapl>m</font> are found and no occurrences of any other element of
 <font face=Kapl>u</font>, and the shape of <font face=Kapl>mi</font> specifies the number of virtual rows and columns
 spanned by <font face=Kapl>u[i]</font>. Hence, neither of the following counts as a canonical
 representation:
<pre><font face=Kapl>     2 2Ò`a`t`t`b
     2 2Ò`a`a`a`b</font></pre>
Note that any layout array in nested vector form can be translated into canonical form. E.g.,
<pre><font face=Kapl>     mû(`a;`b `c;`d `e `f)
     nû3 6Ò`a`a`a`a`a`a`b`b`b`c`c`c`d`d`e`e`f`f</font></pre>
represent the same geometry.
</blockquote>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Placeholder in Simple Matrix Layouts</b>
<blockquote>
Consider the geometry of three objects, <font face=Kapl>a</font>, <font face=Kapl>b</font>, and <font face=Kapl>c</font>, which are to
 be arranged in a rectangle whose lower left quadrant is intended to be "empty". That is:<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-2.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>

<td valign=top>
<pre><font face=Kapl>     &gt;0Ø¡`at of¡`a`b`c
 0 0 1 1
 0 1 1 1
 1 1 1 1</font></pre>
To obtain this geometry, use the "placeholder" symbol "<font face=Kapl>`</font>" in the layout variable:
<pre><font face=Kapl>     mû(`a `b;` `c)</font></pre>
allowing the <font face=Kapl>c</font> object to span a single column, as shown.<P>
Note that <font face=Kapl>`</font> is <i>not</i> the symbol of any object.</td></row></table>
</blockquote>
<A NAME=HEADING436>
<H3><FONT color="#20B2AA">The Nested Matrix Form</FONT></H3>
<blockquote>
Consider the array <font face=Kapl>m</font>:
<pre><font face=Kapl>  aûbûcûdûeûfûgûhûÉ3
  mû2 2Ò&lt;()
  m[0;0]û&lt;2 1Ò`a`b
  m[0;1]û&lt;1 2Ò`c`d
  m[1;1]û&lt;4 1Ò`e`f`g`h</font></pre>
<font face=Kapl>m</font> is a 2x2 array of symbolic matrices, where the shapes of the submatrices
 implicitly specify the relative spans of their children, as shown.
<pre><font face=Kapl>  `m is `layout
   &gt;0Ø¡`at of¡ØØ,,¡m
 0 0 1 1
 1 0 1 1
 0 1 2 1
 0 2 2 1
 2 1 1 2
 3 1 1 2
 4 1 1 2
 5 1 1 2</font></pre><p>
<img src="APlusRef_ScrnMgmt_1-3a.gif" alt="example"><P>

The ability to manipulate blocks of objects without the intervening step of assigning to a
 global variable can be extremely convenient in applications with dynamic structures. Thus:
<pre><font face=Kapl>     wûxûyûzûÉ3
     rû1 2Ò(`w `x;2 1Ò`y `z)
     m[1;0]û&lt;r</font></pre><P>
<img src="APlusRef_ScrnMgmt_1-3b.gif" alt="example"><P>

The display of <font face=Kapl>m</font> is modified as shown; note how <font face=Kapl>()</font> is replaced wholesale
 by the arbitrary structure containing <font face=Kapl>w</font>, <font face=Kapl>x</font>, <font face=Kapl>y</font>, and <font face=Kapl>z</font>.<P>
<pre><font face=Kapl>     &gt;0Ø¡`at ofØ¡,¡Ø,,¡m
 0 0 1 3
 1 0 1 3
 0 3 2 1
 0 4 2 1
 2 0 4 1
 2 1 4 1
 2 2 2 1
 4 2 2 1
 2 3 1 2
 3 3 1 2
 4 3 1 2
 5 3 1 2</font></pre>
The placeholder can be restored or another variable inserted:
<pre><font face=Kapl>     m[1;0]û&lt;()</font></pre><P>
<img src="APlusRef_ScrnMgmt_1-4a.gif" alt="example">

<pre><font face=Kapl>     vûÉ3
     m[1;0]û&lt;3 1Ò`v</font></pre><P>
<img src="APlusRef_ScrnMgmt_1-4b.gif" alt="example"><P>

with the results shown. The compactness shown in previous figures can be obtained by
 freeing <font face=Kapl>m</font> and then rebinding it after inserting the placeholder
 or variable.
</blockquote>
</blockquote>
<A NAME=HEADING437>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Constraints <A NAME=63>on Resizing
 Objects</FONT></H2>
<blockquote>
Objects can be resized in either of two ways: directly, by specifying values for certain
 size-dependent attributes (e.g., font, or rows or cols); or indirectly, by resizing the
 object's container. E.g.,<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-5a.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>

<td valign=top>
<pre><font face=Kapl>     aûÉ10
     bû`a
     show `b is `layout</font></pre>
The natural size of the array-class object <font face=Kapl>a</font> is determined by (among other things)
 the default number of rows displayed, which in this case is:
<pre><font face=Kapl>     `rows of `a
&lt;  5</font></pre>
</td></row></table><P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-5b.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>

<td valign=top>
Now grab the frame of the window with the mouse and pull down until eight rows of <font face=Kapl>a</font>
 are exposed.
<pre><font face=Kapl>     `rows of `a
&lt;  8</font></pre>
This should look pretty much the same as executing the code<br>
<pre><font face=Kapl>     `a has (`rows;8)</font></pre>
Intuitively, however, they seem to be quite different. In the first case, the size of
 <font face=Kapl>a</font> is a function of the size of its parent
 <font face=Kapl>b</font>, while in the second case, the size of <font face=Kapl>b</font>
 is a function of the size of its child <font face=Kapl>a</font>.</td></row>
</table><P>
Since the second case will only arise when the program explicitly sets an attribute, there
 is no real need to constrain or control that kind of resizing. But in the first case, you
 might want to keep <font face=Kapl>a</font> from being resized no matter what the user
 does to change the size of <font face=Kapl>b</font>. In this example, you will want to set
 the "don't grow in height" constraint on a:<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-5c.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td valign=top>
<pre><font face=Kapl>     `a has (`resize;'H')</font></pre>
As the window <font face=Kapl>b</font> is resized, <font face=Kapl>a</font> will hang on to its five-row display,
 centering itself in <font face=Kapl>b</font>-space.<P>
What is actually going on, and what will help in understanding some of the examples to come,
 is this: suppose you stretch <font face=Kapl>b</font> to include 100 additional height pixels. The layout
 receives the message<br>
"distribute 100 additional pixels over your rows"<br>
in response to which it expands its only row by 100 pixels. The row of the layout then sends
 to each of its children - in this case, just <font face=Kapl>a</font> - <br>
"grow by 100 additional pixels"<br>
But <font face=Kapl>a</font> is H-constrained, and refuses to comply.</td></row></table><P>
Consider the case:<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-5d.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>

<td valign=top>
<pre><font face=Kapl>     aûbûÉ10
     cû&lt;`a`b
     `a has (`resize;'H')
     show `c is `layout</font></pre>
In this example, only <font face=Kapl>a</font> is constrained. Resizing the layout <font face=Kapl>c</font> has the
 effect of giving extra space to the sole row of <font face=Kapl>c</font>, which in turn has the effect of
 giving extra space to each child in that row. Array <font face=Kapl>a</font> rejects the space while
 <font face=Kapl>b</font> accepts it.</td></row></table><P>
In an example involving more than one row:<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-6a.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>

<td valign=top>
<pre><font face=Kapl>     aûbûcûÉ10
     dû(`a;`b;`c)
     show `d is `layout</font></pre>
Resizing <font face=Kapl>d</font> 300 pixels larger will cause <font face=Kapl>d</font> to send three messages, one to
 each of its rows:<br>
"grow by <font face=Kapl>Ä300ß3</font> additional pixels"<br>
which in turn causes each row to send to its child the message to grow by that amount. In
 this case, all three children will expand. But if we were to set the H-constraint on
 <font face=Kapl>b</font>:
<pre><font face=Kapl>     `b has (`resize;'H')</font></pre>
then we would see that <font face=Kapl>a</font> and <font face=Kapl>c</font> each take their share of the extra space,
 but <font face=Kapl>b</font> does not, as shown.</td></row></table><P>
The "H" attribute is paired with one for constraining width, called, appropriately enough,
 "W".
</blockquote>
<A NAME=HEADING438>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Constraints on Resizing Layout Structures</FONT></H3>
<blockquote>
Where only constraints on objects are set, resizing the layout causes each of its rows to
 accept a share of the extra space. You will have noticed that while this method keeps
 constrained objects from changing size, it does not keep the rows or columns containing
 these objects from being resized. In the example given above, where <font face=Kapl>b</font> is
 constrained by "H", what you might have expected was that <font face=Kapl>a</font> and <font face=Kapl>c</font> would
 absorb all the extra space, leaving <font face=Kapl>b</font> the same size, <i>and</i> leaving the amount
 of space taken up by the second virtual row of the layout unchanged. Instead, <font face=Kapl>b</font>
 appears to be floating in empty layout-space. How do you keep <font face=Kapl>b</font> "glued" to
 <font face=Kapl>a</font> above and <font face=Kapl>c</font> below?<P>
Recall that a resize causes the layout to send messages of the form<br>
"grow/shrink by n pixels"<br>
to each of its rows (or columns), which in turn send messages of the form<br>
"grow/shrink by n pixels"<br>
to each of their children. "H" and "W", set on objects, allow these objects to reject such
 requests, and remain the same size. We want a similar ability for the virtual rows and
 columns of a layout, which would enable them to reject resize requests they receive from
 the layout:<P>
<pre><font face=Kapl>     aûbûcûÉ10
     dû`a`b`c
     `b has (`resize;'h')
     show `d is `layout</font></pre>
Now suppose you expand <font face=Kapl>d</font> by 300 height-pixels. <font face=Kapl>d</font> receives the message:<br>
"grow in height by 300 pixels."<br>
It then asks each of its rows,<br>
"can you grow in height?"<br>
to which rows 0 and 2 reply "yes" and 1 replies "no". <font face=Kapl>d</font> then sends the following
 messages:<P>
to row 0: "grow by <font face=Kapl>Ä300ß2</font> pixels"<BR>to row 2: "grow by <font face=Kapl>Ä300ß2</font> pixels"<P>
which in turn send resize messages to their children. But note that row 1, having replied
 "no" to the message asking whether it could be resized, receives no such message from the
 layout. Consequently, no "H" constraint need be placed on any object in row 1.<P>
The "h" attribute is similarly paired with one for constraining column width, "w".
</blockquote>
<A NAME=HEADING439>
<H3><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Constraining Layout Structure by Way of the Objects</FONT></H3>
<blockquote>
While syntactically both forms of resize constraint are placed on objects in a layout,
 semantically they are quite distinct. "H" and "W" constrain the resizing of objects; "h" and
 "w" constrain the resizing of the structure containing the objects on which these
 constraints are placed. What this means is that "h" or "w" placed on an object will
 indirectly constrain all other objects on the same row or column. E.g.,
<pre><font face=Kapl>     aûbûcûÉ10
     dû(`a;`b `c)
     `b has (`resize;'h')
     `d is `layout</font></pre>
"h", set on <font face=Kapl>b</font>, propagates upward to row 1 of the layout, and hence downward in its
 effects to <font face=Kapl>c</font>. All extra space accumulates in row 0 of the layout.
<A NAME=HEADING440>
<H2><FONT color="#20B2AA">Repositioning Objects in a Layout</FONT></H2>
<blockquote>
Consider once again the example:<P>
<table border=0 cellspacing=0 cellpadding=0>
<row><td><img src="APlusRef_ScrnMgmt_1-6b.gif" alt="example">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>

<td valign=top>
<pre><font face=Kapl>     aûbûcûÉ10
     dû(`a;`b;`c)
     show `d is `layout
     `b has (`resize;'H')</font></pre>
Resizing the layout by 300 pixels causes row 1 to grow, but <font face=Kapl>b</font> is constrained. The
 extra space is allocated: half above <font face=Kapl>b</font>, half below. In other words, <font face=Kapl>b</font> is
 vertically centered in the row. Suppose we wanted <font face=Kapl>b</font> to stick to the top of its
 row as it grows:
<pre><font face=Kapl>     `b has (`resize;'t')</font></pre>
This causes the extra space given to row 1 to be allocated: all below <font face=Kapl>b</font>, as shown.
</td></row></table><P>
Other justification options are:
<pre></font><font face=Kapl>     `b has (`resize;'b')        ã </font>Stick to the bottom.<font face=Kapl>
     `b has (`resize;'l')        ã </font>Stick to the left.<font face=Kapl>
     `b has (`resize;'r')        ã </font>Stick to the right.</pre>
Justification options can be paired in obvious ways:
<pre></font><font face=Kapl>     `b has (`resize;'lt')       ã </font>Stick left and top.</pre>
but, of course, the following pair is inconsistent, and s will use the one it prefers,
 top, for:
<pre></font><font face=Kapl>     `b has (`resize;'tb')       ã </font>Stick top and bottom.</pre>
</blockquote>
<A NAME=HEADING441>
<H3><FONT color="#20B2AA">Default Constraints</FONT></H3>
<blockquote>
A+ classes such as table and array which come with the concepts of rows and columns are
 instantiated with no resize constraints. It is assumed that most uses of array will allow
 for resizing. Other classes, such as label and button, are constrained in the height
 direction, and are instantiated with both "h" and "H" constraints. No width constraints are
 set by default on any classes.<P>
For default constraint information, enter, e.g.:
<pre><font face=Kapl>     `resize s.defaultOf `button<BR>&lt;  hH</font></pre>
</blockquote>
<A NAME=HEADING442>
<H3><FONT color="#20B2AA">The resize Attribute</FONT></H3>
<blockquote>
The resize attribute is cumulative in its settings unless a period is included somewhere
 in its value:
<pre></font><font face=Kapl>     `a is `button
     `resize of `a
&lt;  hH                      ã </font>Default constraints.<font face=Kapl>
     `a has (`resize;'W')  ã </font>Set<font face=Kapl> 'W' </font>cumulatively.<font face=Kapl>
     `resize of `a
&lt;  hHW
     `a has (`resize;'lt') ã </font>Set<font face=Kapl> 'l' </font>and<font face=Kapl> 't' </font>cumulatively.<font face=Kapl>
     `resize of `a
&lt;  lthHW                   ã </font>Accumulated.</pre>
To set constraints noncumulatively:
<pre></font><font face=Kapl>     `a has (`resize;'lt.') ã </font>Set<font face=Kapl> 'l' </font>and<font face=Kapl> 't'
                            ã </font>noncumulatively, using a period.<font face=Kapl>
     `resize of `a
&lt;  lt                    ã </font>Not accumulated: just <font face=Kapl>'l'</font> and <font face=Kapl>'t'</font></pre>
To reset the default constraints:
<pre></font><font face=Kapl>     `a has (`resize;)   ã </font>Set to null.<font face=Kapl>
     `resize of `a
&lt;  hH                    ã </font>Default constraints.</pre>
To eliminate all constraints:
<pre></font><font face=Kapl>     `a has (`resize;'') ã </font>Set to<font face=Kapl> ''</font>. Could have used<font face=Kapl>
                         ã '.' </font>with the same result.<font face=Kapl>
     `resize of `a
&lt;                        ã </font>No constraints.</pre>
</blockquote>
</blockquote>
<A NAME=HEADING443>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;The Geometry of Slotfiller
 Objects</FONT></H2>
<blockquote>
A+ currently supports five slotfiller classes:  slot, radio, choice, check, and action.
 Typically, the A+ variable of a slotfiller class has the form:
<pre><font face=Kapl>     (`sym ... `sym;(val;...;val))</font></pre>
<A NAME=HEADING444>
<H3><FONT color="#20B2AA">Partition Vector Form</FONT></H3>
<blockquote>
The method for controlling the geometry of slotfiller objects is strongly analogous to the
 one used to position objects in a layout. Conceptually, slotfillers possess row-column
 structure, within which components can be positioned and which they may span. For example,
 the slotfiller
<pre><font face=Kapl>     sfû(`one `two `three;(10;20;30))</font></pre>
can be laid out as<P>
<img src="APlusRef_ScrnMgmt_1-7a.gif" alt="example"><P>

through the geometry setting:
<pre><font face=Kapl>     `sf has (`geometry;1 2)</font></pre>
which specifies: one object on the first row, two objects on the second row. Implicitly, the
 first object spans two columns, each of the other two span one column.<P>
Note that geometry settings of this form are partition vectors:
<pre><font face=Kapl>     1 2Ú 0Øsf
&lt;  `one
&lt;  `two `three</font></pre>
</blockquote>
<A NAME=HEADING445>
<H3><FONT color="#20B2AA">Index Matrix, or Canonical Form</FONT></H3>
<blockquote>
A more general method for controlling geometry is, once again, strongly analogous to the
 method of canonical representation for layouts. Consider the geometry for <font face=Kapl>sf</font>
 shown as<P>
<img src="APlusRef_ScrnMgmt_1-7b.gif" alt="example"><P>

where the object <font face=Kapl>one</font> spans two rows, and <font face=Kapl>two</font> and <font face=Kapl>three</font> each span
 a single row. This is obtained by means of:
<pre><font face=Kapl>     `sf has (`geometry;2 2Ò0 1 0 2)</font></pre>
Note that
<pre><font face=Kapl>     !@ ¢1 Î(2 2Ò0 1 0 2)#0Øsf
 one  two
 one  three</font></pre>
</blockquote>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Placeholder Indices in the Canonical Form</b>
<blockquote>
Consider the geometry:
<pre><font face=Kapl>one: ___10    two: ___20
              three: ___30</font></pre>
where the lower left quadrant is empty. This is obtained by means of:
<pre><font face=Kapl>     `sf has (`geometry;2 2Ò0 1 ¢1 2)</font></pre>
where -1 plays the same role in geometry arrays as <font face=Kapl>`</font> does in layout variables.
</blockquote>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbolic Geometry</b>
<blockquote>
The s functions will translate symbolic matrices into geometry matrices:
<pre><font face=Kapl>     `sf has (`geometry;2 2Ò `one `two ` `three)</font></pre>
is equivalent to
<pre><font face=Kapl>     `sf has (`geometry;2 2Ò0 1 ¢1 2)</font></pre>
for slotfillers containing the symbols <font face=Kapl>`one</font>, <font face=Kapl>`two</font>, and <font face=Kapl>`three</font>.
</blockquote>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Horizontal Geometry</b>
<blockquote>
The default geometry for a slot is 1; i.e., <font face=Kapl>(#0Øsf)Ò1</font>. Horizontal geometry for any
 slot is <font face=Kapl>#0Øsf</font>. For convenience, this can be specified simply as
<pre><font face=Kapl>     `sf has (`geometry;¢2)</font></pre>
</blockquote>
</blockquote>
<A NAME=HEADING446>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Making Objects Equal Sizes</FONT></H2>
<blockquote>
Consider
<pre><font face=Kapl>     aû(`one `thirteen `twelve `seven;(;;;))
     `a has (`geometry;¢2)
     show `a is `action</font></pre>
The buttons have different widths, and grow and shrink proportionally as the object is
 resized. Objects with geometry - layouts and slotfillers - can be constrained by the R and C
 attributes:
<pre><font face=Kapl>     `a has (`C;1)</font></pre>
causes all buttons in <font face=Kapl>a</font> to assume the size of the button with maximum width, namely,
 <font face=Kapl>thirteen</font>.<P>
The R constraint has the same effect on rows:
<pre><font face=Kapl>     aûÉ10
     bû20
     cû`a`b
     show `c is `layout
     `c has (`R;1)</font></pre>
now causes <font face=Kapl>b</font> to assume the height of <font face=Kapl>a</font>.<P>
One consequence of making sizes equal is that virtual row or column ratios can be used to
 indicate the proportional sizing of objects. For example, compare
<pre><font face=Kapl>     aûÉ3 4
     bûÉ10
     cû`a`b
     show `c is `layout</font></pre>
with
<pre><font face=Kapl>     aaûÉ3 4
     bbûÉ10
     ccû1 4Ò`aa`aa`aa`bb
     `cc is `layout
     `cc has (`C;1)
     show `cc</font></pre>
Both <font face=Kapl>a</font> and <font face=Kapl>aa</font> are at <font face=Kapl>0 0 1 3</font> and <font face=Kapl>b</font> and <font face=Kapl>bb</font> are
 at <font face=Kapl>0&nbsp;3&nbsp;1&nbsp;1</font>, but only in <font face=Kapl>cc</font> does virtual-columns span
 determine relative width.
</blockquote>
<A NAME=HEADING447>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Locking and Zooming</FONT></H2>
<blockquote>
Suppose you have a layout of four graphs:
<pre><font face=Kapl>     aaûbbûccûddûÉ10
     (a;b;c;d)û(`aa;`bb;`cc;`dd)
     `a`b`c`d is¡`graph
     mû`a`b`c`d
     `m is `layout
     m has¡((`at;0 0);(`at;0 1);(`at;1 0);(`at;1 1))
     show `m</font></pre>
You might like a mechanism whereby one of the graphs can be "zoomed" to fill the entire
 layout and later restored to its original cell. Note that <font face=Kapl>m</font> is not
 representational: the graphs are explicitly positioned using <font face=Kapl>`at</font>.<P>
<pre></font><font face=Kapl>     Zû()     ã </font>Symbol of the graph that has been zoomed.</pre>
Consider the function
<pre><font face=Kapl>zoom{x}:
      {
      if (x½())
              {
              if (~Z½())
                    {
                    iûmÉZ;
                    sû2 2Îi;
                    yxsû`ys `xs of 0#(m¨Z)/m;
                    hide Z;
                    Z has (`ys `xs `at;yxs,&lt;s,1 1);
                    show Z;
                    }
              }
     else
              {
              if (~Z½()) &amp;{()};
              x has (`at `raise;(0 0 2 2;1));
              };
     .Zûx;
     }</font></pre>
If the argument to <font face=Kapl>zoom</font> is nonnull, then (1)&nbsp;if something is
 zoomed, "unzoom" it (see below), and then (2)&nbsp;zoom the object named. To zoom an
 object, reposition it at 0&nbsp;0 with a span of 2&nbsp;2 and raise it to the front.<P>
If the argument to <font face=Kapl>zoom</font> is null and something is zoomed, "unzoom" it by translating
 its index in <font face=Kapl>m</font> to a position in the layout, get the pixel extent of some other
 (arbitrary) child of <font face=Kapl>m</font>, hide the object, reset its position and extent, and reshow
 the object.<P>
These roundabout procedures are necessary because an attempt to reposition the object that
 was zoomed will cause the layout to expand to accommodate the extent of the formerly zoomed
 object.<P>
The attribute lock on layouts (and their subclasses) can be turned on, after showing, to
 force the downsizing of an object that is being positioned so that the object will fit into
 the cell. In other words, the layout will not expand to fit the object, but will force the
 object to fit the layout. Now consider the <font face=Kapl>zoom</font> function, rewritten to operate on
 locked layouts;
<pre><font face=Kapl>     `m has (`lock;1)

     zoom{x}:
            {
            if (x½())
               {
               if (~Z½()) Z has (`at;(2 2ÎmÉZ),1 1);
               }
            else
               {
               if (~Z½()) &amp;{()};
               x has (`at `raise;(0 0 2 2;1));
               };
            .Zûx;
            }</font></pre>
</blockquote>
<A NAME=HEADING448>
<H2><FONT color="#20B2AA">&nbsp;&nbsp;&nbsp;Natural Size Action</FONT></H2>
<blockquote>
Consider
<pre><font face=Kapl>     aûbûcûÉ10
     dû(`a;`b `c)
     show `d is `layout</font></pre>
Resize the layout </font><font face=Kapl>d</font>. Now execute
<pre><font face=Kapl>     `d has `naturalsize</font></pre>
The layout sends the naturalsize message to each of its children. A primitive object that
 receives the naturalsize message recomputes its natural size (see "<A HREF="#61">The
 Natural Size of Objects</A>"). After each child recomputes its natural size and transmits
 it to the parent, the parent recomputes its own size.
</blockquote>
<HR>
<ADDRESS><table width="100%"><tr><td><font size=2><i><a href="mailto:doc@aplusdev.org">doc@aplusdev.org</a></i></font></td><td align=right><font size=2><i>&#169; Copyright 1995&#150;2008 Morgan Stanley Dean Witter &amp; Co.  All rights reserved.</i></font></td></tr></table></ADDRESS>
</BODY>
</HTML>
