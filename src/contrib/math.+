
ã Stray math functions

ã Data directory for .m files
dotmdirû"/usr/local/aplus-fsf-4.22/contrib/"

ã Basics
ã ¢¢¢¢¢¢

gcd {x;y} : {
ã 6-10-1989 ð Sitte
ã Greatest common denominator; Euclidean algorithm
	bû0¨zûx|y;
	rû(~b)«|x;
	if (©/bû,b) rûr+(Òr)Òb\(b/,z) gcd b/(«/Òz)Òx;
	if (^/`int=(©x),©y) `int©r else r
	}

lcm {x;y} : {
ã 6-10-1989 ð Sitte
ã Least common multiple; calls gcd
	rûx«yßx gcd y;
	if (^/`int=(©x),©y) if ((^/,r¤2147483647)^^/,r¦¢2147483648) rû`int©r;
	r
	}

gcdmult {abc} : {
ã 5-15-1996 ð Sitte
ã Greatest common denominator of a vector; Euclidean algorithm
	rûÉ0;
	while (1<#abcûr,(0¨abc)/abc) abcû(rûÄ/abc)|abc;
	if (`int=©abc) `int©r else r
	}

lcmmult {abc} : {
ã 5-15-1996 ð Sitte
ã Least common multiple of a vector; calls gcdmult
	rû|«/abc;
	rûrßgcdmult rßabc;
	if (`int=©abc) if ((r¤2147483647)^r¦¢2147483648) rû`int©r;
	r
	}

linindet {ab;c} : {
ã 5-13-96 ð Sitte
ã Linear indeterminate equation: integer solution of ax + by = c,
ã    using Euclidean algorithm
ã c is optional, defaults to 1
	if (0Å#c) cû1;
	abûab[sûçab]; rûÉ0;
	while (1¨¢1Ùab) {rûr,Äab[¢2+#ab]ß¢1Ùab; abûab,(¢1Ùab)|ab[¢2+#ab];
		if (0=¢1Ùab)
			if (0=(iû''Ò¢2Ùab)|c) {rûÉ0; cûcßi; abû(2Òab)ßi}
			else ûÉ0 ã c not divisible by gcd of a,b
		};
	Õab; Õrûr,1 0; cûc«(2|Òr)÷1 ¢1;
	(*iû(#r)-3) do r[i]ûr[i+2]+«/r[i+0 1];
	rûc«2Òr;
	if (iûÄÄ/|rßabû2Òab) rûr-ab«i««c;
	r[è÷(Òr)Òs]
	}

lincong {a;b;m} : {
ã 5-13-96 ð Sitte
ã Linear congruence: integer solution of ax ½ b (mod m)
ã The result is the apv of the solution set (r[0]+r[1]«Ér[2])
	dûm gcd a; if (0¨d|b) ûÉ0;
	rûlinindet {(a,-m)ßd;bßd};
	((mßd)|''Òr),(mßd),d
	}

primes {n} : {
ã 5-1-83 ý 9-15-83 ð M.K. Rosenberg
ã Generate prime numbers via the sieve of Eratosthenes
ã By Rowe & Stoneburner, the Upjohn Company
ã (Much faster in APL, which used boolean data type (= 1 bit))
	pûnÒbû1; nsûÄ.5+n*.5;
	while (ns¦bûb+1+(bÕp)É1) pûp^(bÒ1),bÕnÒ~(-b)Ù1;
	1+p/Én
	}

factorize {i} : {
ã 12-13-1986 ð Sitte
ã Factors of integer i
	fû1Õ primes {Äi*.5};
	f2ûfû(i=lcm {i;f})/f;
	iû`int©Ä.5+iß«/f;
	while (#f2û(1¨i gcd f2)/f2) {
		iû`int©Ä.5+iß«/f2;
		fûf,f2
		};
	f[èf],(i¨1)/i
	}

divisors {i} : {
ã 2-12-98 ð Sitte
ã Positive divisors of i
	fûfactorize i; fûf[nû(f¨1Õf,0)/ÉÒf]; nûn-¢1Õ¢1,n;
	fûf[mûçn] ; nûn[m]; dû(Ò,i)Ò1;
	(mûÒn) do dû,(1,f[m]*1+Én[m])Ê.«d;
	d[èd]
	}

eulertot {n} : {
ã 4-22-96 ð Sitte
ã Euler totient function: number of integers < and relatively prime to n
	Ä.1+n««/1-ß(f¨¢1Õ0,f)/fûfactorize n
	}

convolve {p;q} : {
ã 5-9-1987 ð Sitte
ã Convolution of two vectors of probabilities
ã   or, the coefficients of the polynomial product of two polynomials
	+/(-É#p) ÷@0 1 (pÊ.«q) ,@1 (0 ¢1+#p)Ò0
	}

combine {m;n} : {
ã 11-6-94 ð 7-17-95 ð Sitte
ã Returns all combinations of Én taken m at a time
	case 1 {
	 	((0¦m)©m>n);	0 0Ò0;
		(mÅ1,n);	m!Én;
		(m=2);		((÷Én)/Én) ,@0 Ø(1ÕÉn)Õ¡<Én;
		(m=n-1);	(Ém) +@1 (Én)Ê.>÷Ém;
		{
			cû1!kûÉ#bû(1+n-m)Ò1;
			(m-1) do cû(b/k) ,@¢1 (1+c)[(É+/b)+b/(#c)-+\bû÷+\÷b]
			}
		}
	}
			ã much clearer, much slower; re- and re-curses
			ã (0 ,@1Û 1+(m-1) combine n-1),1+m combine n-1

permute {n} : {
ã Returns all permutations of Én
ã Courtesy of Roger Hui
	if (1<n) !(ç@1 iÊ.=iûÉn)[;0,@1Û1+permute n-1] else É1,n
	}

partition {m;n} : {
ã All size m partitions of n ð Arthur Whitney
	kû1+ÉÄnß1Óm;
	case (1Óm) {
		1;	(m,m)Òn;
		2;	k ,@0 n-k;
		{	pû(m-1)partition n-1;
			cû1#Òp;
			bûkÊ.¤p[;0]Äp[;c-1]-p[;c-2]-1;
			zû((+/@1 b)/k) ,@¢1 p[(,b)/(«/Òb)ÒÉ#p];
			z[;c]ûz[;c]-z[;0]-1;
			z}
		}
	}

Stirling2 {m;n} : {
ã Stirling numbers of the second kind
ã Number of ways of partitioning n elements into m subsets
ã 8-24-95 ð Sitte
	Sû(+/(¢1*m-Ém+1)«binomial {Ém+1;m}«(Ém+1)*n)ßfactorial {m};
	if (S¤2147483647) `int©S else S
	}

Stirling1 {m;n} : {
ã Stirling numbers of the first kind
ã 8-24-95 ð Sitte
	Sûcase 1 {
		mÅ0,n;	m=n;
		m=1;	(¢1*n-1)«factorial {n-1};
		m=n-1;	-binomial {2;n};
		{Sû0; (kûn-m-1) do
			SûS+(¢1*k)«binomial{n+k-m;n+k-1}«binomial{n-m+k;n+n-m}«Stirling2{k;n+k-m}
			}
		};
	if ((S¤2147483647)^S¦¢2147483648) `int©S else S
	}

pyth {n;m} : {
ã 1-17-1987 ð Sitte
ã Pythagorean triangle triplets
ã m preferably odd, e.g.:  pyth {1+É5;1+2«É3}
	mû,m; nû,n;
	aûbûcû(2«n)Ê.«m;
	nû2«n*2; bûb +@1 0 n;; cûc +@1 0 n;
	mûm*2; ; aûa +@1 m; cûc +@1 m;
	a,¡b,¡c
	}

showpyth {n;m;spc} : {
ã 1-17-1987 ð Sitte
ã Display Pythagorean triangle triplets
ã m preferably odd, e.g.:  showpyth {1+É17;1+2«É5;}
ã Space between columns defaults to 2, can be set
	if (0ÅÒspc) spcû2;
	tripsûî ,@2 >pyth {n;m};
	rhoû(0ÂÒtrips)ß«/Òm;
	(((-spc)+(«/Òm)«rho+spc)Ò(rho,spc)/1 0) \@1 trips
	}

ã The n-th Fibonacci number & 2 preceding using O(log n) integer operations
ã Roger Hui
fib{n}: 1 1 0 1/,mpower {«É2 2;n-1}

fibs {n}: {
ã First n Fibonacci numbers ð Roger Hui algorithm, adapted
ã Faster than addition
	mûffû2 2Ò1 2 2 3.0; kû(iû1)+3«Ó(n-1)ß3; fûkÙ1 1 2 3.0;
	while (k>iûi+3) f[i+É3]û1 1 0 1/,ffûm+.«ff;
	if (n<47) fû`int©f;
	(¢3|n-1)Õf
	}

ã First year calculus:
ã ¢¢¢¢¢ ¢¢¢¢ ¢¢¢¢¢¢¢¢

(f LIMIT) arg : {
ã 9-22-1984 ð Sitte
ã Simple limit routine, test for monotonic convergence
ã Argument to f is supplied in the form (x;Èx;params) (for the simplest case,
ã   the first two must be added to get x+Èx)
ã arg is a two element nested vector (arg1;params)
ã   arg1 is a 1-, 2-, 3- or more element vector
ã     arg1[0] is the limit point x
ã     arg1[1] is the step size Èx to start with (optionally but not optimally supplied)
ã     arg1[2] is the factor by which Èx is successively decremented (.1 default)
ã   params, it any, are sent to the function as parameters, as indicated above
ã E.g.: f FDERIV LIMIT 5 .01 .6 (to increase precision of FDERIV)

	(arg;params)ûarg; bû~iû0;
	xû''Òargû,arg; hûh+.01«(x+x=0)«0=hû1#2Ùarg; decûdec+.1«0=decû2#3Ùarg;
	lûf (x;h;params);
	while (b) {
		hûdec«h;
		gûf (x;h;params);
		if (2<iûi+1) bû(c>0)^1>cû(g-l)ßd;
		dûg-Õl;
		if (bûb^(d¨0)©i=1) lûg
		};
	ã hûhßdec : would give you step size which came closest to the limit

	l
	}

(f FDERIV) arg : {
ã 9-22-1984 ð Sitte
ã Derivative by 4-point Lagrange interpolation
ã  (Does right-handed derivative, left-handed with negative step size)
ã arg is a 3 element enclosed vector
ã   0Øarg is x for f'(x), 1Øarg is the incremental step size Èx (optionally
ã     but not optimally supplied)
ã   If f has valence 2 or if it is ambivalent and 2Ø arg is not empty, then
ã     2Øarg is sent to the function as left argument
ã See LIMIT for optimization.--Abramowitz & Stegun Table 25.2

	(x;h;larg)û3Ùarg;
	if (0ÅÒh) hû(Òx)Ò0;
	hûh+.0001«(x+x=0)«h=0;
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	yûif (1=val) f +\1 3/x~h else larg f +\1 3/x~h;
	(¢11 18 ¢9 2+.«y)ß6«h
	}

(f SDERIV) arg : {
ã 9-22-1984 ð Sitte
ã Second derivative by 4-point Lagrange interpolation
ã  (Does right-handed derivative, left-handed with negative step size)
ã arg is a 3 element enclosed vector
ã   0Øarg is x for f'(x)
ã   1Øarg is the incremental step size Èx (optionally but not optimally supplied)
ã   If f has valence 2 or if it is ambivalent and 2Ø arg is not empty, then
ã     2Øarg is sent to the function as left argument
ã See LIMIT for optimization.--Abramowitz & Stegun Table 25.2

	(x;h;larg)û3Ùarg;
	if (0ÅÒh) hû(Òx)Ò0;
	hûh+.001«(x+x=0)«h=0;
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	yûif (1=val) f +\1 3/x~h else larg f +\1 3/x~h;
	(6 ¢15 12 ¢3+.«y)ß3«h«h
	}

(f INTEG) abc : {
ã 9-21-1984 ð Sitte
ã Integration by Romberg algorithm with extrapolation to the limit
ã arg is a 2 element nested vector (abc;larg)
ã   abc is a three element vector:
ã     abc[0 1] are the lower and upper limits of integration
ã     abc[2] is the desired number of significant digits in the result
ã   larg is sent to the function as left argument if the function has
ã     valence 2 or if it is ambivalent and larg is non-empty
ã Cf. H-P Journal August '80; Davis & Rabinowitz

	midû.5«+/2Òabc; rngûabc[1]-abc[0]; largû3Õabc; kû0;
	ppû_gsv `pp; _ssv{`pp;2#abc};
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	vû,.75«yûrng«sûif (1=val) f mid else larg f mid;
	while (~(Õîyûk#v)½îy) {
		kûk+1; uû(¢1+k2)+(2«k2)«Éßk2û2*-k; 
		if (1=val)
			sûs++/(1-u«u)«f mid+.25«rng«u«3-u«u
		else
			sûs++/(1-u«u)«larg f mid+.25«rng«u«3-u«u;
		vû(.75«rng«s«k2),v;
		(iûk) do v[i+1]ûv[i]+(v[i]-v[i+1])ß¢1+4*i+1
		};
	_ssv{`pp;pp};
	y
	}

(f INTEGGAUSLEG) abnml : {
ã 10-10-88 ð Sitte
ã Integration by Gauss-Legendre quadrature (between finite limits, piecewise integrable)
ã na is a 5 element enclosed vector:
ã   abnml[0 1] is the lower and upper limits of integration
ã   2Øabnml is the number of points to sample per interval
ã   3Øabnml is the number of intervals into which to subdivide the range (defaults to 1)
ã   4Øabnml is optional, if present is sent to the function as left argument
ã Requires legpolynom, legroots, binomial, gamma, loggamma

	(a;b;n;m;larg)ûabnml; if (0ÅÒm) mû1;
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	rngû(b-a)ß2«m; sumû(a-rng)+(2«rng)«1+Ém;
	xûnØlegroots;
	wtsû(m«Òx)Ò2ß(1-x*2)«(x Â@0 1 (n-Én)«¢1Õlegpolynom {n})*2;
	xû,sum +@0 1 rng«x;
	rng«wts+.« if (1=val) f x else larg f x
	}

(f INTEGGAUSLAG) nal : {
ã 10-10-88 ð Sitte
ã Integration by Gauss-Laguerre quadrature (between finite limit and Inf)
ã nal is a 3 element enclosed vector:
ã   0Ønal is the number of points to sample
ã   1Ønal (optional, defaults to 0) is the lower limit of integration
ã   2Ønal is optional, if present is sent to the function as left argument
ã Requires lagpolynom, lagroots, factorial, binomial, gamma, loggamma

	(n;a;larg)ûnal; if (0ÅÒa) aû0;
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	xûnØlagroots;
	wtsûx Â@0 1 lagpolynom {;n+1};
	wtsûxß(wts«n+1)*2;
	(*-a)«wts+.« if (1=val) f x+a else larg f x+a
	}

(f INTEGGAUSHERM) nhl : {
ã 12-10-86 ð Sitte
ã Integration by Gauss-Hermite quadrature (between ¢Inf and Inf)
ã nhl is a 3 element enclosed vector:
ã   0Ønhl is the number of points to sample
ã   1Ønhl (optional, defaults to 1) is the divisor in the weight function
ã     if = 1, the weight function is *-x*2
ã     if ¨ 1, the weight function is *-(x*2)ß1#nhl (e.g., *-(x*2)ß2)
ã   2Ønhl is optional, if present is sent to the function as left argument
ã Requires hermpolynom, hermroots, factorial, binomial, gamma, loggamma

	(n;h;larg)ûnhl; hûif (~0ÅÒh) h*.5 else 1;
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	xûnØhermroots;
	wtsûx Â@0 1 hermpolynom {;n-1};
	wtsû((Ï1)*.5)ßnß(factorial {n-1})ßwtsß(2*n-1)ßwts;
	h«wts+.« if (1=val) f h«x else larg f h«x
	}

(f SECANT) arg : {
ã 9-21-84 ý 3-4-92 ð Sitte
	(guess1;guess2;epsilon;larg)ûarg;
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	xûguess1; hûguess2-guess1; if (0ÅÒepsilon) epsilonû0;
	hûh+.0001«(x+x=0)«h=bûjû0;
	epsilonûepsilon+.00000001«epsilon=0;
	if (^/,bûb©epsilon>|zûif (1=val) f x else larg f x) û(b;x) else xûx+h;
	while ((15¦jûj+1)>^/,bûb©epsilon>|yûif (1=val) f x else larg f x)
		{hû(b¤d¨0)«(h«y)ß(d=0)+dûz-y; xûx+h; zûy};
	(b;x)
	}

(f NRAPH) arg : {
ã 3-2-92 ð Sitte
ã Solve by Newton-Raphson method:
ã   x[n+1] = x[n]-f(x[n])ßf'(x[n])
ã Result tolerance and left argument to f optional
ã Returns (boolean of successful solve; solution)
	(guess;epsilon;larg)ûarg;
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	bûjû0; rhoûÒxûguess;
	if (0ÅÒepsilon) epsilonû.0000001;
	while ((15¦jûj+1)>^/,bûb©epsilon>|zûif (1=val) f x else larg f x) {
		dzûf FDERIV (x;;larg);
		if (^/b1û,dz¨0)
			xûx-zßdz
		else {
			(x;z;dz)û,¡(x;z;dz);
			if (©/b1) {
				kûb1/ÉÒb1;
	       			(k#x)û(k#x)-(k#z)ß(k#dz)
				};
			(k#x)û.9«(kû(~b1)/ÉÒb1)#x;
			xûrhoÒx
			}
		};
	(b;x)
	}

(f CAUCHYSOLVE) arg : {
ã 3-2-92 ð Sitte
ã Solve by Cauchy (second order Newton) solve method:
ã   f(x)= 0 =f(x[n])+(f'(x[n])«(x[n+1]-x[n]))+((f"(x[n])ß2)«(x[n+1]-x[n])*2
ã Result tolerance and left argument to f optional
ã Returns (boolean of successful solve; solution)
	(guess;epsilon;larg)ûarg;
	valûif (0=0Øvalûdo _valence{f}) 1Øval else 1+~0ÅÒlarg;
	bûjû0; rhoûÒxûguess;
	if (0ÅÒepsilon) epsilonû.0000001;
	while ((25¦jûj+1)>^/,bûb©epsilon>|zûif (1=val) f x else larg f x) {
	       	dzûf FDERIV (x;;larg);
       		d2zûf SDERIV (x;;larg);
		qû(dz«dz)-2«d2z«z;
		if (^/b1û,dz¨0) {
			xûx-2«zßdz+(«dz)«(0Óq)*.5;
			}
		else {
			(x;z;dz;d2z;q)û,¡(x;z;dz;d2z;q);
			if (©/b1) {
				kûb1/ÉÒb1;
	       			(k#x)û(k#x)-2«(k#z)ß(k#dz)+(«k#dz)«(0Ók#q)*.5
				};
			if (©/b2û(~b1)^0¨d2z«q¦0) {
				kûb2/ÉÒb2;
	       			(k#x)û(k#x)-((k#dz)-(«(k#dz)-(0=k#dz)«(«k#x)««k#d2z)«(k#q)*.5)ßk#d2z
				};
			if (©/kû~b1©b2) {
				kûk/ÉÒk;
				(k#x)û.8«k#x;
				};
			xûrhoÒx
			}
		};
	(b;x)
	}

ã Matrices
ã ¢¢¢¢¢¢¢¢

determinant m : {
ã Determinant of matrix m, by partial pivoting
ã 5-28-93 ð Sitte
	if (2¨#Òm) ÙÂ'domain error';
	nû#mû`float©m; if ((n=0)©n¨1#Òm) ÙÂ'domain error';
	sû1;
	(iû¢1+n) do {
		if (i¨kûi+''Òç|m[lûi+Én-i;i]) {
			((i,k)#m)û(k,i)#m;
			sû-s;
			}
		else if (0=m[i;i])
			û0;
		m[k;l]ûm[k;l]-m[kû1Õl;i]Ê.«m[i;l]ßm[i;i]
		};
	s««/0 0ôm
	}

determinant2 m : {
ã Determinant of matrix m, by partial pivoting
ã 5-28-93 ð Sitte
	if (2¨#Òm) ÙÂ'domain error';
	nû#m; if ((n=0)©n¨1#Òm) ÙÂ'domain error';
	case (#m) {
		1 ; ''Òm;
		2 ; (m[0;0]«m[1;1])-m[0;1]«m[1;0]; ã Now if we had -/, like a real APL...
		3 ; (+/«/@1(É3)÷m)-+/«/@1(-É3)÷m;
		{sû1; mû`float©m;
		(iû¢1+n) do {
			case (''Òç0,kû(Ó/|m[l;i]),Ó/|m[i;lûiÕÉn]) {
				0 ; û0;
				1 ; if (i¨kûi+(|m[l;i])É0#k) {((i,k)#m)û(k,i)#m; sû-s};
				2 ; if (i¨kûi+(|m[i;l])É1#k) {m[;i,k]ûm[;k,i]; sû-s}
				};
			m[k;l]ûm[k;l]-m[kû1Õl;i]Ê.«m[i;l]ßm[i;i]
			};
		s««/0 0ôm}
		}
	}

ccd {m} : {
ã Anscombe p. 390 ð 8-10-1985 ð Sitte
ã Complete Cholesky Decomposition
	if ((0ÅÒm)©2¨ÒÒm) ÙÂ'non-matrix';
	if (~m½ôm) ÙÂ'non-symmetric';
	nû''ÒÒtû(Òm)Ò0.0;
	(iûn) do {
		uû(iÕm[i;])-u[;0]+.«uû(i-n) Ù@1 iÙt;
		if (0¦''Òu) ÙÂ'non-positive-definite';
		t[i;i+Én-i]ûußu[0]*.5
		};
	t
	}

mpower{m;n}: {
ã Raising matrix m to the n-th power by repeated squaring ð Roger Hui
	nûn«sû«n; zûif (2|n) m else (Òm)Ò(1+#m)Ù1;
	while (nûÄnß2) {mûm+.«m; if (2|n) zûz+.«m};
	if (s¨¢1) z else ­z
	}

ã Gammas and factorials:
ã ¢¢¢¢¢¢ ¢¢¢ ¢¢¢¢¢¢¢¢¢¢

gamma {x} : {
ã Gamma function ð 7-21-1994 ð Sitte
ã Abramowitz & Stegun 6.1.40, with error correction (Kuki CACM 15-4)
	rhoûÒx; bû(¢10,10-1e-10)èxû,x; gû(Òb)Ò0.0;
	if (©/mûb=1) (m/g)ûgamma {1+m/x}ßm/x; ã ¢10 < x < 10
	ã limit recursion, for x ¤ ¢10:
	if (0Åb) (m#g)ûgamma {1+10+1|m#x}ßØ«/¡(<@0 m#x)+¡É¡10-(mû(b=0)/ÉÒb)#x;
	if (2Åb) {
		bernû÷1 ¢1 1 ¢1 5 ¢691 7ß6 30 42 30 66 2730 6«m«¢1+mû2«1+É7;
		(m/g)û((Ï2)*.5)«(y*y-.5)«*(-y)+((ßy«y) Â@0 1 bern)ßyû(mû2=b)/x
		};
	if (©/bû(x-1)=Ä|x-1) (b/g)ûÄ.5+b/g;
	if (`int=©x) if (^/b) if (13¦Ó/x) gû`int©g;
	rhoÒg
	}

factorial {x} : gamma {x+1}

loggamma {x} : {
ã Log of the gamma function ð 6-6-1995 ð Sitte
ã Abramowitz & Stegun 6.1.40, with error correction
	rhoûÒx; bû10>xû,x; lgû(Òb)Ò0.0;
	if (©/b) {
		if (©/b1ûb^(x-1)=Ä|x-1) (b1/lg)ûðØ«/¡1Õ¡É¡(b1/x)+1=b1/x;
		if (©/b2ûb^~b1) (b2/lg)ûðgamma {b2/x}
		};
	if (0Åb) {
		bernû÷1 ¢1 1 ¢1 5 ¢691 7ß6 30 42 30 66 2730 6«m«¢1+mû2«1+É7;
		((~b)/lg)û((ðy)«y-.5)-y-(.5«ðÏ2)+((ßy«y) Â@0 1 bern)ßyû(~b)/x
		};
	rhoÒlg
	}

binomial {w;z} : {
ã 7-21-1994 ð Sitte
ã Binomial function
	bigû140<zÓwÓz-w;
	rhoûÒbig; zû(«/rho)Òz; wû(#z)Òw; cû(#z)Ò0.0;
	if (^/bû(w¨Ä.5+w)©z¨-Ó|.5+z) {
		if (~©/big)
			cûgamma {z+1}ßgamma {w+1}«gamma {1+z-w}
		else {
			(b2/c)ûgamma {1+b2/z}ßgamma {1+b2/w}«gamma {1+(b2/z)-(b2û~big)/w};
			(big/c)û*loggamma {1+big/z}-loggamma {1+big/w}+loggamma {1+(big/z)-big/w};
			};
		}
	else {ã Special case negative integers to avoid InfßInf
		(b2/c)ûgamma {1+b2/z}ßgamma {1+b2/w}«gamma {1+(b2/z)-(b2ûb^~big)/w};
		(b2/c)û*loggamma {1+b2/z}-loggamma {1+b2/w}+loggamma {1+(b2/z)-(b2ûb^big)/w};
		bû(~b)/ÉÒb; ã z a negative integer in both the following
		if (#b2û(w[b]=-Ó|.5+b#w)/b) ã w a negative integer
			c[b2]û(¢1*2|z[b2]+w[b2])«(¢1-b2#z) binomial ¢1-b2#w;
		if (#b2û(w[b]=Ä|.5+b#w)/b) ã w non-negative integer, z-w a negative integer
			c[b2]û(¢1*2|b2#w)«(b2#w) binomial w[b2]-1+b2#z;
		};
	if (©/bû(z=Ä.5+z)^w=Ä.5+w) (b/c)ûÄ.5+b/c;
	if (^/`int=(©z),©w) if (((¢2*31)¤Ä/c)^(2*31)>Ó/c) cû`int©c;
	rhoÒc
	}

multinomial {m;n} : {
ã 1-26-98 ð Sitte
ã Number of combinations of (+/m) out of n objects in m boxes, with m[k] in the k-th box
	mû,m; cû((0¨Òm)Ò0)Òmûm[çm];
	binomial{c;n}«factorial{n-c}ß«/factorial (1Õm),n-+/m
	}

beta {x;y} : {
ã 9-21-84 ð Sitte
ã Beta function
	ßy«binomial {x-1;x+y-1}
	}

incompletebeta {a;b;x} : {
ã Incomplete beta function ð Sitte
ã "Best results are obtained when x < ((aÓb)-1)ßa+b-2"
ã Handles array a,b,x (each same-sized array or scalar)
ã Abramowitz & Stegun 26.5.8 ð Sitte
	rhoûÒiû((1-x)«c«m+a-1)<x«(cû1 ¢1[2>a+b])«(b-1)+mû(a=1)^b=1;
	if (0=ÒÒm) if (^/,i=''Òi) iû''Òi;
	(a;b)û<@c (,i)÷ ,@1 ¢1[cû«ÒÒi] a~b; ã (keep scalar if scalar, vector otherwise)
	xû(«/rho)Òx; iûi/ÉÒx; (i#x)û1-i#x;
	cû((Òa),15)Ò0.0;
	((2«m) #@1 c)û-((aÊ.+m)«(a+b)Ê.+m)ß(aÊ.+2«m)«aÊ.+1+2«mûÉ8;
	mû1Õm;
	((2«m) #@1 c)û(m «@1 bÊ.-m)ß(aÊ.+2«m)«aÊ.+¢1+2«m;
	cûx «@0 1 c;
	pû1+c[;8]ß1+c[;9]ß1+c[;10]ß1+c[;11]ß1+c[;12]ß1+c[;13]ß1+c[;14];
	pûß1+c[;0]ß1+c[;1]ß1+c[;2]ß1+c[;3]ß1+c[;4]ß1+c[;5]ß1+c[;6]ß1+c[;7]ßp;
	pûp«(x*a)«((1-x)*b)ßa«beta{a;b};
	(i#p)û1-i#p;
	rhoÒp
	}

incompletegamma {a;x} : {
ã Incomplete gamma function
ã Abramowitz & Stegun 6.5.31 ð Sitte
	if (©/(,0>x),,0¦a) ÙÂ'domain error';
	if ((1¨Ò,a)^(1¨Ò,x)^(Ò,a)¨Ò,x) ÙÂ'domain error';
	rhoûÒx«a; xû,rhoÒx; aû(Òx)Òa; pû(Òx)Ò0.0;
	ãif (#iiû(bû(x¤1)©x<a)/ÉÒx) if (#iiû(0¨ii#x)/ii) {
	ã	iûÉ#qûii#x;
	ã	wû(q*aa)ß(*q)«factorial {aaûii#a};
	ã	vûq *@0 1Û 1+É5;
	ã	kû(sû(Òq)Ò1) +@0 1Û 1+É5;
	ã	qû(Òq)Ò0.0; hû(Òq)Ò1;
	ã	while (#pgûs) {
	ã		sûs+ +/@1 hûh «@0 1 vß «\@1 aa +@0 1 k;
	ã		kûk+5;
	ã		hûh[;4];
	ã		q[j/i]ûq[j/i]+(jûpg=s)/s;
	ã		jû(~j)/É#j;
	ã		(aa;h;v;k;s;i)û(<j)#¡(aa;h;v;k;s;i);
	ã		};
	ã	p[ii]ûw«q
	ã	};
	if (#iiû(~bû0)/É#b) {
		vûii#x; aaûii#a;
		wû(v*aa)ß(*v)«gamma {aa};
		qû9ßv+(10-aa)ß1+10ßv+(11-aa)ß1+11ßv+12-aa;
		qû6ßv+(7-aa)ß1+8ßv+(8-aa)ß1+8ßv+(9-aa)ß1+q;
		qû3ßv+(4-aa)ß1+4ßv+(5-aa)ß1+5ßv+(6-aa)ß1+q;
		p[ii]û1-wßv+(1-aa)ß1+ßv+(2-aa)ß1+2ßv+(3-aa)ß1+q
		};
	rhoÒp
	}

ã Orthogonal polynomials:
ã ¢¢¢¢¢¢¢¢¢¢ ¢¢¢¢¢¢¢¢¢¢¢

bernpolynom {type;n} : {
ã 12-7-1989 ð Sitte
ã if type ½ `poly, returns the coefficients of Bernoulli polynomial of degree n
ã if type ½ `nums, returns the first n+1 Bernoulli numbers
	bû(n+1)Ùrû(-n=0)Õ1 ¢.5;
	(iûn-1) do {
		rû(r«(i+2)ß÷1+Éi+2),0;
		b[i+2]ûr[i+2]ûif (2|i+1) (.5Âr)ß¢2+2*¢1-i else 0
		};
	case (type) {
		`poly; r;
		`nums; b;
		Ù`domain
		}
	}

chebpolynom {kind;n} : {
ã 1-6-1991 ð Sitte
ã Returns coefficients of Chebyshev polynomial of degree n
ã Use kind ½ `first for polynomial of the first kind, ½ `second for the second kind
	if (kindÅ`first `second) firstûkind=`first else Ù`domain;
	mûn-(0¤m+m-n)/mûÉn+1;
	rû((nß2«n-m)*first)«(¢1*m)«(2*n-m+m)«m binomial n-m;
	÷((Én+1)Ån-m+m)\r
	}

eulerpolynom {type;n} : {
ã 12-7-1989 ð Sitte
ã if type ½ `poly, returns the coefficients of Euler polynomial of degree n
ã if type ½ `nums, returns the first n+1 Euler numbers
	rû(-n=0)Õ1 ¢.5; eû(n+1)Ù1;
	(iûn-1) do {
		rû(r«(i+2)ß÷1+Éi+2),0;
		r[i+2]û¢.5«+/r;
		rû(2*-j)«Ä.5+r«2*jûÓ2ði+2;
		e[i+2]û2Â÷r
		};
	case (type) {
		`poly; r;
		`nums; e;
		Ù`domain
		}
	}

legpolynom {n} : {
ã 12-7-1986 ð Sitte
ã Returns coefficients of Legendre polynomial of degree n
	iû(0¤i+i-n)/iûÉn+1;
	rû(¢1*n-i)«(i binomial n)«(n binomial 2«i)ß2*n;
	÷((Én+1)Åi+i-n)\r
	}

ã The roots of the Legendre polynomial of degree n = nØlegroots
legrootsû(É1+Ä(2«#legroots)*.5)ÚlegrootsûÛàdotmdir,'legroots.m';

lagpolynom {a;n} : {
ã 10-10-1988 ð Sitte
ã Returns coefficients of (Generalized) Laguerre polynomial of degree n
ã Uses the weight function *-x, unless (optionally) the argument a has
ã   been specified, in which case it uses the weight function (*-x)«x*a
	if (0ÅÒa) aû0;
	(¢1*m)«((n-m) binomial n+a)ßfactorial mû÷Én+1
	}

ã Roots of the Laguerre polynomial of degree n = nØlagroots
lagrootsû(É1+Ä(2«#lagroots)*.5)ÚlagrootsûÛàdotmdir,'lagroots.m';

hermpolynom {two;n} : {
ã 12-7-1986 ð Sitte
ã Returns coefficients of Hermite polynomial of degree n
ã Uses the weight function *-x*2, unless (optionally) the argument two has
ã   been set to 2, in which case it uses the weight function *(-x*2)ß2
	mûn-(0¤m+m-n)/mûÉn+1; twoûif ((,2)½,two) m-n else 0;
	rû(¢1*m)«(2*two+n-m+m)«(factorial m)«(m binomial n)«m binomial n-m;
	÷((Én+1)Ån-m+m)\r
	}

ã The roots of the Hermite polynomial of degree n = nØhermroots
hermrootsû(É1+Ä(2«#hermroots)*.5)ÚhermrootsûÛàdotmdir,'hermroots.m';

ã Simple Statistics
ã ¢¢¢¢¢¢ ¢¢¢¢¢¢¢¢¢¢

moment {x;p;n;center} : {
ã 11-1-1994 ð Sitte
ã Calculates nth moment of distribution x about the center (`mean or `origin)
ã n may be a vector, calculate several moments at same time
ã center may also be vector of same length as n
ã p is optional, either vector of probability of x (1 ½ +/p)
ã  or function scalar (<{f}) which calculates probability of x from x
ã  (if p is empty, uniform distribution assumed (weight by ß#x))
ã
ã 			    Mean:	moment {x;p;1;`origin}
ã 			Variance:	moment {x;p;2;`mean}
ã  expected value wrt function f:	moment {f{x};p;1;`origin}

	if (`func=©p) pûmß+/mûp¡x else if (0Å#p) pû(Òx)Òß#x;
	mû(#n)Ò0.0; centerû(#n)Òcenter;
	if (©/bûcenter=`origin) (b/m)ûp+.«xÊ.*b/n;
	if (©/bûcenter=`mean) (b/m)ûp+.«(x-x+.«p)Ê.*b/n;
	(Òn)Òm
	}

skewness {p;x} : {skûmoment {x;p;2 3;`mean}; (1#sk)ß(0#sk)*1.5}

kurtosis {p;x} : {kuûmoment {x;p;2 4;`mean}; ¢3+(1#ku)ß(0#ku)*2}

standardize {type;p;x} : {
ã Standardize to mean 0, standard deviation 1
ã type is `population (or `pop; default) or `sample (or `samp)
ã See comments in moment for p
	nûnß(nû#x)-'samp'½4ÒÎtype;	ã Correction for sample
	zûmoment{x;p;1 2;`origin`mean};	ã Mean, variance
	(x-0#z)ß(n«1#z)*.5		ã (x-mean)ßs.d.
	}
